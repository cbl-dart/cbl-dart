import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Documents
> Description - Couchbase Lite concepts — Data model — Documents <br />
> Related Content -  Databases | Blobs | Indexing

## Overview

### Document Structure

In Couchbase Lite the term 'document' refers to an entry in the database; a record, or row in a table if you like.

Each document has an ID (primary key in other databases) by which it can be located. This ID can be automatically generated (as a UUID) or specified programmatically; the only constraints are that it must be unique within the database, and it can’t be changed. The document also has a value which contains the actual application data. This value is stored as a dictionary collection of key-value (k-v) pairs where the values themselves may comprise different types of data such as numbers, strings, arrays or even nested objects.

### Data Encoding
The document body is stored in an internal, efficient, binary form ([Fleece](https://github.com/couchbase/fleece#readme)).
This internal form is easily converted into a manageable native dictionary format for manipulation in applications.

Fleece data is stored in the smallest format that will hold the value, whilst maintaining the integrity of the value.

### Fleece data encoding

When working with Dart, the Fleece encoding cycle can result in the Dart type information being lost. So, care should be taken when storing and recovering data in a document - or converting that document to JSON and back - using non-explicit functions such as toPlainMap().

Always use explicit creation of the expected type, whenever the type of result is not itself explicit. For example:

```dart showLineNumbers
var doc = await db.document(documentId).toMap();
var testVal =  int.parse(doc['testInt']);
```

### Data Types

The Document class offers a set of property accessors for various scalar types, including boolean, integers, floating-point and strings. These accessors take care of converting to/from JSON encoding, and make sure you get the type you’re expecting.

So your document content may well comprise one or more supporting data types such as:

- Boolean
- Date
- Double
- Float

In addition to these basic data types Couchbase Lite provides for the following:

- Dictionary — represents a read-only key-value pair collection
- MutableDictionary — represents a writeable key-value pair collection
- Blob — represents an arbitrary piece of binary data
- Array — represents a readonly ordered collection of objects
- MutableArray — represents a writeable collection of objects

### JSON

Couchbase Lite also provides for the direct handling of JSON data implemented in most cases by the provision of a toJson() method on appropriate API classes (for example, on MutableDocument, Dictionary, Blob and Array).

## Constructing a Document

An individual document often represents a single instance of an object in application code. A document might be considered equivalent to a row in a relational table; with each of the document’s attributes being equivalent to a column.

Documents can contain nested structures. This allows developers to express many-to-many relationships without requiring a reference or junction table; and is naturally expressive of hierarchical data.

Most apps will work with one or more documents, persisting them to a local database and optionally syncing them, either centrally or to the cloud.

In this section we provide an example of how you might create a hotel document, which provides basic contact details and price data.

### Data model
```
hotel: {
  documentType: string (value = `hotel`)
  name: string
  address: dictionary {
    street: string
    city: string
    state: string
    country: string
    code: string
  }
  phones: array
  rate: float 
}
```

### Open a Database

First we open your database. If the database does not already exist, Couchbase Lite will create it for us.

```dart showLineNumbers
CouchbaseLiteFlutter.init();
// Initialize the Couchbase Lite system
final databaseDirectory = await getApplicationDocumentsDirectory();

// Get the directory information of where the database will be stored/opened from 
final cblDatabaseDirectory = databaseDirectory.subDirectory('databases');

//Get the configuration for the database
var dbConfig =
          DatabaseConfiguration(directory: cblDatabaseDirectory.path);

// Get the database (and create it if it doesn’t exist).
// highlight-next-line
var database = await Database.openAsync('getting-started', dbConfig);
```
 
### Create a Document 
Now we create a new document to hold our application’s data.

Because we will be adding data to the document we must use its mutable form.

```dart
var mutableDoc = MutableDocument.withId('hotel::1');
```

### Create a Dictionary 
Here we create a dictionary (address). Because we want to add values into the dictionary, we must create it in mutable form.

When the dictionary is retrieved, each element’s value is directly accessible via its own key.

```dart showLineNumbers
// Create and populate mutable dictionary
// Create a new mutable dictionary and populate some keys/values
var address = MutableDictionary(); 
address.setString('1 Main Street', key:'street');
address.setString('San Francisco', key:'city');
address.setString('CA.', key:'state');
address.setString('USA', key:'country');
address.setString('90210', key:'code');
```

### Create an Array

Since our hotel may have multiple lines we provide an array (phones) to hold contact numbers. Again, because we want to add values into the array, we create it in mutable form.

```dart
var phones = MutableArray();
phones.addString('555-555-0000');
phones.addString('555-555-0001');
```

### Populate a Document

Here we add our data to the mutable document we created earlier. Each data item is stored as a key-value pair.

```dart showLineNumbers
// Initialize and populate the document
// <1> Add document type to document properties
mutableDoc.setString('hotel', key:'documentType');

// <2> Add hotel name string to document properties
mutableDoc.setString('Hotel Dart Mo', key:'name');

// <3> Add float to document properties
mutableDoc.setFloat(121.75, key:'room_rate');

// <4> Add dictionary to document's properties
mutableDoc.setDictionary(address, key:'address');

// <5> Add array to document's properties
mutableDoc.setString(phones, key:'phones');
```
1. Add hotel name (string)
2. Add average room rate (float)
3. Add document type (string). Couchbase recommend using a type attribute to define each logical document type. 
4. Add address (dictionary) The address dictionary is added to the document and stored with the key address. We will use this to retrieve it when needed.
5. Add phone numbers (array) The phones arrary is added to the document and stored with the key phones. We will use this to retrieve it when needed.

### Save a Document 

With the document now populated, we can persist to our Couchbase Lite database.

```dart
var result = await database.saveDocument(mutableDoc);
```

### Close the Database

With our document saved, we can now close our Couchbase Lite database.

```dart
await database.close()
```

## Working with Data

### Checking a Document's Properties

To check whether a given property exists in the document, you should use the document [contains(String key)](https://github.com/cbl-dart/cbl-dart/blob/main/packages/cbl/lib/src/document/dictionary.dart#L84) method.

If the property doesn't exist, the call will return the default for that that method(0 for getInt(), 0.0 for getFloat(), etc.).

:::note
Care should be taken when storing and recovering data in a document or converting that document to JSON and back.

Data encoding (Fleece) can result in Long values being converted to Float instead of Double.  Interpreting data as boolean can also give inconsistent results.
:::

### Date accessors

As a convenience Couchbase Lite offers Date accessors. Dates are a common data type, but JSON doesn’t natively support them, so the convention is to store them as strings in ISO-8601 format.

###### Example 1 - Date Getter 

```dart
doc.setValue(DateTime.now(), key:'createdAt');
var date = doc.getDate('createdAt');
```


### Using Dictionaries
**API References**
- [Dictionary](https://pub.dev/documentation/cbl/latest/cbl/Dictionary-class.html)
- [MutableDictionary](https://pub.dev/documentation/cbl/latest/cbl/MutableDictionary-class.html)

###### Example 2 - Read only 

```dart showLineNumbers
// NOTE: No error handling, for brevity
var document = await db.document('doc1');

// Getting a dictionary from the document's properties
var dict = document?.dictionary('address')

// Access a value with a key from the dictionary
var street = dict?.string("street")

// Iterate dictionary
for (var key in dict!.keys) {
	debugPrint("Key $key = ${dict.value(key).toString()}");
}

// Create a mutable copy
var mutableDictionary = dict.toMutable();
```

###### Example 3- Mutable 

```dart showLineNumbers
// NOTE: No error handling, for brevity 

// Create a new mutable dictionary and populate some keys/values
var mutableDict = MutableDictionary();
mutableDict.setString('1 Main Street', key:'street');
mutableDict.setString('San Francisco', key:'city');

// Add the dictionary to a document's properties and save the document
var mutableDoc = MutableDocument.withId('doc1');
mutableDoc.setDictionary(mutableDict, key:'address')
await database.saveDocument(mutableDoc);

```

### Using Arrays 
**API References**
- [Array](https://pub.dev/documentation/cbl/latest/cbl/Array-class.html)
- [MutableArray](https://pub.dev/documentation/cbl/latest/cbl/MutableArray-class.html)

###### Example 4 - Read Only 

```dart showLineNumbers
// NOTE: No error handling, for brevity 
var document = await database?.document('doc1');

// Getting a phones array from the document's properties
var array = document?.array('phones');

// Get element count
var count = array?.length;

// Access an array element by index
val phone = array?.getString(1);

// Iterate array
array?.forEach((item) {
	debugPrint('Row {$item.toString}');
});

// Create a mutable copy
var mutableArray = array.toMutable();
````

###### Example 5 - Mutable 

```dart showLineNumbers
// NOTE: No error handling, for brevity

// Create a new mutable array and populate data into the array
var mutableArray = MutableArray();
mutableArray.addString('650-000-0000');
mutableArray.addString('650-000-0001');

// Set the array to document's properties and save the document
var mutableDoc = MutableDocument.withId('doc1');
mutableDoc.setArray(mutableArray, key: 'phones');
await database?.saveDocument(mutableDoc);
```

## Document Initializers

The following methods/initializers can be used:

The [MutableDocument](https://pub.dev/documentation/cbl/latest/cbl/MutableDocument/MutableDocument.htmll) constructor can be used to create a new document where the document ID is randomly generated by the database.

The [MutableDocument.withId(String id)](https://pub.dev/documentation/cbl/latest/cbl/MutableDocument/MutableDocument.withId.html) constructor can be used to create a new document with a specific document ID.

The [Database.document(String id)](https://pub.dev/documentation/cbl/latest/cbl/Database/document.html) method can be used to get a document. If it doesn’t exist in the database, it will return null. This method can be used to check if a document with a given ID already exists in the database.

###### Example 6. Persist a document
```dart showLineNumbers
var doc = MutableDocument();
doc.setString('task', key:'documentType');
doc.setString('todo', key:'owner');
doc.setDate(DateTime.now(), key: 'createdAt');
await database.saveDocument(doc);
```

## Mutability

By default, when a document is read from the database it is immutable. The [Document.toMutable()](https://pub.dev/documentation/cbl/latest/cbl/Document/toMutable.html) method should be used to create an instance of the document which can be updated.

###### Example 7. Make a mutable document

```dart showLineNumbers
var document  = await database.document('xyz');
var mutableDoc = document.toMutable();
if (mutableDoc != null) {
	mutableDoc.setString('new value', key:'key');
	await database.saveDocument(mutableDoc);
}
```
:::caution
Any user change to the value of reserved keys (_id, _rev or _deleted) will be detected when a document is saved and will result in an exception.
:::

## Batch operations
If you’re making multiple changes to a database at once, it’s faster to group them together. The following example persists a few documents in batch.

###### Example 8. Batch operations

```dart showLineNumbers
database.inBatch(() async {
 for (var index = 0; index <= 9; index++) {
   var doc = MutableDocument();

   doc.setValue('user', key: 'type')
   doc.setValue('user $i.toString()' key:'name');
   doc.setBoolean(false, key:'admin');

   await database.saveDocument(doc);
 }
});
```

At the local level this operation is still transactional: no other Database instances, including ones managed by the replicator can make changes during the execution of the block, and other instances will not see partial changes. Couchbase Mobile is a distributed system, and due to the way replication works, there’s no guarantee that Capella App Services or Sync Gateway will receive your changes all at once.

## Document change events

It is possible to register for document changes. The following example registers for changes to the document with ID user.john and prints the verified_account property when a change is detected.

###### Example 9. Document change events

```dart showLineNumbers
var token = database
  .addDocumentChangeListener('user.john',
   (change) async {
    var doc = await database.document(change.documentId);
    if (doc != null){
     debugPrint('Status: ${doc.string('verified_account')}');
    }
});
```

### Change Streams
Streams are a convenient alternative to listen for changes. Similarly to change listeners, change streams returned from synchronous APIs are receiving changes as soon as the stream is subscribed to.

Streams returned from asynchronous APIs start to listen asynchronously. Unfortunately it's not possible to return a Future from Stream.listen to signal to subscribers the point in time after which the the stream will observe events. Instead, asynchronous APIs return [AsyncListenStreams](https://pub.dev/documentation/cbl/latest/cbl/AsyncListenStream-class.html), which expose a Future in AsyncListenStream.listening that completes when the stream is fully listening:

<Tabs>
<TabItem value="database" label="Database Changes" default>

```dart showLineNumbers
final stream = database.changes();

stream.listen((change) {
  print('Ids of changed documents: ${change.documentIds}'):
});

// Await the Future exposed by the stream.
await stream.listening;

// The stream is guaranteed to be notified of this change.
await db.saveDocument(MutableDocument.withId('Hey'));
```
</TabItem>
<TabItem value="documentChanges" label="Document Changes">

```dart showLineNumbers
final stream = database.documentChanges('user.john');

stream.listen((change) async {
 var changedDoc = await database.document(change.documentId);
  if (changedDoc != null) {
   debugPrint('Status: ${changedDoc.string('verified_account')}');
  }
});

await stream.listening;
```

</TabItem>
</Tabs>

If you only ever open the same database file once at any given time, you don't need to await the listening future. In this case the stream will always observe all subsequent events.

To stop listening to changes just cancel the subscription, like with any other stream.

## Document Expiration

Document expiration allows users to set the expiration date for a document. When the document expires, it is purged from the database. The purge is not replicated to Capella App Services or Sync Gateway.

###### Example 10. Set document expiration

```dart showLineNumbers
database.setDocumentExpiration(
	'doc123', 
	DateTime.now().add(
		const Duration(days: 1)));

//Reset expiration
database.setDocumentExpiration('doc123', null);

//Query documents that will be expired in less than five minutes
var fiveMinutesFromNow = DateTime.now().add(
	const Duration(minutes: 5));
var query = QueryBuilder.createAsync();

query
  .select(SelectResult.expression(Meta.id))
  .from(DataSource.database(database))
  .where(Meta.expiration.lessThan(
	Expression.date(fiveMinutesFromNow)));
```

## Document Constraints

Couchbase Lite APIs do not explicitly disallow the use of attributes with the underscore prefix at the top level of document. This is to facilitate the creation of documents for use either in local only mode where documents are not synced.

:::caution
"_id", :"_rev" and "_sequence" are reserved keywords and must not be used as top-level attributes — see Example 11.
:::

For more guidance — see: [Sync Gateway - data modeling guidelines](https://docs.couchbase.com/sync-gateway/current/data-modeling.html)

###### Example 11. Reserved Keys List 

- _attachments
- _deleted 
- _id
- _removed
- _rev
- _sequence

## Working with JSON Data

The toJson() typed-accessor means you can easily work with JSON data, native, and Couchbase Lite objects.

### Arrays
Convert an ArrayObject to and from JSON using the toJSON() and toArray methods — see: Example 12.

Additionally you can:

- Initialize a 'MutableArrayObject' using data supplied as a JSON string. This is done using the init(json) constructor-- see: Example 4

- Convert an ArrayFragment object to a JSON String

###### Example 12. Arrays as JSON strings

```dart showLineNumbers
var doc = await database.document('1000');
if (doc != null) {
 var array = doc.array('list');
 if (array != null) {
  var json = array.toJson();
  debugPrint(json);
 }
}
```

### Blobs 
Convert a Blob to JSON using the toJSON method — see Example 13.

You can also check whether a given dictionary object is a blob, or not, using isBlob() — again, see Example 13.

:::note
The blob object must first be saved to the database (generating required metadata) before you can use the toJSON method.
:::

###### Example 13. Blobs as JSON strings

```dart showLineNumbers
var doc = await database.document('1000');
if (doc != null) {
 var blob = doc.blob('avatar'); 
 if (blob != null) {
  var json = blob.toJson();
  debugPrint(json);
 }
}
```

### Dictionaries 

Convert a DictionaryObject to and from JSON using the toJSON and toDictionary methods — see Example 14.

###### Example 14. Dictionaries as JSON strings
```dart showLineNumbers
var doc = await database.document('1000');
if (doc != null) {
 var dictionary = doc.dictionary('dictionary');
 if (dictionary != null) {
  var json = dictionary.toJson();
  debugPrint(json);
 }
}
```

### Documents

Convert a Document to and from JSON strings using the toJSON() method — see Example 15.

###### Example 15. Documents as JSON strings
```dart showLineNumbers
final result = await query.execute();
final results = await result.allResults();
for (var r in results){
	final json = r.toJson();
	var hotel = jsonDecode(json);
}
```

#### JSON String format

If your query selects ALL then the JSON format will be:

```json
{
  database-name: {
    key1: "value1",
    keyx: "valuex"
  }
}
```

If your query selects a sub-set of available properties then the JSON format will be:

```json
{
  key1: "value1",
  keyx: "valuex"
}
```


