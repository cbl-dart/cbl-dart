"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[486],{7013:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>i});const t=JSON.parse('{"id":"general-concepts","title":"General Concepts","description":"General Concepts in the API and How to Work With Them","source":"@site/docs/general-concepts.mdx","sourceDirName":".","slug":"/general-concepts","permalink":"/general-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/cbl-dart/cbl-dart/tree/main/docs/docs/general-concepts.mdx","tags":[],"version":"current","frontMatter":{"description":"General Concepts in the API and How to Work With Them"},"sidebar":"sidebar","previous":{"title":"Install","permalink":"/install"},"next":{"title":"Databases","permalink":"/databases"}}');var a=s(4848),r=s(8453);const o={description:"General Concepts in the API and How to Work With Them"},c="General Concepts",l={},i=[{value:"Synchronous and Asynchronous APIs",id:"sync-and-async-apis",level:2},{value:"Change Listeners",id:"change-listeners",level:2},{value:"Change Streams",id:"change-streams",level:2},{value:"Closing Resources",id:"closing-resources",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components},{MetaHeader:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("MetaHeader",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.header,{children:[(0,a.jsx)(n.h1,{id:"general-concepts",children:"General Concepts"}),(0,a.jsx)(s,{})]}),"\n",(0,a.jsx)(n.h2,{id:"sync-and-async-apis",children:"Synchronous and Asynchronous APIs"}),"\n",(0,a.jsxs)(n.p,{children:["The whole Couchbase Lite API comes in both a synchronous and asynchronous\nversion. The synchronous version is more efficient and slightly more convenient\nto use, but has the downside that it blocks the current\n",(0,a.jsx)(n.a,{href:"https://api.dart.dev/dart-isolate/Isolate-class.html",children:(0,a.jsx)(n.code,{children:"Isolate"})}),"."]}),"\n",(0,a.jsx)(n.p,{children:"In UI applications, such as Flutter apps, this is problematic. Blocking the UI\nisolate for too long causes janky animations, or worse, makes the app\nunresponsive. With only a synchronous API available, the solution would be to\noffload the work to a worker isolate. That is what the asynchronous API does in\na transparent way."}),"\n",(0,a.jsx)(n.p,{children:"Unless you are noticing the performance impact of the overhead of the\nasynchronous API, use the asynchronous API."}),"\n",(0,a.jsxs)(n.p,{children:["To support writing code that works with both synchronous and asynchronous APIs,\nsynchronous and asynchronous APIs always extend from a common base class that\nuses ",(0,a.jsx)(n.a,{href:"https://api.dart.dev/dart-async/FutureOr-class.html",children:(0,a.jsx)(n.code,{children:"FutureOr"})})," wherever a result could be synchronous or\nasynchronous."]}),"\n",(0,a.jsxs)(n.p,{children:["Take for example this simplified version of the ",(0,a.jsx)(n.a,{href:"https://pub.dev/documentation/cbl/latest/cbl/Query-class.html",children:(0,a.jsx)(n.code,{children:"Query"})})," API:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"abstract class Query {\n  // The common base class leaves open whether the results are returned\n  // synchronously or asynchronously.\n  FutureOr<ResultSet> execute();\n}\n\nabstract class SyncQuery extends Query {\n  // The synchronous version of `Query` returns results directly.\n  ResultSet execute();\n}\n\nabstract class AsyncQuery extends Query {\n  // The asynchronous version of `Query` returns results in a `Future`.\n  Future<ResultSet> execute();\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://api.dart.dev/dart-async/FutureOr-class.html",children:(0,a.jsx)(n.code,{children:"FutureOr"})})," can be awaited just like a ",(0,a.jsx)(n.a,{href:"https://api.dart.dev/dart-async/Future-class.html",children:(0,a.jsx)(n.code,{children:"Future"})}),", so\nby programming against ",(0,a.jsx)(n.a,{href:"https://pub.dev/documentation/cbl/latest/cbl/Query-class.html",children:(0,a.jsx)(n.code,{children:"Query"})})," your code works with both the synchronous and\nasynchronous API:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"/// Runs a query that returns a result set with one row and one column and\n/// returns its value.\nFuture<int> runCountQuery(Query query) {\n  final resultSet = await query.execute();\n  final results = await resultSet.allResults();\n  // Returns the first column of the first row.\n  return result[0].integer(0);\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"change-listeners",children:"Change Listeners"}),"\n",(0,a.jsx)(n.p,{children:"Certain objects allow you to register change listeners. In the case of\nsynchronous APIs, all changes are delivered to the listeners as soon as they are\nregistered."}),"\n",(0,a.jsxs)(n.p,{children:["With asynchronous APIs, changes are only guaranteed to be delivered once the\n",(0,a.jsx)(n.a,{href:"https://api.dart.dev/dart-async/Future-class.html",children:(0,a.jsx)(n.code,{children:"Future"})})," returned from the registration call is completed:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// Await the future returned from the registration call.\nawait database.addChangeListener((change) {\n  print('Ids of changed documents: ${change.documentIds}'):\n});\n\n// The listener is guaranteed to be notified of this change.\nawait database.saveDocument(MutableDocument.withId('Hey'));\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To stop receiving notifications, call ",(0,a.jsx)(n.code,{children:"removeChangeListener"})," with the token that\nwas returned from the registration call. Regardless of the whether the API is\nsynchronous or asynchronous, listeners will stop receiving notifications\nimmediately:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"final token = await database.addChangeListener((change) { });\n\n// Some time goes by...\n\nawait database.removeChangeListener(token);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"change-streams",children:"Change Streams"}),"\n",(0,a.jsx)(n.p,{children:"Streams are a convenient alternative to listen for changes. Similarly to change\nlisteners, change streams returned from synchronous APIs are receiving changes\nas soon as the stream is subscribed to."}),"\n",(0,a.jsxs)(n.p,{children:["Streams returned from asynchronous APIs start to listen asynchronously.\nUnfortunately it's not possible to return a ",(0,a.jsx)(n.a,{href:"https://api.dart.dev/dart-async/Future-class.html",children:(0,a.jsx)(n.code,{children:"Future"})})," from\n",(0,a.jsx)(n.a,{href:"https://api.dart.dev/dart-async/Stream/listen.html",children:(0,a.jsx)(n.code,{children:"Stream.listen"})})," to signal to subscribers the point in time after\nwhich the the stream will observe events. Instead, asynchronous APIs return\n",(0,a.jsx)(n.a,{href:"https://pub.dev/documentation/cbl/latest/cbl/AsyncListenStream-class.html",children:(0,a.jsx)(n.code,{children:"AsyncListenStream"})}),"s, which expose a ",(0,a.jsx)(n.a,{href:"https://api.dart.dev/dart-async/Future-class.html",children:(0,a.jsx)(n.code,{children:"Future"})})," in\n",(0,a.jsx)(n.a,{href:"https://pub.dev/documentation/cbl/latest/cbl/AsyncListenStream/listening.html",children:(0,a.jsx)(n.code,{children:"AsyncListenStream.listening"})})," that completes when the stream is fully\nlistening:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"final stream = database.changes();\n\nstream.listen((change) {\n  print('Ids of changed documents: ${change.documentIds}'):\n});\n\n// Await the Future exposed by the stream.\nawait stream.listening;\n\n// The stream is guaranteed to be notified of this change.\nawait database.saveDocument(MutableDocument.withId('Hey'));\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If you only ever open the same database file once at any given time, you don't\nneed to await the ",(0,a.jsx)(n.code,{children:"listening"})," future. In this case the stream will always\nobserve all subsequent events."]}),"\n",(0,a.jsx)(n.p,{children:"To stop listening to changes just cancel the subscription, like with any other\nstream."}),"\n",(0,a.jsx)(n.h2,{id:"closing-resources",children:"Closing Resources"}),"\n",(0,a.jsxs)(n.p,{children:["Some types implement ",(0,a.jsx)(n.a,{href:"https://pub.dev/documentation/cbl/latest/cbl/ClosableResource-class.html",children:(0,a.jsx)(n.code,{children:"ClosableResource"})}),". At the moment these are\n",(0,a.jsx)(n.a,{href:"https://pub.dev/documentation/cbl/latest/cbl/Database-class.html",children:(0,a.jsx)(n.code,{children:"Database"})})," and ",(0,a.jsx)(n.a,{href:"https://pub.dev/documentation/cbl/latest/cbl/Replicator-class.html",children:(0,a.jsx)(n.code,{children:"Replicator"})}),". Once you are done with an instance of these\ntypes, call its ",(0,a.jsx)(n.a,{href:"https://pub.dev/documentation/cbl/latest/cbl/ClosableResource/close.html",children:(0,a.jsx)(n.code,{children:"ClosableResource.close"})})," method. This will free resources\nused by the object, as well as remove listeners, close streams and close child\nresources. For example closing a database will also close any associated\nreplicators."]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var t=s(6540);const a={},r=t.createContext(a);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);