// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:cbl/src/bindings/cblite.dart' as imp1;

/// Initializes the native libraries.
///
/// This function can be called multiple times and is thread save. The
/// libraries are only initialized by the first call and subsequent calls are
/// NOOPs.
@ffi.Native<NativeCBLDart_Initialize>()
external int CBLDart_Initialize(
  ffi.Pointer<ffi.Void> dartInitializeDlData,
  ffi.Pointer<ffi.Void> cblInitContext,
  ffi.Pointer<CBLError> errorOut,
);

@ffi.Native<NativeCBLDart_AsyncCallback_New>()
external CBLDart_AsyncCallback CBLDart_AsyncCallback_New(
  int id,
  int sendPort,
  bool debug,
);

@ffi.Native<NativeCBLDart_AsyncCallback_Delete>()
external void CBLDart_AsyncCallback_Delete(
  CBLDart_AsyncCallback callback,
);

@ffi.Native<NativeCBLDart_AsyncCallback_Close>()
external void CBLDart_AsyncCallback_Close(
  CBLDart_AsyncCallback callback,
);

@ffi.Native<NativeCBLDart_AsyncCallback_CallForTest>()
external void CBLDart_AsyncCallback_CallForTest(
  CBLDart_AsyncCallback callback,
  int argument,
);

@ffi.Native<NativeCBLDart_CBLLog_SetCallback>()
external bool CBLDart_CBLLog_SetCallback(
  CBLDart_AsyncCallback callback,
);

@ffi.Native<NativeCBLDart_CBLLog_SetCallbackLevel>()
external void CBLDart_CBLLog_SetCallbackLevel(
  imp1.DartCBLLogLevel level,
);

@ffi.Native<NativeCBLDart_CBLLog_SetFileConfig>()
external bool CBLDart_CBLLog_SetFileConfig(
  ffi.Pointer<CBLLogFileConfiguration> config,
  ffi.Pointer<CBLError> errorOut,
);

@ffi.Native<NativeCBLDart_CBLLog_GetFileConfig>()
external ffi.Pointer<CBLLogFileConfiguration> CBLDart_CBLLog_GetFileConfig();

@ffi.Native<NativeCBLDart_CBLLog_SetSentryBreadcrumbs>()
external bool CBLDart_CBLLog_SetSentryBreadcrumbs(
  bool enabled,
);

@ffi.Native<NativeCBLDart_CBLEncryptionKey_FromPassword>()
external bool CBLDart_CBLEncryptionKey_FromPassword(
  ffi.Pointer<CBLDartEncryptionKey> key,
  imp1.FLString password,
);

@ffi.Native<NativeCBLDart_CBLDatabaseConfiguration_Default>()
external CBLDartDatabaseConfiguration
    CBLDart_CBLDatabaseConfiguration_Default();

@ffi.Native<NativeCBLDart_CBL_CopyDatabase>()
external bool CBLDart_CBL_CopyDatabase(
  imp1.FLString fromPath,
  imp1.FLString toName,
  ffi.Pointer<CBLDartDatabaseConfiguration> config,
  ffi.Pointer<CBLError> outError,
);

@ffi.Native<NativeCBLDart_CBLDatabase_Open>()
external ffi.Pointer<CBLDatabase> CBLDart_CBLDatabase_Open(
  imp1.FLString name,
  ffi.Pointer<CBLDartDatabaseConfiguration> config,
  ffi.Pointer<CBLError> errorOut,
);

@ffi.Native<NativeCBLDart_CBLDatabase_Release>()
external void CBLDart_CBLDatabase_Release(
  ffi.Pointer<CBLDatabase> database,
);

@ffi.Native<NativeCBLDart_CBLDatabase_Close>()
external bool CBLDart_CBLDatabase_Close(
  ffi.Pointer<CBLDatabase> database,
  bool andDelete,
  ffi.Pointer<CBLError> errorOut,
);

@ffi.Native<NativeCBLDart_CBLDatabase_ChangeEncryptionKey>()
external bool CBLDart_CBLDatabase_ChangeEncryptionKey(
  ffi.Pointer<CBLDatabase> database,
  ffi.Pointer<CBLDartEncryptionKey> newKey,
  ffi.Pointer<CBLError> outError,
);

@ffi.Native<NativeCBLDart_CBLCollection_AddDocumentChangeListener>()
external void CBLDart_CBLCollection_AddDocumentChangeListener(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLCollection> collection,
  imp1.FLString docID,
  CBLDart_AsyncCallback listener,
);

@ffi.Native<NativeCBLDart_CBLCollection_AddChangeListener>()
external void CBLDart_CBLCollection_AddChangeListener(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLCollection> collection,
  CBLDart_AsyncCallback listener,
);

@ffi.Native<NativeCBLDart_CBLCollection_CreateIndex>()
external bool CBLDart_CBLCollection_CreateIndex(
  ffi.Pointer<CBLCollection> collection,
  imp1.FLString name,
  CBLDart_CBLIndexSpec indexSpec,
  ffi.Pointer<CBLError> errorOut,
);

@ffi.Native<NativeCBLDart_CBLQuery_AddChangeListener>()
external ffi.Pointer<CBLListenerToken> CBLDart_CBLQuery_AddChangeListener(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLQuery> query,
  CBLDart_AsyncCallback listener,
);

@ffi.Native<NativeCBLDart_CBLBlobReader_Read>()
external FLSliceResult CBLDart_CBLBlobReader_Read(
  ffi.Pointer<CBLBlobReadStream> stream,
  int bufferSize,
  ffi.Pointer<CBLError> outError,
);

@ffi.Native<NativeCBLDart_CBLReplicator_Create>()
external ffi.Pointer<CBLReplicator> CBLDart_CBLReplicator_Create(
  ffi.Pointer<CBLDart_ReplicatorConfiguration> config,
  ffi.Pointer<CBLError> errorOut,
);

@ffi.Native<NativeCBLDart_CBLReplicator_Release>()
external void CBLDart_CBLReplicator_Release(
  ffi.Pointer<CBLReplicator> replicator,
);

@ffi.Native<NativeCBLDart_CBLReplicator_AddChangeListener>()
external void CBLDart_CBLReplicator_AddChangeListener(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLReplicator> replicator,
  CBLDart_AsyncCallback listenerId,
);

@ffi.Native<NativeCBLDart_CBLReplicator_AddDocumentReplicationListener>()
external void CBLDart_CBLReplicator_AddDocumentReplicationListener(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLReplicator> replicator,
  CBLDart_AsyncCallback listenerId,
);

@ffi.Native<NativeCBLDart_FLSliceResult_RetainByBuf>()
external void CBLDart_FLSliceResult_RetainByBuf(
  ffi.Pointer<ffi.Void> buf,
);

@ffi.Native<NativeCBLDart_FLSliceResult_ReleaseByBuf>()
external void CBLDart_FLSliceResult_ReleaseByBuf(
  ffi.Pointer<ffi.Void> buf,
);

@ffi.Native<NativeCBLDart_KnownSharedKeys_New>()
external ffi.Pointer<KnownSharedKeys> CBLDart_KnownSharedKeys_New();

@ffi.Native<NativeCBLDart_KnownSharedKeys_Delete>()
external void CBLDart_KnownSharedKeys_Delete(
  ffi.Pointer<KnownSharedKeys> keys,
);

@ffi.Native<NativeCBLDart_GetLoadedFLValue>()
external void CBLDart_GetLoadedFLValue(
  imp1.FLValue value,
  ffi.Pointer<CBLDart_LoadedFLValue> out,
);

@ffi.Native<NativeCBLDart_FLArray_GetLoadedFLValue>()
external void CBLDart_FLArray_GetLoadedFLValue(
  imp1.FLArray array,
  int index,
  ffi.Pointer<CBLDart_LoadedFLValue> out,
);

@ffi.Native<NativeCBLDart_FLDict_GetLoadedFLValue>()
external void CBLDart_FLDict_GetLoadedFLValue(
  imp1.FLDict dict,
  imp1.FLString key,
  ffi.Pointer<CBLDart_LoadedFLValue> out,
);

@ffi.Native<NativeCBLDart_FLDictIterator_Begin>()
external ffi.Pointer<CBLDart_FLDictIterator> CBLDart_FLDictIterator_Begin(
  imp1.FLDict dict,
  ffi.Pointer<KnownSharedKeys> knownSharedKeys,
  ffi.Pointer<CBLDart_LoadedDictKey> keyOut,
  ffi.Pointer<CBLDart_LoadedFLValue> valueOut,
  bool deleteOnDone,
  bool preLoad,
);

@ffi.Native<NativeCBLDart_FLDictIterator_Delete>()
external void CBLDart_FLDictIterator_Delete(
  ffi.Pointer<CBLDart_FLDictIterator> iterator,
);

@ffi.Native<NativeCBLDart_FLDictIterator_Next>()
external bool CBLDart_FLDictIterator_Next(
  ffi.Pointer<CBLDart_FLDictIterator> iterator,
);

@ffi.Native<NativeCBLDart_FLArrayIterator_Begin>()
external ffi.Pointer<CBLDart_FLArrayIterator> CBLDart_FLArrayIterator_Begin(
  imp1.FLArray array,
  ffi.Pointer<CBLDart_LoadedFLValue> valueOut,
  bool deleteOnDone,
);

@ffi.Native<NativeCBLDart_FLArrayIterator_Delete>()
external void CBLDart_FLArrayIterator_Delete(
  ffi.Pointer<CBLDart_FLArrayIterator> iterator,
);

@ffi.Native<NativeCBLDart_FLArrayIterator_Next>()
external bool CBLDart_FLArrayIterator_Next(
  ffi.Pointer<CBLDart_FLArrayIterator> iterator,
);

@ffi.Native<NativeCBLDart_FLEncoder_WriteArrayValue>()
external bool CBLDart_FLEncoder_WriteArrayValue(
  imp1.FLEncoder encoder,
  imp1.FLArray array,
  int index,
);

/// This is a compatibility layer to allow Dart code to use the Couchbase Lite C
/// API. Some method signatures are incompatible with Dart's FFI capabilities.
///
/// This layer is also where memory management of objects from the Couchbase Lite
/// C API is integrated with the garbage collection of Dart objects.
abstract class CBLDartInitializeResult {
  static const int CBLDartInitializeResult_kSuccess = 0;
  static const int CBLDartInitializeResult_kIncompatibleDartVM = 1;
  static const int CBLDartInitializeResult_kCBLInitError = 2;
}

/// A struct holding information about an error. It's declared on the stack by a caller, and
/// its address is passed to an API function. If the function's return value indicates that
/// there was an error (usually by returning NULL or false), then the CBLError will have been
/// filled in with the details.
typedef CBLError = imp1.CBLError;
typedef NativeCBLDart_Initialize = ffi.Int32 Function(
    ffi.Pointer<ffi.Void> dartInitializeDlData,
    ffi.Pointer<ffi.Void> cblInitContext,
    ffi.Pointer<CBLError> errorOut);
typedef DartCBLDart_Initialize = int Function(
    ffi.Pointer<ffi.Void> dartInitializeDlData,
    ffi.Pointer<ffi.Void> cblInitContext,
    ffi.Pointer<CBLError> errorOut);

final class _CBLDart_AsyncCallback extends ffi.Opaque {}

typedef CBLDart_AsyncCallback = ffi.Pointer<_CBLDart_AsyncCallback>;

/// A port is used to send or receive inter-isolate messages
typedef Dart_Port = ffi.Int64;
typedef DartDart_Port = int;
typedef NativeCBLDart_AsyncCallback_New = CBLDart_AsyncCallback Function(
    ffi.Uint32 id, Dart_Port sendPort, ffi.Bool debug);
typedef DartCBLDart_AsyncCallback_New = CBLDart_AsyncCallback Function(
    int id, int sendPort, bool debug);
typedef NativeCBLDart_AsyncCallback_Delete = ffi.Void Function(
    CBLDart_AsyncCallback callback);
typedef DartCBLDart_AsyncCallback_Delete = void Function(
    CBLDart_AsyncCallback callback);
typedef NativeCBLDart_AsyncCallback_Close = ffi.Void Function(
    CBLDart_AsyncCallback callback);
typedef DartCBLDart_AsyncCallback_Close = void Function(
    CBLDart_AsyncCallback callback);
typedef NativeCBLDart_AsyncCallback_CallForTest = ffi.Void Function(
    CBLDart_AsyncCallback callback, ffi.Int64 argument);
typedef DartCBLDart_AsyncCallback_CallForTest = void Function(
    CBLDart_AsyncCallback callback, int argument);
typedef NativeCBLDart_CBLLog_SetCallback = ffi.Bool Function(
    CBLDart_AsyncCallback callback);
typedef DartCBLDart_CBLLog_SetCallback = bool Function(
    CBLDart_AsyncCallback callback);
typedef NativeCBLDart_CBLLog_SetCallbackLevel = ffi.Void Function(
    imp1.CBLLogLevel level);
typedef DartCBLDart_CBLLog_SetCallbackLevel = void Function(
    imp1.CBLLogLevel level);

/// The properties for configuring logging to files.
/// @warning `usePlaintext` results in significantly larger log files and higher CPU usage that may slow
/// down your app; we recommend turning it off in production.
typedef CBLLogFileConfiguration = imp1.CBLLogFileConfiguration;
typedef NativeCBLDart_CBLLog_SetFileConfig = ffi.Bool Function(
    ffi.Pointer<CBLLogFileConfiguration> config,
    ffi.Pointer<CBLError> errorOut);
typedef DartCBLDart_CBLLog_SetFileConfig = bool Function(
    ffi.Pointer<CBLLogFileConfiguration> config,
    ffi.Pointer<CBLError> errorOut);
typedef NativeCBLDart_CBLLog_GetFileConfig
    = ffi.Pointer<CBLLogFileConfiguration> Function();
typedef DartCBLDart_CBLLog_GetFileConfig = ffi.Pointer<CBLLogFileConfiguration>
    Function();
typedef NativeCBLDart_CBLLog_SetSentryBreadcrumbs = ffi.Bool Function(
    ffi.Bool enabled);
typedef DartCBLDart_CBLLog_SetSentryBreadcrumbs = bool Function(bool enabled);

final class CBLDartEncryptionKey extends ffi.Struct {
  @CBLDartEncryptionAlgorithm()
  external int algorithm;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Uint8> bytes;
}

typedef CBLDartEncryptionAlgorithm = ffi.Uint32;
typedef DartCBLDartEncryptionAlgorithm = int;

final class CBLDartDatabaseConfiguration extends ffi.Struct {
  external imp1.FLString directory;

  external CBLDartEncryptionKey encryptionKey;
}

typedef NativeCBLDart_CBLEncryptionKey_FromPassword = ffi.Bool Function(
    ffi.Pointer<CBLDartEncryptionKey> key, imp1.FLString password);
typedef DartCBLDart_CBLEncryptionKey_FromPassword = bool Function(
    ffi.Pointer<CBLDartEncryptionKey> key, imp1.FLString password);
typedef NativeCBLDart_CBLDatabaseConfiguration_Default
    = CBLDartDatabaseConfiguration Function();
typedef DartCBLDart_CBLDatabaseConfiguration_Default
    = CBLDartDatabaseConfiguration Function();
typedef NativeCBLDart_CBL_CopyDatabase = ffi.Bool Function(
    imp1.FLString fromPath,
    imp1.FLString toName,
    ffi.Pointer<CBLDartDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDart_CBL_CopyDatabase = bool Function(
    imp1.FLString fromPath,
    imp1.FLString toName,
    ffi.Pointer<CBLDartDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError);

/// \defgroup database  Database
/// @{ */
/// /** A connection to an open database.
typedef CBLDatabase = imp1.CBLDatabase;
typedef NativeCBLDart_CBLDatabase_Open = ffi.Pointer<CBLDatabase> Function(
    imp1.FLString name,
    ffi.Pointer<CBLDartDatabaseConfiguration> config,
    ffi.Pointer<CBLError> errorOut);
typedef DartCBLDart_CBLDatabase_Open = ffi.Pointer<CBLDatabase> Function(
    imp1.FLString name,
    ffi.Pointer<CBLDartDatabaseConfiguration> config,
    ffi.Pointer<CBLError> errorOut);
typedef NativeCBLDart_CBLDatabase_Release = ffi.Void Function(
    ffi.Pointer<CBLDatabase> database);
typedef DartCBLDart_CBLDatabase_Release = void Function(
    ffi.Pointer<CBLDatabase> database);
typedef NativeCBLDart_CBLDatabase_Close = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> database,
    ffi.Bool andDelete,
    ffi.Pointer<CBLError> errorOut);
typedef DartCBLDart_CBLDatabase_Close = bool Function(
    ffi.Pointer<CBLDatabase> database,
    bool andDelete,
    ffi.Pointer<CBLError> errorOut);
typedef NativeCBLDart_CBLDatabase_ChangeEncryptionKey = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> database,
    ffi.Pointer<CBLDartEncryptionKey> newKey,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDart_CBLDatabase_ChangeEncryptionKey = bool Function(
    ffi.Pointer<CBLDatabase> database,
    ffi.Pointer<CBLDartEncryptionKey> newKey,
    ffi.Pointer<CBLError> outError);

/// \defgroup collection  Collection
/// @{ */
/// /** A collection, a document container.
typedef CBLCollection = imp1.CBLCollection;
typedef NativeCBLDart_CBLCollection_AddDocumentChangeListener
    = ffi.Void Function(
        ffi.Pointer<CBLDatabase> db,
        ffi.Pointer<CBLCollection> collection,
        imp1.FLString docID,
        CBLDart_AsyncCallback listener);
typedef DartCBLDart_CBLCollection_AddDocumentChangeListener = void Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLCollection> collection,
    imp1.FLString docID,
    CBLDart_AsyncCallback listener);
typedef NativeCBLDart_CBLCollection_AddChangeListener = ffi.Void Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLCollection> collection,
    CBLDart_AsyncCallback listener);
typedef DartCBLDart_CBLCollection_AddChangeListener = void Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLCollection> collection,
    CBLDart_AsyncCallback listener);

abstract class CBLDart_IndexType {
  static const int kCBLDart_IndexTypeValue = 0;
  static const int kCBLDart_IndexTypeFullText = 1;
}

final class CBLDart_CBLIndexSpec extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @imp1.CBLQueryLanguage()
  external imp1.DartCBLQueryLanguage expressionLanguage;

  external imp1.FLString expressions;

  @ffi.Bool()
  external bool ignoreAccents;

  external imp1.FLString language;
}

typedef NativeCBLDart_CBLCollection_CreateIndex = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    imp1.FLString name,
    CBLDart_CBLIndexSpec indexSpec,
    ffi.Pointer<CBLError> errorOut);
typedef DartCBLDart_CBLCollection_CreateIndex = bool Function(
    ffi.Pointer<CBLCollection> collection,
    imp1.FLString name,
    CBLDart_CBLIndexSpec indexSpec,
    ffi.Pointer<CBLError> errorOut);

/// An opaque 'cookie' representing a registered listener callback.
/// It's returned from functions that register listeners, and used to remove a listener by
/// calling \ref CBLListener_Remove.
typedef CBLListenerToken = imp1.CBLListenerToken;

/// \defgroup queries  Queries
/// @{ */
/// /** A compiled database query.
typedef CBLQuery = imp1.CBLQuery;
typedef NativeCBLDart_CBLQuery_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLDatabase> db,
        ffi.Pointer<CBLQuery> query, CBLDart_AsyncCallback listener);
typedef DartCBLDart_CBLQuery_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLDatabase> db,
        ffi.Pointer<CBLQuery> query, CBLDart_AsyncCallback listener);

/// A heap-allocated block of memory returned from an API call.
/// The caller takes ownership, and must call \ref FLSliceResult_Release when done with it.
/// \warning The contents of the block must not be modified, since others may be using it.
/// \note This is equivalent to the C++ class `alloc_slice`. In C++ the easiest way to deal with
/// a `FLSliceResult` return value is to construct an `alloc_slice` from it, which will
/// adopt the reference, and release it in its destructor. For example:
/// `alloc_slice foo( CopyFoo() );`
typedef FLSliceResult = imp1.FLSliceResult;

/// A stream for reading a blob's content.
typedef CBLBlobReadStream = imp1.CBLBlobReadStream;
typedef NativeCBLDart_CBLBlobReader_Read = FLSliceResult Function(
    ffi.Pointer<CBLBlobReadStream> stream,
    ffi.Uint64 bufferSize,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDart_CBLBlobReader_Read = FLSliceResult Function(
    ffi.Pointer<CBLBlobReadStream> stream,
    int bufferSize,
    ffi.Pointer<CBLError> outError);

final class CBLDart_ReplicationCollection extends ffi.Struct {
  external ffi.Pointer<CBLCollection> collection;

  external imp1.FLArray channels;

  external imp1.FLArray documentIDs;

  external CBLDart_AsyncCallback pushFilter;

  external CBLDart_AsyncCallback pullFilter;

  external CBLDart_AsyncCallback conflictResolver;
}

final class CBLDart_ReplicatorConfiguration extends ffi.Struct {
  external ffi.Pointer<CBLDatabase> database;

  external ffi.Pointer<CBLEndpoint> endpoint;

  @imp1.CBLReplicatorType()
  external imp1.DartCBLReplicatorType replicatorType;

  @ffi.Bool()
  external bool continuous;

  @ffi.Bool()
  external bool disableAutoPurge;

  @ffi.UnsignedInt()
  external int maxAttempts;

  @ffi.UnsignedInt()
  external int maxAttemptWaitTime;

  @ffi.UnsignedInt()
  external int heartbeat;

  external ffi.Pointer<CBLAuthenticator> authenticator;

  external ffi.Pointer<CBLProxySettings> proxy;

  external imp1.FLDict headers;

  external ffi.Pointer<FLSlice> pinnedServerCertificate;

  external ffi.Pointer<FLSlice> trustedRootCertificates;

  external ffi.Pointer<CBLDart_ReplicationCollection> collections;

  @ffi.Size()
  external int collectionsCount;
}

/// An opaque object representing the location of a database to replicate with.
typedef CBLEndpoint = imp1.CBLEndpoint;

/// An opaque object representing authentication credentials for a remote server.
typedef CBLAuthenticator = imp1.CBLAuthenticator;

/// Proxy settings for the replicator.
typedef CBLProxySettings = imp1.CBLProxySettings;

/// A simple reference to a block of memory. Does not imply ownership.
/// (This is equivalent to the C++ class `slice`.)
typedef FLSlice = imp1.FLSlice;

/// \defgroup replication  Replication
/// @{ */
/// /** A background task that syncs a \ref CBLDatabase with a remote server or peer.
typedef CBLReplicator = imp1.CBLReplicator;
typedef NativeCBLDart_CBLReplicator_Create
    = ffi.Pointer<CBLReplicator> Function(
        ffi.Pointer<CBLDart_ReplicatorConfiguration> config,
        ffi.Pointer<CBLError> errorOut);
typedef DartCBLDart_CBLReplicator_Create = ffi.Pointer<CBLReplicator> Function(
    ffi.Pointer<CBLDart_ReplicatorConfiguration> config,
    ffi.Pointer<CBLError> errorOut);
typedef NativeCBLDart_CBLReplicator_Release = ffi.Void Function(
    ffi.Pointer<CBLReplicator> replicator);
typedef DartCBLDart_CBLReplicator_Release = void Function(
    ffi.Pointer<CBLReplicator> replicator);
typedef NativeCBLDart_CBLReplicator_AddChangeListener = ffi.Void Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLReplicator> replicator,
    CBLDart_AsyncCallback listenerId);
typedef DartCBLDart_CBLReplicator_AddChangeListener = void Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLReplicator> replicator,
    CBLDart_AsyncCallback listenerId);
typedef NativeCBLDart_CBLReplicator_AddDocumentReplicationListener
    = ffi.Void Function(
        ffi.Pointer<CBLDatabase> db,
        ffi.Pointer<CBLReplicator> replicator,
        CBLDart_AsyncCallback listenerId);
typedef DartCBLDart_CBLReplicator_AddDocumentReplicationListener
    = void Function(
        ffi.Pointer<CBLDatabase> db,
        ffi.Pointer<CBLReplicator> replicator,
        CBLDart_AsyncCallback listenerId);
typedef NativeCBLDart_FLSliceResult_RetainByBuf = ffi.Void Function(
    ffi.Pointer<ffi.Void> buf);
typedef DartCBLDart_FLSliceResult_RetainByBuf = void Function(
    ffi.Pointer<ffi.Void> buf);
typedef NativeCBLDart_FLSliceResult_ReleaseByBuf = ffi.Void Function(
    ffi.Pointer<ffi.Void> buf);
typedef DartCBLDart_FLSliceResult_ReleaseByBuf = void Function(
    ffi.Pointer<ffi.Void> buf);

final class KnownSharedKeys extends ffi.Opaque {}

typedef NativeCBLDart_KnownSharedKeys_New = ffi.Pointer<KnownSharedKeys>
    Function();
typedef DartCBLDart_KnownSharedKeys_New = ffi.Pointer<KnownSharedKeys>
    Function();
typedef NativeCBLDart_KnownSharedKeys_Delete = ffi.Void Function(
    ffi.Pointer<KnownSharedKeys> keys);
typedef DartCBLDart_KnownSharedKeys_Delete = void Function(
    ffi.Pointer<KnownSharedKeys> keys);

final class CBLDart_LoadedDictKey extends ffi.Struct {
  @ffi.Bool()
  external bool isKnownSharedKey;

  @ffi.Int()
  external int sharedKey;

  external ffi.Pointer<ffi.Void> stringBuf;

  @ffi.Size()
  external int stringSize;

  external imp1.FLValue value;
}

final class CBLDart_LoadedFLValue extends ffi.Struct {
  @ffi.Bool()
  external bool exists;

  @ffi.Int8()
  external int type;

  @ffi.Bool()
  external bool isInteger;

  @ffi.Uint32()
  external int collectionSize;

  @ffi.Bool()
  external bool asBool;

  @ffi.Int64()
  external int asInt;

  @ffi.Double()
  external double asDouble;

  external ffi.Pointer<ffi.Void> stringBuf;

  @ffi.Size()
  external int stringSize;

  external FLSlice asData;

  external imp1.FLValue value;
}

typedef NativeCBLDart_GetLoadedFLValue = ffi.Void Function(
    imp1.FLValue value, ffi.Pointer<CBLDart_LoadedFLValue> out);
typedef DartCBLDart_GetLoadedFLValue = void Function(
    imp1.FLValue value, ffi.Pointer<CBLDart_LoadedFLValue> out);
typedef NativeCBLDart_FLArray_GetLoadedFLValue = ffi.Void Function(
    imp1.FLArray array,
    ffi.Uint32 index,
    ffi.Pointer<CBLDart_LoadedFLValue> out);
typedef DartCBLDart_FLArray_GetLoadedFLValue = void Function(
    imp1.FLArray array, int index, ffi.Pointer<CBLDart_LoadedFLValue> out);
typedef NativeCBLDart_FLDict_GetLoadedFLValue = ffi.Void Function(
    imp1.FLDict dict,
    imp1.FLString key,
    ffi.Pointer<CBLDart_LoadedFLValue> out);
typedef DartCBLDart_FLDict_GetLoadedFLValue = void Function(imp1.FLDict dict,
    imp1.FLString key, ffi.Pointer<CBLDart_LoadedFLValue> out);

final class CBLDart_FLDictIterator extends ffi.Opaque {}

typedef NativeCBLDart_FLDictIterator_Begin
    = ffi.Pointer<CBLDart_FLDictIterator> Function(
        imp1.FLDict dict,
        ffi.Pointer<KnownSharedKeys> knownSharedKeys,
        ffi.Pointer<CBLDart_LoadedDictKey> keyOut,
        ffi.Pointer<CBLDart_LoadedFLValue> valueOut,
        ffi.Bool deleteOnDone,
        ffi.Bool preLoad);
typedef DartCBLDart_FLDictIterator_Begin
    = ffi.Pointer<CBLDart_FLDictIterator> Function(
        imp1.FLDict dict,
        ffi.Pointer<KnownSharedKeys> knownSharedKeys,
        ffi.Pointer<CBLDart_LoadedDictKey> keyOut,
        ffi.Pointer<CBLDart_LoadedFLValue> valueOut,
        bool deleteOnDone,
        bool preLoad);
typedef NativeCBLDart_FLDictIterator_Delete = ffi.Void Function(
    ffi.Pointer<CBLDart_FLDictIterator> iterator);
typedef DartCBLDart_FLDictIterator_Delete = void Function(
    ffi.Pointer<CBLDart_FLDictIterator> iterator);
typedef NativeCBLDart_FLDictIterator_Next = ffi.Bool Function(
    ffi.Pointer<CBLDart_FLDictIterator> iterator);
typedef DartCBLDart_FLDictIterator_Next = bool Function(
    ffi.Pointer<CBLDart_FLDictIterator> iterator);

final class CBLDart_FLArrayIterator extends ffi.Opaque {}

typedef NativeCBLDart_FLArrayIterator_Begin
    = ffi.Pointer<CBLDart_FLArrayIterator> Function(imp1.FLArray array,
        ffi.Pointer<CBLDart_LoadedFLValue> valueOut, ffi.Bool deleteOnDone);
typedef DartCBLDart_FLArrayIterator_Begin
    = ffi.Pointer<CBLDart_FLArrayIterator> Function(imp1.FLArray array,
        ffi.Pointer<CBLDart_LoadedFLValue> valueOut, bool deleteOnDone);
typedef NativeCBLDart_FLArrayIterator_Delete = ffi.Void Function(
    ffi.Pointer<CBLDart_FLArrayIterator> iterator);
typedef DartCBLDart_FLArrayIterator_Delete = void Function(
    ffi.Pointer<CBLDart_FLArrayIterator> iterator);
typedef NativeCBLDart_FLArrayIterator_Next = ffi.Bool Function(
    ffi.Pointer<CBLDart_FLArrayIterator> iterator);
typedef DartCBLDart_FLArrayIterator_Next = bool Function(
    ffi.Pointer<CBLDart_FLArrayIterator> iterator);
typedef NativeCBLDart_FLEncoder_WriteArrayValue = ffi.Bool Function(
    imp1.FLEncoder encoder, imp1.FLArray array, ffi.Uint32 index);
typedef DartCBLDart_FLEncoder_WriteArrayValue = bool Function(
    imp1.FLEncoder encoder, imp1.FLArray array, int index);

const int kCBLDartEncryptionNone = 0;

const int kCBLDartEncryptionAES256 = 1;

const int kCBLDartEncryptionKeySizeAES256 = 32;
