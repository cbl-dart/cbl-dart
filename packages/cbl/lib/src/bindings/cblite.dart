// ignore_for_file: unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Returns a message describing an error.
/// @note  You are responsible for releasing the result by calling \ref FLSliceResult_Release.
@ffi.Native<NativeCBLError_Message>()
external FLSliceResult CBLError_Message(
  ffi.Pointer<CBLError> outError,
);

/// Returns the current time, in milliseconds since 1/1/1970.
@ffi.Native<NativeCBL_Now>()
external int CBL_Now();

/// Increments an object's reference-count.
/// Usually you'll call one of the type-safe synonyms specific to the object type,
/// like \ref CBLDatabase_Retain`
@ffi.Native<NativeCBL_Retain>()
external ffi.Pointer<CBLRefCounted> CBL_Retain(
  ffi.Pointer<CBLRefCounted> arg0,
);

/// Decrements an object's reference-count, freeing the object if the count hits zero.
/// Usually you'll call one of the type-safe synonyms specific to the object type,
/// like \ref CBLDatabase_Release.
@ffi.Native<NativeCBL_Release>()
external void CBL_Release(
  ffi.Pointer<CBLRefCounted> arg0,
);

/// Returns the total number of Couchbase Lite objects. Useful for leak checking.
@ffi.Native<NativeCBL_InstanceCount>()
external int CBL_InstanceCount();

/// Logs the class and address of each Couchbase Lite object. Useful for leak checking.
/// @note  May only be functional in debug builds of Couchbase Lite.
@ffi.Native<NativeCBL_DumpInstances>()
external void CBL_DumpInstances();

/// Removes a listener callback, given the token that was returned when it was added.
@ffi.Native<NativeCBLListener_Remove>()
external void CBLListener_Remove(
  ffi.Pointer<CBLListenerToken> arg0,
);

/// < `"blob"`
@ffi.Native<FLSlice>()
external final FLSlice kCBLBlobType;

/// < `"digest"`
@ffi.Native<FLSlice>()
external final FLSlice kCBLBlobDigestProperty;

/// < `"length"`
@ffi.Native<FLSlice>()
external final FLSlice kCBLBlobLengthProperty;

/// < `"content_type"`
@ffi.Native<FLSlice>()
external final FLSlice kCBLBlobContentTypeProperty;

/// Returns true if a dictionary in a document is a blob reference.
/// If so, you can call \ref FLDict_GetBlob to access it.
/// @note This function tests whether the dictionary has a `@type` property,
/// whose value is `"blob"`.
@ffi.Native<NativeFLDict_IsBlob>()
external bool FLDict_IsBlob(
  FLDict arg0,
);

/// Returns a CBLBlob object corresponding to a blob dictionary in a document.
/// @param blobDict  A dictionary in a document.
/// @return  A CBLBlob instance for this blob, or NULL if the dictionary is not a blob.
@ffi.Native<NativeFLDict_GetBlob>()
external ffi.Pointer<CBLBlob> FLDict_GetBlob(
  FLDict blobDict,
);

/// Returns the length in bytes of a blob's content (from its `length` property).
@ffi.Native<NativeCBLBlob_Length>()
external int CBLBlob_Length(
  ffi.Pointer<CBLBlob> arg0,
);

/// Returns a blob's MIME type, if its metadata has a `content_type` property.
@ffi.Native<NativeCBLBlob_ContentType>()
external FLString CBLBlob_ContentType(
  ffi.Pointer<CBLBlob> arg0,
);

/// Returns the cryptographic digest of a blob's content (from its `digest` property).
@ffi.Native<NativeCBLBlob_Digest>()
external FLString CBLBlob_Digest(
  ffi.Pointer<CBLBlob> arg0,
);

/// Returns a blob's metadata. This includes the `digest`, `length`, `content_type`,
/// and `@type` properties, as well as any custom ones that may have been added.
@ffi.Native<NativeCBLBlob_Properties>()
external FLDict CBLBlob_Properties(
  ffi.Pointer<CBLBlob> arg0,
);

/// Returns a blob's metadata as JSON.
@ffi.Native<NativeCBLBlob_CreateJSON>()
external FLStringResult CBLBlob_CreateJSON(
  ffi.Pointer<CBLBlob> blob,
);

/// Reads the blob's content into memory and returns them.
/// @note  You are responsible for releasing the result by calling \ref FLSliceResult_Release.
@ffi.Native<NativeCBLBlob_Content>()
external FLSliceResult CBLBlob_Content(
  ffi.Pointer<CBLBlob> blob,
  ffi.Pointer<CBLError> outError,
);

/// Opens a stream for reading a blob's content.
@ffi.Native<NativeCBLBlob_OpenContentStream>()
external ffi.Pointer<CBLBlobReadStream> CBLBlob_OpenContentStream(
  ffi.Pointer<CBLBlob> blob,
  ffi.Pointer<CBLError> arg1,
);

/// Reads data from a blob.
/// @param stream  The stream to read from.
/// @param dst  The address to copy the read data to.
/// @param maxLength  The maximum number of bytes to read.
/// @param outError  On failure, an error will be stored here if non-NULL.
/// @return  The actual number of bytes read; 0 if at EOF, -1 on error.
@ffi.Native<NativeCBLBlobReader_Read>()
external int CBLBlobReader_Read(
  ffi.Pointer<CBLBlobReadStream> stream,
  ffi.Pointer<ffi.Void> dst,
  int maxLength,
  ffi.Pointer<CBLError> outError,
);

/// Sets the position of a CBLBlobReadStream.
/// @param stream  The stream to reposition.
/// @param offset  The byte offset in the stream (relative to the `mode`).
/// @param base    The base position from which the offset is calculated.
/// @param outError  On failure, an error will be stored here if non-NULL.
/// @return  The new absolute position, or -1 on failure.
@ffi.Native<NativeCBLBlobReader_Seek>()
external int CBLBlobReader_Seek(
  ffi.Pointer<CBLBlobReadStream> stream,
  int offset,
  int base,
  ffi.Pointer<CBLError> outError,
);

/// Returns the current position of a CBLBlobReadStream.
@ffi.Native<NativeCBLBlobReader_Position>()
external int CBLBlobReader_Position(
  ffi.Pointer<CBLBlobReadStream> stream,
);

/// Closes a CBLBlobReadStream.
@ffi.Native<NativeCBLBlobReader_Close>()
external void CBLBlobReader_Close(
  ffi.Pointer<CBLBlobReadStream> arg0,
);

/// Compares whether the two given blobs are equal based on their content.
@ffi.Native<NativeCBLBlob_Equals>()
external bool CBLBlob_Equals(
  ffi.Pointer<CBLBlob> blob,
  ffi.Pointer<CBLBlob> anotherBlob,
);

/// Creates a new blob given its contents as a single block of data.
/// @note  You are responsible for releasing the \ref CBLBlob, but not until after its document
/// has been saved.
/// @param contentType  The MIME type (optional).
/// @param contents  The data's address and length.
/// @return  A new CBLBlob instance.
@ffi.Native<NativeCBLBlob_CreateWithData>()
external ffi.Pointer<CBLBlob> CBLBlob_CreateWithData(
  FLString contentType,
  FLSlice contents,
);

/// Opens a stream for writing a new blob.
/// You should next call \ref CBLBlobWriter_Write one or more times to write the data,
/// then \ref CBLBlob_CreateWithStream to create the blob.
///
/// If for some reason you need to abort, just call \ref CBLBlobWriter_Close.
@ffi.Native<NativeCBLBlobWriter_Create>()
external ffi.Pointer<CBLBlobWriteStream> CBLBlobWriter_Create(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLError> arg1,
);

/// Closes a blob-writing stream, if you need to give up without creating a \ref CBLBlob.
@ffi.Native<NativeCBLBlobWriter_Close>()
external void CBLBlobWriter_Close(
  ffi.Pointer<CBLBlobWriteStream> arg0,
);

/// Writes data to a new blob.
/// @param writer  The stream to write to.
/// @param data  The address of the data to write.
/// @param length  The length of the data to write.
/// @param outError  On failure, error info will be written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLBlobWriter_Write>()
external bool CBLBlobWriter_Write(
  ffi.Pointer<CBLBlobWriteStream> writer,
  ffi.Pointer<ffi.Void> data,
  int length,
  ffi.Pointer<CBLError> outError,
);

/// Creates a new blob after its data has been written to a \ref CBLBlobWriteStream.
/// You should then add the blob to a mutable document as a property -- see
/// \ref FLSlot_SetBlob.
/// @note  You are responsible for releasing the CBLBlob reference.
/// @note  Do not free the stream; the blob will do that.
/// @param contentType  The MIME type (optional).
/// @param writer  The blob-writing stream the data was written to.
/// @return  A new CBLBlob instance.
@ffi.Native<NativeCBLBlob_CreateWithStream>()
external ffi.Pointer<CBLBlob> CBLBlob_CreateWithStream(
  FLString contentType,
  ffi.Pointer<CBLBlobWriteStream> writer,
);

@ffi.Native<NativeFLSlot_SetBlob>()
external void FLSlot_SetBlob(
  FLSlot slot,
  ffi.Pointer<CBLBlob> blob,
);

/// Get a \ref CBLBlob object from the database using the \ref CBLBlob properties.
///
/// The \ref CBLBlob properties is a blob's metadata containing two required fields
/// which are a special marker property `"@type":"blob"`, and property `digest` whose value
/// is a hex SHA-1 digest of the blob's data. The other optional properties are `length` and
/// `content_type`. To obtain the \ref CBLBlob properties from a \ref CBLBlob,
/// call \ref CBLBlob_Properties function.
///
/// @note   You must release the \ref CBLBlob when you're finished with it.
/// @param db   The database.
/// @param properties   The properties for getting the \ref CBLBlob object.
/// @param outError On failure, error info will be written here if specified. A nonexistent blob
/// is not considered a failure; in that event the error code will be zero.
/// @return A \ref CBLBlob instance, or NULL if the doc doesn't exist or an error occurred.
@ffi.Native<NativeCBLDatabase_GetBlob>()
external ffi.Pointer<CBLBlob> CBLDatabase_GetBlob(
  ffi.Pointer<CBLDatabase> db,
  FLDict properties,
  ffi.Pointer<CBLError> outError,
);

/// Save a new \ref CBLBlob object into the database without associating it with
/// any documents. The properties of the saved \ref CBLBlob object will include
/// information necessary for referencing the \ref CBLBlob object in the properties
/// of the document to be saved into the database.
///
/// Normally you do not need to use this function unless you are in the situation
/// (e.g. developing javascript binding) that you cannot retain the \ref CBLBlob
/// object until the document containing the \ref CBLBlob object is successfully
/// saved into the database.
/// \note The saved \ref CBLBlob objects that are not associated with any documents
/// will be removed from the database when compacting the database.
/// @param db   The database.
/// @param blob The The CBLBlob to save.
/// @param outError On failure, error info will be written here.
@ffi.Native<NativeCBLDatabase_SaveBlob>()
external bool CBLDatabase_SaveBlob(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLBlob> blob,
  ffi.Pointer<CBLError> outError,
);

/// < `"@type"`
@ffi.Native<FLSlice>()
external final FLSlice kCBLTypeProperty;

/// Reads a document from the default collection in an immutable form.
/// Each call to this function creates a new object (which must later be released.)
/// @note  If you are reading the document in order to make changes to it, call
/// \ref CBLDatabase_GetMutableDocument instead.
/// @warning  <b>Deprecated :</b> Use CBLCollection_GetDocument on the default collection instead.
/// @param database  The database.
/// @param docID  The ID of the document.
/// @param outError  On failure, the error will be written here. (A nonexistent document is not
/// considered a failure; in that event the error code will be zero.)
/// @return  A new \ref CBLDocument instance, or NULL if the doc doesn't exist or an error occurred.
@ffi.Native<NativeCBLDatabase_GetDocument>()
external ffi.Pointer<CBLDocument> CBLDatabase_GetDocument(
  ffi.Pointer<CBLDatabase> database,
  FLString docID,
  ffi.Pointer<CBLError> outError,
);

/// Saves a (mutable) document to the default collection.
/// @warning If a newer revision has been saved since \p doc was loaded, it will be overwritten by
/// this one. This can lead to data loss! To avoid this, call
/// \ref CBLDatabase_SaveDocumentWithConcurrencyControl or
/// \ref CBLDatabase_SaveDocumentWithConflictHandler instead.
/// @warning  <b>Deprecated :</b> Use CBLCollection_SaveDocument on the default collection instead.
/// @param db  The database.
/// @param doc  The mutable document to save.
/// @param outError  On failure, the error will be written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLDatabase_SaveDocument>()
external bool CBLDatabase_SaveDocument(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  ffi.Pointer<CBLError> outError,
);

/// Saves a (mutable) document to the default collection.
/// If a conflicting revision has been saved since \p doc was loaded, the \p concurrency
/// parameter specifies whether the save should fail, or the conflicting revision should
/// be overwritten with the revision being saved.
/// If you need finer-grained control, call \ref CBLDatabase_SaveDocumentWithConflictHandler instead.
/// @warning  <b>Deprecated :</b> Use CBLCollection_SaveDocumentWithConcurrencyControl on the default collection instead.
/// @param db  The database.
/// @param doc  The mutable document to save.
/// @param concurrency  Conflict-handling strategy (fail or overwrite).
/// @param outError  On failure, the error will be written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLDatabase_SaveDocumentWithConcurrencyControl>()
external bool CBLDatabase_SaveDocumentWithConcurrencyControl(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  int concurrency,
  ffi.Pointer<CBLError> outError,
);

/// Saves a (mutable) document to the default collection, allowing for custom conflict handling in the event
/// that the document has been updated since \p doc was loaded.
/// @warning <b>Deprecated :</b> Use CBLCollection_SaveDocumentWithConflictHandler on the default collection instead.
/// @param db  The database.
/// @param doc  The mutable document to save.
/// @param conflictHandler  The callback to be invoked if there is a conflict.
/// @param context  An arbitrary value to be passed to the \p conflictHandler.
/// @param outError  On failure, the error will be written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLDatabase_SaveDocumentWithConflictHandler>()
external bool CBLDatabase_SaveDocumentWithConflictHandler(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  CBLConflictHandler conflictHandler,
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLError> outError,
);

/// Deletes a document from the default collection. Deletions are replicated.
/// @warning  You are still responsible for releasing the CBLDocument.
/// @warning  <b>Deprecated :</b> Use CBLCollection_DeleteDocument on the default collection instead.
/// @param db  The database.
/// @param document  The document to delete.
/// @param outError  On failure, the error will be written here.
/// @return  True if the document was deleted, false if an error occurred.
@ffi.Native<NativeCBLDatabase_DeleteDocument>()
external bool CBLDatabase_DeleteDocument(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> document,
  ffi.Pointer<CBLError> outError,
);

/// Deletes a document from the default collection. Deletions are replicated.
/// @warning  You are still responsible for releasing the CBLDocument.
/// @warning  <b>Deprecated :</b> Use CBLCollection_DeleteDocumentWithConcurrencyControl on the default collection instead.
/// @param db  The database.
/// @param document  The document to delete.
/// @param concurrency  Conflict-handling strategy.
/// @param outError  On failure, the error will be written here.
/// @return  True if the document was deleted, false if an error occurred.
@ffi.Native<NativeCBLDatabase_DeleteDocumentWithConcurrencyControl>()
external bool CBLDatabase_DeleteDocumentWithConcurrencyControl(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> document,
  int concurrency,
  ffi.Pointer<CBLError> outError,
);

/// Purges a document from the default collection. This removes all traces of the document.
/// Purges are _not_ replicated. If the document is changed on a server, it will be re-created
/// when pulled.
/// @warning  You are still responsible for releasing the \ref CBLDocument reference.
/// @warning  <b>Deprecated :</b> Use CBLCollection_PurgeDocument on the default collection instead.
/// @note If you don't have the document in memory already, \ref CBLDatabase_PurgeDocumentByID is a
/// simpler shortcut.
/// @param db  The database.
/// @param document  The document to purge.
/// @param outError  On failure, the error will be written here.
/// @return  True if the document was purged, false if it doesn't exist or the purge failed.
@ffi.Native<NativeCBLDatabase_PurgeDocument>()
external bool CBLDatabase_PurgeDocument(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> document,
  ffi.Pointer<CBLError> outError,
);

/// Purges a document by its ID from the default collection.
/// @note  If no document with that ID exists, this function will return false but the error
/// code will be zero.
/// @warning  <b>Deprecated :</b> Use CBLCollection_PurgeDocumentByID on the default collection instead.
/// @param database  The database.
/// @param docID  The document ID to purge.
/// @param outError  On failure, the error will be written here.
/// @return  True if the document was purged, false if it doesn't exist or the purge failed.
@ffi.Native<NativeCBLDatabase_PurgeDocumentByID>()
external bool CBLDatabase_PurgeDocumentByID(
  ffi.Pointer<CBLDatabase> database,
  FLString docID,
  ffi.Pointer<CBLError> outError,
);

/// Reads a document from the default collection in mutable form that can be updated and saved.
/// (This function is otherwise identical to \ref CBLDatabase_GetDocument.)
/// @note  You must release the document when you're done with it.
/// @warning  <b>Deprecated :</b> Use CBLCollection_GetMutableDocument on the default collection instead.
/// @param database  The database.
/// @param docID  The ID of the document.
/// @param outError  On failure, the error will be written here. (A nonexistent document is not
/// considered a failure; in that event the error code will be zero.)
/// @return  A new \ref CBLDocument instance, or NULL if the doc doesn't exist or an error occurred.
@ffi.Native<NativeCBLDatabase_GetMutableDocument>()
external ffi.Pointer<CBLDocument> CBLDatabase_GetMutableDocument(
  ffi.Pointer<CBLDatabase> database,
  FLString docID,
  ffi.Pointer<CBLError> outError,
);

/// Creates a new, empty document in memory, with a randomly-generated unique ID.
/// It will not be added to a database until saved.
/// @return  The new mutable document instance.
@ffi.Native<NativeCBLDocument_Create>()
external ffi.Pointer<CBLDocument> CBLDocument_Create();

/// Creates a new, empty document in memory, with the given ID.
/// It will not be added to a database until saved.
/// @note  If the given ID conflicts with a document already in the database, that will not
/// be apparent until this document is saved. At that time, the result depends on the
/// conflict handling mode used when saving; see the save functions for details.
/// @param docID  The ID of the new document, or NULL to assign a new unique ID.
/// @return  The new mutable document instance.
@ffi.Native<NativeCBLDocument_CreateWithID>()
external ffi.Pointer<CBLDocument> CBLDocument_CreateWithID(
  FLString docID,
);

/// Creates a new mutable CBLDocument instance that refers to the same document as the original.
/// If the original document has unsaved changes, the new one will also start out with the same
/// changes; but mutating one document thereafter will not affect the other.
/// @note  You must release the new reference when you're done with it. Similarly, the original
/// document still exists and must also be released when you're done with it.
@ffi.Native<NativeCBLDocument_MutableCopy>()
external ffi.Pointer<CBLDocument> CBLDocument_MutableCopy(
  ffi.Pointer<CBLDocument> original,
);

/// Returns a document's ID.
@ffi.Native<NativeCBLDocument_ID>()
external FLString CBLDocument_ID(
  ffi.Pointer<CBLDocument> arg0,
);

/// Returns a document's revision ID, which is a short opaque string that's guaranteed to be
/// unique to every change made to the document.
/// If the document doesn't exist yet, this function returns NULL.
@ffi.Native<NativeCBLDocument_RevisionID>()
external FLString CBLDocument_RevisionID(
  ffi.Pointer<CBLDocument> arg0,
);

/// Returns a document's current sequence in the local database.
/// This number increases every time the document is saved, and a more recently saved document
/// will have a greater sequence number than one saved earlier, so sequences may be used as an
/// abstract 'clock' to tell relative modification times.
@ffi.Native<NativeCBLDocument_Sequence>()
external int CBLDocument_Sequence(
  ffi.Pointer<CBLDocument> arg0,
);

/// Returns a document's collection or NULL for the new document that hasn't been saved.
@ffi.Native<NativeCBLDocument_Collection>()
external ffi.Pointer<CBLCollection> CBLDocument_Collection(
  ffi.Pointer<CBLDocument> arg0,
);

/// Returns a document's properties as a dictionary.
/// @note  The dictionary object is owned by the document; you do not need to release it.
/// @warning  When the document is released, this reference to the properties becomes invalid.
/// If you need to use any properties after releasing the document, you must retain them
/// by calling \ref FLValue_Retain (and of course later release them.)
/// @warning  This dictionary _reference_ is immutable, but if the document is mutable the
/// underlying dictionary itself is mutable and could be modified through a mutable
/// reference obtained via \ref CBLDocument_MutableProperties. If you need to preserve the
/// properties, call \ref FLDict_MutableCopy to make a deep copy.
@ffi.Native<NativeCBLDocument_Properties>()
external FLDict CBLDocument_Properties(
  ffi.Pointer<CBLDocument> arg0,
);

/// Returns a mutable document's properties as a mutable dictionary.
/// You may modify this dictionary and then call \ref CBLDatabase_SaveDocument to persist the changes.
/// @note  The dictionary object is owned by the document; you do not need to release it.
/// @note  Every call to this function returns the same mutable collection. This is the
/// same collection returned by \ref CBLDocument_Properties.
/// @note  When accessing nested collections inside the properties as a mutable collection
/// for modification, use \ref FLMutableDict_GetMutableDict or \ref FLMutableDict_GetMutableArray.
/// @warning  When the document is released, this reference to the properties becomes invalid.
/// If you need to use any properties after releasing the document, you must retain them
/// by calling \ref FLValue_Retain (and of course later release them.)
@ffi.Native<NativeCBLDocument_MutableProperties>()
external FLMutableDict CBLDocument_MutableProperties(
  ffi.Pointer<CBLDocument> arg0,
);

/// Sets a mutable document's properties.
/// Call \ref CBLDatabase_SaveDocument to persist the changes.
/// @note  The dictionary object will be retained by the document. You are responsible for
/// releasing any retained reference(s) you have to it.
@ffi.Native<NativeCBLDocument_SetProperties>()
external void CBLDocument_SetProperties(
  ffi.Pointer<CBLDocument> arg0,
  FLMutableDict properties,
);

/// Returns a document's properties as JSON.
/// @note  You are responsible for releasing the result by calling \ref FLSliceResult_Release.
@ffi.Native<NativeCBLDocument_CreateJSON>()
external FLSliceResult CBLDocument_CreateJSON(
  ffi.Pointer<CBLDocument> arg0,
);

/// Sets a mutable document's properties from a JSON string.
@ffi.Native<NativeCBLDocument_SetJSON>()
external bool CBLDocument_SetJSON(
  ffi.Pointer<CBLDocument> arg0,
  FLSlice json,
  ffi.Pointer<CBLError> outError,
);

/// Returns the time, if any, at which a given document will expire and be purged.
/// Documents don't normally expire; you have to call \ref CBLDatabase_SetDocumentExpiration
/// to set a document's expiration time.
/// @warning  <b>Deprecated :</b> Use CBLCollection_GetDocumentExpiration instead.
/// @param db  The database.
/// @param docID  The ID of the document.
/// @param outError  On failure, an error is written here.
/// @return  The expiration time as a CBLTimestamp (milliseconds since Unix epoch),
/// or 0 if the document does not have an expiration,
/// or -1 if the call failed.
@ffi.Native<NativeCBLDatabase_GetDocumentExpiration>()
external int CBLDatabase_GetDocumentExpiration(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

/// Sets or clears the expiration time of a document.
/// @warning  <b>Deprecated :</b> Use CBLCollection_SetDocumentExpiration instead.
/// @param db  The database.
/// @param docID  The ID of the document.
/// @param expiration  The expiration time as a CBLTimestamp (milliseconds since Unix epoch),
/// or 0 if the document should never expire.
/// @param outError  On failure, an error is written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLDatabase_SetDocumentExpiration>()
external bool CBLDatabase_SetDocumentExpiration(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  int expiration,
  ffi.Pointer<CBLError> outError,
);

/// Registers a document change listener callback. It will be called after a specific document
/// is changed on disk.
/// @warning  <b>Deprecated :</b> Use CBLCollection_AddDocumentChangeListener on the default collection instead.
/// @param db  The database to observe.
/// @param docID  The ID of the document to observe.
/// @param listener  The callback to be invoked.
/// @param context  An opaque value that will be passed to the callback.
/// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the listener.
@ffi.Native<NativeCBLDatabase_AddDocumentChangeListener>()
external ffi.Pointer<CBLListenerToken> CBLDatabase_AddDocumentChangeListener(
  ffi.Pointer<CBLDatabase> db,
  FLString docID,
  CBLDocumentChangeListener listener,
  ffi.Pointer<ffi.Void> context,
);

/// The default collection's name.
@ffi.Native<FLString>()
external final FLString kCBLDefaultCollectionName;

/// Returns the names of all existing scopes in the database.
/// The scope exists when there is at least one collection created under the scope.
/// @note The default scope will always exist, containing at least the default collection.
/// @note You are responsible for releasing the returned array.
/// @param db  The database.
/// @param outError  On failure, the error will be written here.
/// @return  The names of all existing scopes in the database, or NULL if an error occurred.
@ffi.Native<NativeCBLDatabase_ScopeNames>()
external FLMutableArray CBLDatabase_ScopeNames(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLError> outError,
);

/// Returns the names of all collections in the scope.
/// @note  You are responsible for releasing the returned array.
/// @param db  The database.
/// @param scopeName  The name of the scope.
/// @param outError  On failure, the error will be written here.
/// @return  The names of all collections in the scope, or NULL if an error occurred.
@ffi.Native<NativeCBLDatabase_CollectionNames>()
external FLMutableArray CBLDatabase_CollectionNames(
  ffi.Pointer<CBLDatabase> db,
  FLString scopeName,
  ffi.Pointer<CBLError> outError,
);

/// Returns an existing scope with the given name.
/// The scope exists when there is at least one collection created under the scope.
/// @note The default scope will always exist, containing at least the default collection.
/// @note You are responsible for releasing the returned scope.
/// @param db  The database.
/// @param scopeName  The name of the scope.
/// @param outError  On failure, the error will be written here.
/// @return  A \ref CBLScope instance, or NULL if the scope doesn't exist or an error occurred.
@ffi.Native<NativeCBLDatabase_Scope>()
external ffi.Pointer<CBLScope> CBLDatabase_Scope(
  ffi.Pointer<CBLDatabase> db,
  FLString scopeName,
  ffi.Pointer<CBLError> outError,
);

/// Returns the existing collection with the given name and scope.
/// @note  You are responsible for releasing the returned collection.
/// @param db  The database.
/// @param collectionName  The name of the collection.
/// @param scopeName  The name of the scope.
/// @param outError  On failure, the error will be written here.
/// @return A \ref CBLCollection instance, or NULL if the collection doesn't exist or an error occurred.
@ffi.Native<NativeCBLDatabase_Collection>()
external ffi.Pointer<CBLCollection> CBLDatabase_Collection(
  ffi.Pointer<CBLDatabase> db,
  FLString collectionName,
  FLString scopeName,
  ffi.Pointer<CBLError> outError,
);

/// Create a new collection.
/// The naming rules of the collections and scopes are as follows:
/// - Must be between 1 and 251 characters in length.
/// - Can only contain the characters A-Z, a-z, 0-9, and the symbols _, -, and %.
/// - Cannot start with _ or %.
/// - Both scope and collection names are case sensitive.
/// @note  If the collection already exists, the existing collection will be returned.
/// @note  You are responsible for releasing the returned collection.
/// @param db  The database.
/// @param collectionName  The name of the collection.
/// @param scopeName  The name of the scope.
/// @param outError  On failure, the error will be written here.
/// @return  A \ref CBLCollection instance, or NULL if an error occurred.
@ffi.Native<NativeCBLDatabase_CreateCollection>()
external ffi.Pointer<CBLCollection> CBLDatabase_CreateCollection(
  ffi.Pointer<CBLDatabase> db,
  FLString collectionName,
  FLString scopeName,
  ffi.Pointer<CBLError> outError,
);

/// Delete an existing collection.
/// @note  The default collection cannot be deleted.
/// @param db  The database.
/// @param collectionName  The name of the collection.
/// @param scopeName  The name of the scope.
/// @param outError  On failure, the error will be written here.
/// @return  True if success, or False if an error occurred.
@ffi.Native<NativeCBLDatabase_DeleteCollection>()
external bool CBLDatabase_DeleteCollection(
  ffi.Pointer<CBLDatabase> db,
  FLString collectionName,
  FLString scopeName,
  ffi.Pointer<CBLError> outError,
);

/// Returns the default scope.
/// @note  You are responsible for releasing the returned scope.
/// @param db  The database.
/// @param outError  On failure, the error will be written here.
/// @return  A \ref CBLScope instance, or NULL if an error occurred.
@ffi.Native<NativeCBLDatabase_DefaultScope>()
external ffi.Pointer<CBLScope> CBLDatabase_DefaultScope(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLError> outError,
);

/// Returns the default collection.
/// @note  You are responsible for releasing the returned collection.
/// @param db  The database.
/// @param outError  On failure, the error will be written here.
/// @return  A \ref CBLCollection instance, or NULL if an error occurred.
@ffi.Native<NativeCBLDatabase_DefaultCollection>()
external ffi.Pointer<CBLCollection> CBLDatabase_DefaultCollection(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLError> outError,
);

/// Returns the collection's scope.
/// @note You are responsible for releasing the returned scope.
/// @param collection  The collection.
/// @return The scope of the collection.
@ffi.Native<NativeCBLCollection_Scope>()
external ffi.Pointer<CBLScope> CBLCollection_Scope(
  ffi.Pointer<CBLCollection> collection,
);

/// Returns the collection's name.
/// @param collection  The collection.
/// @return The name of the collection.
@ffi.Native<NativeCBLCollection_Name>()
external FLString CBLCollection_Name(
  ffi.Pointer<CBLCollection> collection,
);

/// Returns the collection's fully qualified name in the '<scope-name>.<collection-name>' format.
/// @param collection  The collection.
/// @return The fully qualified name of the collection.
@ffi.Native<NativeCBLCollection_FullName>()
external FLString CBLCollection_FullName(
  ffi.Pointer<CBLCollection> collection,
);

/// Returns the collection's database.
/// @note The database object is owned by the collection object; you do not need to release it.
/// @param collection  The collection.
/// @return The database of the collection.
@ffi.Native<NativeCBLCollection_Database>()
external ffi.Pointer<CBLDatabase> CBLCollection_Database(
  ffi.Pointer<CBLCollection> collection,
);

/// Returns the number of documents in the collection.
/// @param collection  The collection.
/// @return  the number of documents in the collection.
@ffi.Native<NativeCBLCollection_Count>()
external int CBLCollection_Count(
  ffi.Pointer<CBLCollection> collection,
);

/// Reads a document from the collection, creating a new (immutable) \ref CBLDocument object.
/// Each call to this function creates a new object (which must later be released.)
/// @note  If you are reading the document in order to make changes to it, call
/// CBLCollection_GetMutableDocument instead.
/// @param collection  The collection.
/// @param docID  The ID of the document.
/// @param outError  On failure, the error will be written here. (A nonexistent document is not
/// considered a failure; in that event the error code will be zero.)
/// @return  A new \ref CBLDocument instance, or NULL if the doc doesn't exist or an error occurred.
@ffi.Native<NativeCBLCollection_GetDocument>()
external ffi.Pointer<CBLDocument> CBLCollection_GetDocument(
  ffi.Pointer<CBLCollection> collection,
  FLString docID,
  ffi.Pointer<CBLError> outError,
);

/// Saves a (mutable) document to the collection.
/// @warning  If a newer revision has been saved since the doc was loaded, it will be
/// overwritten by this one. This can lead to data loss! To avoid this, call
/// \ref CBLCollection_SaveDocumentWithConcurrencyControl or
/// \ref CBLCollection_SaveDocumentWithConflictHandler instead.
/// @param collection  The collection to save to.
/// @param doc  The mutable document to save.
/// @param outError  On failure, the error will be written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLCollection_SaveDocument>()
external bool CBLCollection_SaveDocument(
  ffi.Pointer<CBLCollection> collection,
  ffi.Pointer<CBLDocument> doc,
  ffi.Pointer<CBLError> outError,
);

/// Saves a (mutable) document to the collection.
/// If a conflicting revision has been saved since \p doc was loaded, the \p concurrency
/// parameter specifies whether the save should fail, or the conflicting revision should
/// be overwritten with the revision being saved.
/// If you need finer-grained control, call \ref CBLCollection_SaveDocumentWithConflictHandler instead.
/// @param collection  The collection to save to.
/// @param doc  The mutable document to save.
/// @param concurrency  Conflict-handling strategy (fail or overwrite).
/// @param outError  On failure, the error will be written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLCollection_SaveDocumentWithConcurrencyControl>()
external bool CBLCollection_SaveDocumentWithConcurrencyControl(
  ffi.Pointer<CBLCollection> collection,
  ffi.Pointer<CBLDocument> doc,
  int concurrency,
  ffi.Pointer<CBLError> outError,
);

/// Saves a (mutable) document to the collection, allowing for custom conflict handling in the event
/// that the document has been updated since \p doc was loaded.
/// @param collection  The collection to save to.
/// @param doc  The mutable document to save.
/// @param conflictHandler  The callback to be invoked if there is a conflict.
/// @param context  An arbitrary value to be passed to the \p conflictHandler.
/// @param outError  On failure, the error will be written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLCollection_SaveDocumentWithConflictHandler>()
external bool CBLCollection_SaveDocumentWithConflictHandler(
  ffi.Pointer<CBLCollection> collection,
  ffi.Pointer<CBLDocument> doc,
  CBLConflictHandler conflictHandler,
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLError> outError,
);

/// Deletes a document from the collection. Deletions are replicated.
/// @warning  You are still responsible for releasing the CBLDocument.
/// @param collection  The collection containing the document.
/// @param document  The document to delete.
/// @param outError  On failure, the error will be written here.
/// @return  True if the document was deleted, false if an error occurred.
@ffi.Native<NativeCBLCollection_DeleteDocument>()
external bool CBLCollection_DeleteDocument(
  ffi.Pointer<CBLCollection> collection,
  ffi.Pointer<CBLDocument> document,
  ffi.Pointer<CBLError> outError,
);

/// Deletes a document from the collection. Deletions are replicated.
/// @warning You are still responsible for releasing the CBLDocument.
/// @param collection  The collection containing the document.
/// @param document  The document to delete.
/// @param concurrency  Conflict-handling strategy.
/// @param outError  On failure, the error will be written here.
/// @return  True if the document was deleted, false if an error occurred.
@ffi.Native<NativeCBLCollection_DeleteDocumentWithConcurrencyControl>()
external bool CBLCollection_DeleteDocumentWithConcurrencyControl(
  ffi.Pointer<CBLCollection> collection,
  ffi.Pointer<CBLDocument> document,
  int concurrency,
  ffi.Pointer<CBLError> outError,
);

/// Purges a document. This removes all traces of the document from the collection.
/// Purges are _not_ replicated. If the document is changed on a server, it will be re-created
/// when pulled.
/// @warning  You are still responsible for releasing the \ref CBLDocument reference.
/// @note  If you don't have the document in memory already, \ref CBLCollection_PurgeDocumentByID is a
/// simpler shortcut.
/// @param collection  The collection containing the document.
/// @param document  The document to delete.
/// @param outError  On failure, the error will be written here.
/// @return  True if the document was purged, false if it doesn't exist or the purge failed.
@ffi.Native<NativeCBLCollection_PurgeDocument>()
external bool CBLCollection_PurgeDocument(
  ffi.Pointer<CBLCollection> collection,
  ffi.Pointer<CBLDocument> document,
  ffi.Pointer<CBLError> outError,
);

/// Purges a document, given only its ID.
/// @note  If no document with that ID exists, this function will return false but the error code will be zero.
/// @param collection  The collection.
/// @param docID  The document ID to purge.
/// @param outError  On failure, the error will be written here.
/// @return  True if the document was purged, false if it doesn't exist or the purge failed.
@ffi.Native<NativeCBLCollection_PurgeDocumentByID>()
external bool CBLCollection_PurgeDocumentByID(
  ffi.Pointer<CBLCollection> collection,
  FLString docID,
  ffi.Pointer<CBLError> outError,
);

/// Returns the time, if any, at which a given document will expire and be purged.
/// Documents don't normally expire; you have to call \ref CBLCollection_SetDocumentExpiration
/// to set a document's expiration time.
/// @param collection  The collection.
/// @param docID  The ID of the document.
/// @param outError  On failure, an error is written here.
/// @return  The expiration time as a CBLTimestamp (milliseconds since Unix epoch),
/// or 0 if the document does not have an expiration,
/// or -1 if the call failed.
@ffi.Native<NativeCBLCollection_GetDocumentExpiration>()
external int CBLCollection_GetDocumentExpiration(
  ffi.Pointer<CBLCollection> collection,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

/// Sets or clears the expiration time of a document.
/// @param collection  The collection.
/// @param docID  The ID of the document.
/// @param expiration  The expiration time as a CBLTimestamp (milliseconds since Unix epoch),
/// or 0 if the document should never expire.
/// @param outError  On failure, an error is written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLCollection_SetDocumentExpiration>()
external bool CBLCollection_SetDocumentExpiration(
  ffi.Pointer<CBLCollection> collection,
  FLSlice docID,
  int expiration,
  ffi.Pointer<CBLError> outError,
);

/// Reads a document from the collection, in mutable form that can be updated and saved.
/// (This function is otherwise identical to \ref CBLCollection_GetDocument.)
/// @note  You must release the document when you're done with it.
/// @param collection  The collection.
/// @param docID  The ID of the document.
/// @param outError  On failure, the error will be written here. (A nonexistent document is not
/// considered a failure; in that event the error code will be zero.)
/// @return  A new \ref CBLDocument instance, or NULL if the doc doesn't exist or an error occurred.
@ffi.Native<NativeCBLCollection_GetMutableDocument>()
external ffi.Pointer<CBLDocument> CBLCollection_GetMutableDocument(
  ffi.Pointer<CBLCollection> collection,
  FLString docID,
  ffi.Pointer<CBLError> outError,
);

/// Creates a value index in the collection.
/// If an identical index with that name already exists, nothing happens (and no error is returned.)
/// If a non-identical index with that name already exists, it is deleted and re-created.
/// @param collection  The collection.
/// @param name  The name of the index.
/// @param config  The index configuration.
/// @param outError  On failure, an error is written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLCollection_CreateValueIndex>()
external bool CBLCollection_CreateValueIndex(
  ffi.Pointer<CBLCollection> collection,
  FLString name,
  CBLValueIndexConfiguration config,
  ffi.Pointer<CBLError> outError,
);

/// Creates a full-text index in the collection.
/// If an identical index with that name already exists, nothing happens (and no error is returned.)
/// If a non-identical index with that name already exists, it is deleted and re-created.
/// @param collection  The collection.
/// @param name  The name of the index.
/// @param config  The index configuration.
/// @param outError  On failure, an error is written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLCollection_CreateFullTextIndex>()
external bool CBLCollection_CreateFullTextIndex(
  ffi.Pointer<CBLCollection> collection,
  FLString name,
  CBLFullTextIndexConfiguration config,
  ffi.Pointer<CBLError> outError,
);

/// Deletes an index in the collection by name.
/// @param collection  The collection.
/// @param name  The name of the index.
/// @param outError  On failure, an error is written here.
/// @return  True on success, false on failure.
@ffi.Native<NativeCBLCollection_DeleteIndex>()
external bool CBLCollection_DeleteIndex(
  ffi.Pointer<CBLCollection> collection,
  FLString name,
  ffi.Pointer<CBLError> outError,
);

/// Returns the names of the indexes in the collection, as a Fleece array of strings.
/// @note  You are responsible for releasing the returned Fleece array.
/// @param collection  The collection.
/// @param outError  On failure, an error is written here.
/// @return  The index names in the collection, or NULL if an error occurred.
@ffi.Native<NativeCBLCollection_GetIndexNames>()
external FLMutableArray CBLCollection_GetIndexNames(
  ffi.Pointer<CBLCollection> collection,
  ffi.Pointer<CBLError> outError,
);

/// Returns an index object representing an existing index in the collection.
/// @note You are responsible for releasing the returned index object.
/// @param collection The collection.
/// @param name  The name of the index.
/// @param outError  On failure, an error is written here.
/// @return A \ref CBLQueryIndex instance if the index exists, or NULL if the index doesn't exist or an error occurred.
@ffi.Native<NativeCBLCollection_GetIndex>()
external ffi.Pointer<CBLQueryIndex> CBLCollection_GetIndex(
  ffi.Pointer<CBLCollection> collection,
  FLString name,
  ffi.Pointer<CBLError> outError,
);

/// Registers a collection change listener callback. It will be called after one or more documents are changed on disk.
/// @param collection  The collection to observe.
/// @param listener  The callback to be invoked.
/// @param context  An opaque value that will be passed to the callback.
/// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the listener.
@ffi.Native<NativeCBLCollection_AddChangeListener>()
external ffi.Pointer<CBLListenerToken> CBLCollection_AddChangeListener(
  ffi.Pointer<CBLCollection> collection,
  CBLCollectionChangeListener listener,
  ffi.Pointer<ffi.Void> context,
);

/// Registers a document change listener callback. It will be called after a specific document is changed on disk.
/// @param collection  The collection to observe.
/// @param docID  The ID of the document to observe.
/// @param listener  The callback to be invoked.
/// @param context  An opaque value that will be passed to the callback.
/// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the listener.
@ffi.Native<NativeCBLCollection_AddDocumentChangeListener>()
external ffi.Pointer<CBLListenerToken> CBLCollection_AddDocumentChangeListener(
  ffi.Pointer<CBLCollection> collection,
  FLString docID,
  CBLCollectionDocumentChangeListener listener,
  ffi.Pointer<ffi.Void> context,
);

/// Returns the default database configuration.
@ffi.Native<NativeCBLDatabaseConfiguration_Default>()
external CBLDatabaseConfiguration CBLDatabaseConfiguration_Default();

/// Returns true if a database with the given name exists in the given directory.
/// @param name  The database name (without the ".cblite2" extension.)
/// @param inDirectory  The directory containing the database. If NULL, `name` must be an
/// absolute or relative path to the database.
@ffi.Native<NativeCBL_DatabaseExists>()
external bool CBL_DatabaseExists(
  FLString name,
  FLString inDirectory,
);

/// Copies a database file to a new location, and assigns it a new internal UUID to distinguish
/// it from the original database when replicating.
/// @param fromPath  The full filesystem path to the original database (including extension).
/// @param toName  The new database name (without the ".cblite2" extension.)
/// @param config  The database configuration (directory and encryption option.)
/// @param outError  On return, will be set to the error that occurred, if applicable.
/// @note While a database is open, one or more of its files may be in use.  Attempting to copy a file, while it is in use, will fail.  We recommend that you close a database before attempting to copy it.
@ffi.Native<NativeCBL_CopyDatabase>()
external bool CBL_CopyDatabase(
  FLString fromPath,
  FLString toName,
  ffi.Pointer<CBLDatabaseConfiguration> config,
  ffi.Pointer<CBLError> outError,
);

/// Deletes a database file. If the database file is open, an error is returned.
/// @param name  The database name (without the ".cblite2" extension.)
/// @param inDirectory  The directory containing the database. If NULL, `name` must be an
/// absolute or relative path to the database.
/// @param outError  On return, will be set to the error that occurred, or a 0 code if no error.
/// @return  True if the database was deleted, false if it doesn't exist or deletion failed.
/// (You can tell the last two cases apart by looking at \p outError.)
@ffi.Native<NativeCBL_DeleteDatabase>()
external bool CBL_DeleteDatabase(
  FLString name,
  FLString inDirectory,
  ffi.Pointer<CBLError> outError,
);

/// Opens a database, or creates it if it doesn't exist yet, returning a new \ref CBLDatabase
/// instance.
/// It's OK to open the same database file multiple times. Each \ref CBLDatabase instance is
/// independent of the others (and must be separately closed and released.)
/// @param name  The database name (without the ".cblite2" extension.)
/// @param config  The database configuration (directory and encryption option.)
/// @param outError  On failure, the error will be written here.
/// @return  The new database object, or NULL on failure.
@ffi.Native<NativeCBLDatabase_Open>()
external ffi.Pointer<CBLDatabase> CBLDatabase_Open(
  FLSlice name,
  ffi.Pointer<CBLDatabaseConfiguration> config,
  ffi.Pointer<CBLError> outError,
);

/// Closes an open database.
@ffi.Native<NativeCBLDatabase_Close>()
external bool CBLDatabase_Close(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> outError,
);

/// Closes and deletes a database. If there are any other connections to the database,
/// an error is returned.
@ffi.Native<NativeCBLDatabase_Delete>()
external bool CBLDatabase_Delete(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> outError,
);

/// Begins a transaction. You **must** later call \ref
/// CBLDatabase_EndTransaction to commit or abort the transaction.
/// @note  Multiple writes are much faster when grouped in a transaction.
/// @note  Changes will not be visible to other CBLDatabase instances on the same database until
/// the transaction ends.
/// @note  Transactions can nest. Changes are not committed until the outer transaction ends.
@ffi.Native<NativeCBLDatabase_BeginTransaction>()
external bool CBLDatabase_BeginTransaction(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> outError,
);

/// Ends a transaction, either committing or aborting.
@ffi.Native<NativeCBLDatabase_EndTransaction>()
external bool CBLDatabase_EndTransaction(
  ffi.Pointer<CBLDatabase> arg0,
  bool commit,
  ffi.Pointer<CBLError> outError,
);

/// Performs database maintenance.
@ffi.Native<NativeCBLDatabase_PerformMaintenance>()
external bool CBLDatabase_PerformMaintenance(
  ffi.Pointer<CBLDatabase> db,
  int type,
  ffi.Pointer<CBLError> outError,
);

/// Returns the database's name.
@ffi.Native<NativeCBLDatabase_Name>()
external FLString CBLDatabase_Name(
  ffi.Pointer<CBLDatabase> arg0,
);

/// Returns the database's full filesystem path, or null slice if the database is closed or deleted.
@ffi.Native<NativeCBLDatabase_Path>()
external FLStringResult CBLDatabase_Path(
  ffi.Pointer<CBLDatabase> arg0,
);

/// Returns the number of documents in the database, or zero if the database is closed or deleted.
/// @warning  <b>Deprecated :</b> Use CBLCollection_Count on the default collection instead.
@ffi.Native<NativeCBLDatabase_Count>()
external int CBLDatabase_Count(
  ffi.Pointer<CBLDatabase> arg0,
);

/// Returns the database's configuration, as given when it was opened.
@ffi.Native<NativeCBLDatabase_Config>()
external CBLDatabaseConfiguration CBLDatabase_Config(
  ffi.Pointer<CBLDatabase> arg0,
);

/// Creates a value index.
/// Indexes are persistent.
/// If an identical index with that name already exists, nothing happens (and no error is returned.)
/// If a non-identical index with that name already exists, it is deleted and re-created.
/// @warning  <b>Deprecated :</b> Use CBLCollection_CreateValueIndex on the default collection instead.
@ffi.Native<NativeCBLDatabase_CreateValueIndex>()
external bool CBLDatabase_CreateValueIndex(
  ffi.Pointer<CBLDatabase> db,
  FLString name,
  CBLValueIndexConfiguration config,
  ffi.Pointer<CBLError> outError,
);

/// Creates a full-text index.
/// Indexes are persistent.
/// If an identical index with that name already exists, nothing happens (and no error is returned.)
/// If a non-identical index with that name already exists, it is deleted and re-created.
/// @warning  <b>Deprecated :</b> Use CBLCollection_CreateFullTextIndex on the default collection instead.
@ffi.Native<NativeCBLDatabase_CreateFullTextIndex>()
external bool CBLDatabase_CreateFullTextIndex(
  ffi.Pointer<CBLDatabase> db,
  FLString name,
  CBLFullTextIndexConfiguration config,
  ffi.Pointer<CBLError> outError,
);

/// Deletes an index given its name.
/// @warning  <b>Deprecated :</b> Use CBLCollection_DeleteIndex on the default collection instead.
@ffi.Native<NativeCBLDatabase_DeleteIndex>()
external bool CBLDatabase_DeleteIndex(
  ffi.Pointer<CBLDatabase> db,
  FLString name,
  ffi.Pointer<CBLError> outError,
);

/// Returns the names of the indexes on this database, as a Fleece array of strings.
/// @note  You are responsible for releasing the returned Fleece array.
/// @warning  <b>Deprecated :</b> Use CBLCollection_GetIndexNames on the default collection instead.
@ffi.Native<NativeCBLDatabase_GetIndexNames>()
external FLArray CBLDatabase_GetIndexNames(
  ffi.Pointer<CBLDatabase> db,
);

/// Registers a default collection change listener callback. It will be called after one or more
/// documents are changed on disk.
/// @warning  <b>Deprecated :</b> Use CBLCollection_AddChangeListener on the default collection instead.
/// @param db  The database to observe.
/// @param listener  The callback to be invoked.
/// @param context  An opaque value that will be passed to the callback.
/// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the listener.
@ffi.Native<NativeCBLDatabase_AddChangeListener>()
external ffi.Pointer<CBLListenerToken> CBLDatabase_AddChangeListener(
  ffi.Pointer<CBLDatabase> db,
  CBLDatabaseChangeListener listener,
  ffi.Pointer<ffi.Void> context,
);

/// Switches the database to buffered-notification mode. Notifications for objects belonging
/// to this database (documents, queries, replicators, and of course the database) will not be
/// called immediately; your \ref CBLNotificationsReadyCallback will be called instead.
/// @param db  The database whose notifications are to be buffered.
/// @param callback  The function to be called when a notification is available.
/// @param context  An arbitrary value that will be passed to the callback.
@ffi.Native<NativeCBLDatabase_BufferNotifications>()
external void CBLDatabase_BufferNotifications(
  ffi.Pointer<CBLDatabase> db,
  CBLNotificationsReadyCallback callback,
  ffi.Pointer<ffi.Void> context,
);

/// Immediately issues all pending notifications for this database, by calling their listener
/// callbacks.
@ffi.Native<NativeCBLDatabase_SendNotifications>()
external void CBLDatabase_SendNotifications(
  ffi.Pointer<CBLDatabase> db,
);

/// The name of the HTTP cookie used by Sync Gateway to store session keys.
@ffi.Native<FLString>()
external final FLString kCBLAuthDefaultCookieName;

/// Creates a new endpoint representing a server-based database at the given URL.
/// The URL's scheme must be `ws` or `wss`, it must of course have a valid hostname,
/// and its path must be the name of the database on that server.
///
/// The port can be omitted; it defaults to 80 for `ws` and 443 for `wss`.
/// For example: `wss://example.org/dbname`.
///
/// If an invalid endpoint URL is specified, an error will be returned.
@ffi.Native<NativeCBLEndpoint_CreateWithURL>()
external ffi.Pointer<CBLEndpoint> CBLEndpoint_CreateWithURL(
  FLString url,
  ffi.Pointer<CBLError> outError,
);

/// Frees a CBLEndpoint object.
@ffi.Native<NativeCBLEndpoint_Free>()
external void CBLEndpoint_Free(
  ffi.Pointer<CBLEndpoint> arg0,
);

/// Creates an authenticator for HTTP Basic (username/password) auth.
@ffi.Native<NativeCBLAuth_CreatePassword>()
external ffi.Pointer<CBLAuthenticator> CBLAuth_CreatePassword(
  FLString username,
  FLString password,
);

/// Creates an authenticator using a Couchbase Sync Gateway login session identifier,
/// and optionally a cookie name (pass NULL for the default.)
@ffi.Native<NativeCBLAuth_CreateSession>()
external ffi.Pointer<CBLAuthenticator> CBLAuth_CreateSession(
  FLString sessionID,
  FLString cookieName,
);

/// Frees a CBLAuthenticator object.
@ffi.Native<NativeCBLAuth_Free>()
external void CBLAuth_Free(
  ffi.Pointer<CBLAuthenticator> arg0,
);

/// Default conflict resolver. This always returns `localDocument`.
@ffi.Native<CBLConflictResolver>()
external CBLConflictResolver CBLDefaultConflictResolver;

/// Creates a replicator with the given configuration.
@ffi.Native<NativeCBLReplicator_Create>()
external ffi.Pointer<CBLReplicator> CBLReplicator_Create(
  ffi.Pointer<CBLReplicatorConfiguration> arg0,
  ffi.Pointer<CBLError> outError,
);

/// Returns the configuration of an existing replicator.
@ffi.Native<NativeCBLReplicator_Config>()
external ffi.Pointer<CBLReplicatorConfiguration> CBLReplicator_Config(
  ffi.Pointer<CBLReplicator> arg0,
);

/// Starts a replicator, asynchronously. Does nothing if it's already started.
/// @note Replicators cannot be started from within a database's transaction.
/// @param replicator  The replicator instance.
/// @param resetCheckpoint  If true, the persistent saved state ("checkpoint") for this replication
/// will be discarded, causing it to re-scan all documents. This significantly
/// increases time and bandwidth (redundant docs are not transferred, but their
/// IDs are) but can resolve unexpected problems with missing documents if one
/// side or the other has gotten out of sync.
@ffi.Native<NativeCBLReplicator_Start>()
external void CBLReplicator_Start(
  ffi.Pointer<CBLReplicator> replicator,
  bool resetCheckpoint,
);

/// Stops a running replicator, asynchronously. Does nothing if it's not already started.
/// The replicator will call your \ref CBLReplicatorChangeListener with an activity level of
/// \ref kCBLReplicatorStopped after it stops. Until then, consider it still active.
@ffi.Native<NativeCBLReplicator_Stop>()
external void CBLReplicator_Stop(
  ffi.Pointer<CBLReplicator> arg0,
);

/// Informs the replicator whether it's considered possible to reach the remote host with
/// the current network configuration. The default value is true. This only affects the
/// replicator's behavior while it's in the Offline state:
/// Setting it to false will cancel any pending retry and prevent future automatic retries.
/// Setting it back to true will initiate an immediate retry.
@ffi.Native<NativeCBLReplicator_SetHostReachable>()
external void CBLReplicator_SetHostReachable(
  ffi.Pointer<CBLReplicator> arg0,
  bool reachable,
);

/// Puts the replicator in or out of "suspended" state. The default is false.
/// Setting suspended=true causes the replicator to disconnect and enter Offline state;
/// it will not attempt to reconnect while it's suspended.
/// Setting suspended=false causes the replicator to attempt to reconnect, _if_ it was
/// connected when suspended, and is still in Offline state.
@ffi.Native<NativeCBLReplicator_SetSuspended>()
external void CBLReplicator_SetSuspended(
  ffi.Pointer<CBLReplicator> repl,
  bool suspended,
);

/// Returns the replicator's current status.
@ffi.Native<NativeCBLReplicator_Status>()
external CBLReplicatorStatus CBLReplicator_Status(
  ffi.Pointer<CBLReplicator> arg0,
);

/// Indicates which documents in the default collection have local changes that have not yet
/// been pushed to the server by this replicator. This is of course a snapshot, that will
/// go out of date as the replicator makes progress and/or documents are saved locally.
///
/// The result is, effectively, a set of document IDs: a dictionary whose keys are the IDs and
/// values are `true`.
/// If there are no pending documents, the dictionary is empty.
/// On error, NULL is returned.
///
/// @note  This function can be called on a stopped or un-started replicator.
/// @note  Documents that would never be pushed by this replicator, due to its configuration's
/// `pushFilter` or `docIDs`, are ignored.
/// @warning  You are responsible for releasing the returned array via \ref FLValue_Release.
/// @warning  If the default collection is not part of the replication, a NULL with an error
/// will be returned.
/// @warning  <b>Deprecated :</b> Use CBLReplicator_PendingDocumentIDs2 instead.
@ffi.Native<NativeCBLReplicator_PendingDocumentIDs>()
external FLDict CBLReplicator_PendingDocumentIDs(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<CBLError> outError,
);

/// Indicates whether the document in the default collection with the given ID has local changes that
/// have not yet been pushed to the server by this replicator.
///
/// This is equivalent to, but faster than, calling \ref CBLReplicator_PendingDocumentIDs and
/// checking whether the result contains \p docID. See that function's documentation for details.
/// @note  A `false` result means the document is not pending, _or_ there was an error.
/// To tell the difference, compare the error code to zero.
/// @warning  If the default collection is not part of the replication, a NULL with an error
/// will be returned.
/// @warning  <b>Deprecated :</b> Use CBLReplicator_IsDocumentPending2 instead.
@ffi.Native<NativeCBLReplicator_IsDocumentPending>()
external bool CBLReplicator_IsDocumentPending(
  ffi.Pointer<CBLReplicator> repl,
  FLString docID,
  ffi.Pointer<CBLError> outError,
);

/// Indicates which documents in the given collection have local changes that have not yet been
/// pushed to the server by this replicator. This is of course a snapshot, that will go out of date
/// as the replicator makes progress and/or documents are saved locally.
///
/// The result is, effectively, a set of document IDs: a dictionary whose keys are the IDs and
/// values are `true`.
/// If there are no pending documents, the dictionary is empty.
/// On error, NULL is returned.
/// @warning If the given collection is not part of the replication, a NULL with an error will be returned.
@ffi.Native<NativeCBLReplicator_PendingDocumentIDs2>()
external FLDict CBLReplicator_PendingDocumentIDs2(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<CBLCollection> collection,
  ffi.Pointer<CBLError> outError,
);

/// Indicates whether the document with the given ID in the given collection has local changes
/// that have not yet been pushed to the server by this replicator.
///
/// This is equivalent to, but faster than, calling \ref CBLReplicator_PendingDocumentIDs2 and
/// checking whether the result contains \p docID. See that function's documentation for details.
/// @note  A `false` result means the document is not pending, _or_ there was an error.
/// To tell the difference, compare the error code to zero.
/// @warning  If the given collection is not part of the replication, a NULL with an error will be returned.
@ffi.Native<NativeCBLReplicator_IsDocumentPending2>()
external bool CBLReplicator_IsDocumentPending2(
  ffi.Pointer<CBLReplicator> repl,
  FLString docID,
  ffi.Pointer<CBLCollection> collection,
  ffi.Pointer<CBLError> outError,
);

/// Registers a listener that will be called when the replicator's status changes.
@ffi.Native<NativeCBLReplicator_AddChangeListener>()
external ffi.Pointer<CBLListenerToken> CBLReplicator_AddChangeListener(
  ffi.Pointer<CBLReplicator> arg0,
  CBLReplicatorChangeListener arg1,
  ffi.Pointer<ffi.Void> context,
);

/// Registers a listener that will be called when documents are replicated.
@ffi.Native<NativeCBLReplicator_AddDocumentReplicationListener>()
external ffi.Pointer<CBLListenerToken>
    CBLReplicator_AddDocumentReplicationListener(
  ffi.Pointer<CBLReplicator> arg0,
  CBLDocumentReplicationListener arg1,
  ffi.Pointer<ffi.Void> context,
);

/// [false] Plaintext is not used, and instead binary encoding is used in log files
@ffi.Native<ffi.Bool>()
external final bool kCBLDefaultLogFileUsePlaintext;

/// [false] Plaintext is not used, and instead binary encoding is used in log files
/// @warning <b>Deprecated :</b> Use kCBLDefaultLogFileUsePlaintext instead.
@ffi.Native<ffi.Bool>()
external final bool kCBLDefaultLogFileUsePlainText;

/// [524288] 512 KiB for the size of a log file
@ffi.Native<ffi.Size>()
external final int kCBLDefaultLogFileMaxSize;

/// [1] 1 rotated file present (2 total, including the currently active log file)
@ffi.Native<ffi.Uint32>()
external final int kCBLDefaultLogFileMaxRotateCount;

/// [false] Accents and ligatures are not ignored when indexing via full text search
@ffi.Native<ffi.Bool>()
external final bool kCBLDefaultFullTextIndexIgnoreAccents;

/// [kCBLReplicatorTypePushAndPull] Perform bidirectional replication
@ffi.Native<CBLReplicatorType>()
external final int kCBLDefaultReplicatorType;

/// [false] One-shot replication is used, and will stop once all initial changes are processed
@ffi.Native<ffi.Bool>()
external final bool kCBLDefaultReplicatorContinuous;

/// [300] A heartbeat messages is sent every 300 seconds to keep the connection alive
@ffi.Native<ffi.UnsignedInt>()
external final int kCBLDefaultReplicatorHeartbeat;

/// [10] When replicator is not continuous, after 10 failed attempts give up on the replication
@ffi.Native<ffi.UnsignedInt>()
external final int kCBLDefaultReplicatorMaxAttemptsSingleShot;

/// [UINT_MAX] When replicator is continuous, never give up unless explicitly stopped
@ffi.Native<ffi.UnsignedInt>()
external final int kCBLDefaultReplicatorMaxAttemptsContinuous;

/// [300] Max wait time between retry attempts in seconds
@ffi.Native<ffi.UnsignedInt>()
external final int kCBLDefaultReplicatorMaxAttemptsWaitTime;

/// [300] Max wait time between retry attempts in seconds
/// @warning <b>Deprecated :</b> Use kCBLDefaultReplicatorMaxAttemptsWaitTime instead.
@ffi.Native<ffi.UnsignedInt>()
external final int kCBLDefaultReplicatorMaxAttemptWaitTime;

/// [false] Purge documents when a user loses access
@ffi.Native<ffi.Bool>()
external final bool kCBLDefaultReplicatorDisableAutoPurge;

/// [false] Whether or not a replicator only accepts cookies for the sender's parent domains
@ffi.Native<ffi.Bool>()
external final bool kCBLDefaultReplicatorAcceptParentCookies;

/// Formats and writes a message to the log, in the given domain at the given level.
/// \warning This function takes a `printf`-style format string, with extra parameters to match the format placeholders, and has the same security vulnerabilities as other `printf`-style functions.
///
/// If you are logging a fixed string, call \ref CBL_LogMessage instead, otherwise any `%`
/// characters in the `format` string will be misinterpreted as placeholders and the dreaded
/// Undefined Behavior will result, possibly including crashes or overwriting the stack.
/// @param domain  The log domain to associate this message with.
/// @param level  The severity of the message. If this is lower than the current minimum level for the domain
/// (as set by \ref CBLLog_SetConsoleLevel), nothing is logged.
/// @param format  A `printf`-style format string. `%` characters in this string introduce parameters,
/// and corresponding arguments must follow.
@ffi.Native<NativeCBL_Log>()
external void CBL_Log(
  int domain,
  int level,
  ffi.Pointer<ffi.Char> format,
);

/// Writes a pre-formatted message to the log, exactly as given.
/// @param domain  The log domain to associate this message with.
/// @param level  The severity of the message. If this is lower than the current minimum level for the domain
/// (as set by \ref CBLLog_SetConsoleLevel), nothing is logged.
/// @param message  The exact message to write to the log.
@ffi.Native<NativeCBL_LogMessage>()
external void CBL_LogMessage(
  int domain,
  int level,
  FLSlice message,
);

/// Gets the current log level for debug console logging.
/// Only messages at this level or higher will be logged to the console.
@ffi.Native<NativeCBLLog_ConsoleLevel>()
external int CBLLog_ConsoleLevel();

/// Sets the detail level of logging.
/// Only messages whose level is  the given level will be logged to the console.
@ffi.Native<NativeCBLLog_SetConsoleLevel>()
external void CBLLog_SetConsoleLevel(
  int arg0,
);

/// Gets the current log level for debug console logging.
/// Only messages at this level or higher will be logged to the callback.
@ffi.Native<NativeCBLLog_CallbackLevel>()
external int CBLLog_CallbackLevel();

/// Sets the detail level of logging.
/// Only messages whose level is  the given level will be logged to the callback.
@ffi.Native<NativeCBLLog_SetCallbackLevel>()
external void CBLLog_SetCallbackLevel(
  int arg0,
);

/// Gets the current log callback.
@ffi.Native<NativeCBLLog_Callback>()
external CBLLogCallback CBLLog_Callback();

/// Sets the callback for receiving log messages. If set to NULL, no messages are logged to the console.
@ffi.Native<NativeCBLLog_SetCallback>()
external void CBLLog_SetCallback(
  CBLLogCallback callback,
);

/// Gets the current file logging configuration, or NULL if none is configured.
@ffi.Native<NativeCBLLog_FileConfig>()
external ffi.Pointer<CBLLogFileConfiguration> CBLLog_FileConfig();

/// Sets the file logging configuration, and begins logging to files.
@ffi.Native<NativeCBLLog_SetFileConfig>()
external bool CBLLog_SetFileConfig(
  CBLLogFileConfiguration arg0,
  ffi.Pointer<CBLError> outError,
);

/// Creates a new query by compiling the input string.
/// This is fast, but not instantaneous. If you need to run the same query many times, keep the
/// \ref CBLQuery around instead of compiling it each time. If you need to run related queries
/// with only some values different, create one query with placeholder parameter(s), and substitute
/// the desired value(s) with \ref CBLQuery_SetParameters each time you run the query.
/// @note  You must release the \ref CBLQuery when you're finished with it.
/// @param db  The database to query.
/// @param language  The query language,
/// [JSON](https://github.com/couchbase/couchbase-lite-core/wiki/JSON-Query-Schema) or
/// [N1QL](https://docs.couchbase.com/server/4.0/n1ql/n1ql-language-reference/index.html).
/// @param queryString  The query string.
/// @param outErrorPos  If non-NULL, then on a parse error the approximate byte offset in the
/// input expression will be stored here (or -1 if not known/applicable.)
/// @param outError  On failure, the error will be written here.
/// @return  The new query object.
@ffi.Native<NativeCBLDatabase_CreateQuery>()
external ffi.Pointer<CBLQuery> CBLDatabase_CreateQuery(
  ffi.Pointer<CBLDatabase> db,
  int language,
  FLString queryString,
  ffi.Pointer<ffi.Int> outErrorPos,
  ffi.Pointer<CBLError> outError,
);

/// Assigns values to the query's parameters.
/// These values will be substited for those parameters whenever the query is executed,
/// until they are next assigned.
///
/// Parameters are specified in the query source as
/// e.g. `$PARAM` (N1QL) or `["$PARAM"]` (JSON). In this example, the `parameters` dictionary
/// to this call should have a key `PARAM` that maps to the value of the parameter.
/// @param query  The query.
/// @param parameters  The parameters in the form of a Fleece \ref FLDict "dictionary" whose
/// keys are the parameter names. (It's easiest to construct this by using the mutable
/// API, i.e. calling \ref FLMutableDict_New and adding keys/values.)
@ffi.Native<NativeCBLQuery_SetParameters>()
external void CBLQuery_SetParameters(
  ffi.Pointer<CBLQuery> query,
  FLDict parameters,
);

/// Returns the query's current parameter bindings, if any.
@ffi.Native<NativeCBLQuery_Parameters>()
external FLDict CBLQuery_Parameters(
  ffi.Pointer<CBLQuery> query,
);

/// Runs the query, returning the results.
/// To obtain the results you'll typically call \ref CBLResultSet_Next in a `while` loop,
/// examining the values in the \ref CBLResultSet each time around.
/// @note  You must release the result set when you're finished with it.
@ffi.Native<NativeCBLQuery_Execute>()
external ffi.Pointer<CBLResultSet> CBLQuery_Execute(
  ffi.Pointer<CBLQuery> arg0,
  ffi.Pointer<CBLError> outError,
);

/// Returns information about the query, including the translated SQLite form, and the search
/// strategy. You can use this to help optimize the query: the word `SCAN` in the strategy
/// indicates a linear scan of the entire database, which should be avoided by adding an index.
/// The strategy will also show which index(es), if any, are used.
/// @note  You are responsible for releasing the result by calling \ref FLSliceResult_Release.
@ffi.Native<NativeCBLQuery_Explain>()
external FLSliceResult CBLQuery_Explain(
  ffi.Pointer<CBLQuery> arg0,
);

/// Returns the number of columns in each result.
@ffi.Native<NativeCBLQuery_ColumnCount>()
external int CBLQuery_ColumnCount(
  ffi.Pointer<CBLQuery> arg0,
);

/// Returns the name of a column in the result.
/// The column name is based on its expression in the `SELECT...` or `WHAT:` section of the
/// query. A column that returns a property or property path will be named after that property.
/// A column that returns an expression will have an automatically-generated name like `$1`.
/// To give a column a custom name, use the `AS` syntax in the query.
/// Every column is guaranteed to have a unique name.
@ffi.Native<NativeCBLQuery_ColumnName>()
external FLSlice CBLQuery_ColumnName(
  ffi.Pointer<CBLQuery> arg0,
  int columnIndex,
);

/// Moves the result-set iterator to the next result.
/// Returns false if there are no more results.
/// @warning This must be called _before_ examining the first result.
@ffi.Native<NativeCBLResultSet_Next>()
external bool CBLResultSet_Next(
  ffi.Pointer<CBLResultSet> arg0,
);

/// Returns the value of a column of the current result, given its (zero-based) numeric index.
/// This may return a NULL pointer, indicating `MISSING`, if the value doesn't exist, e.g. if
/// the column is a property that doesn't exist in the document.
@ffi.Native<NativeCBLResultSet_ValueAtIndex>()
external FLValue CBLResultSet_ValueAtIndex(
  ffi.Pointer<CBLResultSet> arg0,
  int index,
);

/// Returns the value of a column of the current result, given its name.
/// This may return a NULL pointer, indicating `MISSING`, if the value doesn't exist, e.g. if
/// the column is a property that doesn't exist in the document. (Or, of course, if the key
/// is not a column name in this query.)
/// @note  See \ref CBLQuery_ColumnName for a discussion of column names.
@ffi.Native<NativeCBLResultSet_ValueForKey>()
external FLValue CBLResultSet_ValueForKey(
  ffi.Pointer<CBLResultSet> arg0,
  FLString key,
);

/// Returns the current result as an array of column values.
/// @warning The array reference is only valid until the result-set is advanced or released.
/// If you want to keep it for longer, call \ref FLArray_Retain (and release it when done.)
@ffi.Native<NativeCBLResultSet_ResultArray>()
external FLArray CBLResultSet_ResultArray(
  ffi.Pointer<CBLResultSet> arg0,
);

/// Returns the current result as a dictionary mapping column names to values.
/// @warning The dict reference is only valid until the result-set is advanced or released.
/// If you want to keep it for longer, call \ref FLDict_Retain (and release it when done.)
@ffi.Native<NativeCBLResultSet_ResultDict>()
external FLDict CBLResultSet_ResultDict(
  ffi.Pointer<CBLResultSet> arg0,
);

/// Returns the Query that created this ResultSet.
@ffi.Native<NativeCBLResultSet_GetQuery>()
external ffi.Pointer<CBLQuery> CBLResultSet_GetQuery(
  ffi.Pointer<CBLResultSet> rs,
);

/// Registers a change listener callback with a query, turning it into a "live query" until
/// the listener is removed (via \ref CBLListener_Remove).
///
/// When the first change listener is added, the query will run (in the background) and notify
/// the listener(s) of the results when ready. After that, it will run in the background after
/// the database changes, and only notify the listeners when the result set changes.
/// @param query  The query to observe.
/// @param listener  The callback to be invoked.
/// @param context  An opaque value that will be passed to the callback.
/// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the
/// listener.
@ffi.Native<NativeCBLQuery_AddChangeListener>()
external ffi.Pointer<CBLListenerToken> CBLQuery_AddChangeListener(
  ffi.Pointer<CBLQuery> query,
  CBLQueryChangeListener listener,
  ffi.Pointer<ffi.Void> context,
);

/// Returns the query's _entire_ current result set, after it's been announced via a call to the
/// listener's callback.
/// @note  You must release the result set when you're finished with it.
/// @param query  The query being listened to.
/// @param listener  The query listener that was notified.
/// @param outError  If the query failed to run, the error will be stored here.
/// @return  A new object containing the query's current results, or NULL if the query failed to run.
@ffi.Native<NativeCBLQuery_CopyCurrentResults>()
external ffi.Pointer<CBLResultSet> CBLQuery_CopyCurrentResults(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<CBLListenerToken> listener,
  ffi.Pointer<CBLError> outError,
);

/// Returns the index's name.
/// @param index  The index.
/// @return The name of the index.
@ffi.Native<NativeCBLQueryIndex_Name>()
external FLString CBLQueryIndex_Name(
  ffi.Pointer<CBLQueryIndex> index,
);

/// Returns the collection that the index belongs to.
/// @param index  The index.
/// @return A \ref CBLCollection instance that the index belongs to.
@ffi.Native<NativeCBLQueryIndex_Collection>()
external ffi.Pointer<CBLCollection> CBLQueryIndex_Collection(
  ffi.Pointer<CBLQueryIndex> index,
);

/// The default scope's name.
@ffi.Native<FLString>()
external final FLString kCBLDefaultScopeName;

/// Returns the name of the scope.
/// @param scope  The scope.
/// @return  The name of the scope.
@ffi.Native<NativeCBLScope_Name>()
external FLString CBLScope_Name(
  ffi.Pointer<CBLScope> scope,
);

/// Returns the scope's database.
/// @note The database object is owned by the scope object; you do not need to release it.
/// @param scope  The scope.
/// @return The database of the scope.
@ffi.Native<NativeCBLScope_Database>()
external ffi.Pointer<CBLDatabase> CBLScope_Database(
  ffi.Pointer<CBLScope> scope,
);

/// Returns the names of all collections in the scope.
/// @note  You are responsible for releasing the returned array.
/// @param scope  The scope.
/// @param outError  On failure, the error will be written here.
/// @return  The names of all collections in the scope, or NULL if an error occurred.
@ffi.Native<NativeCBLScope_CollectionNames>()
external FLMutableArray CBLScope_CollectionNames(
  ffi.Pointer<CBLScope> scope,
  ffi.Pointer<CBLError> outError,
);

/// Returns an existing collection in the scope with the given name.
/// @note  You are responsible for releasing the returned collection.
/// @param scope  The scope.
/// @param collectionName  The name of the collection.
/// @param outError  On failure, the error will be written here.
/// @return A \ref CBLCollection instance, or NULL if the collection doesn't exist or an error occurred.
@ffi.Native<NativeCBLScope_Collection>()
external ffi.Pointer<CBLCollection> CBLScope_Collection(
  ffi.Pointer<CBLScope> scope,
  FLString collectionName,
  ffi.Pointer<CBLError> outError,
);

/// Equality test of two slices.
@ffi.Native<NativeFLSlice_Equal>()
external bool FLSlice_Equal(
  FLSlice a,
  FLSlice b,
);

/// Lexicographic comparison of two slices; basically like memcmp(), but taking into account
/// differences in length.
@ffi.Native<NativeFLSlice_Compare>()
external int FLSlice_Compare(
  FLSlice arg0,
  FLSlice arg1,
);

/// Computes a 32-bit hash of a slice's data, suitable for use in hash tables.
@ffi.Native<NativeFLSlice_Hash>()
external int FLSlice_Hash(
  FLSlice s,
);

/// Copies a slice to a buffer, adding a trailing zero byte to make it a valid C string.
/// If there is not enough capacity the slice will be truncated, but the trailing zero byte is
/// always written.
/// @param s  The FLSlice to copy.
/// @param buffer  Where to copy the bytes. At least `capacity` bytes must be available.
/// @param capacity  The maximum number of bytes to copy (including the trailing 0.)
/// @return  True if the entire slice was copied, false if it was truncated.
@ffi.Native<NativeFLSlice_ToCString>()
external bool FLSlice_ToCString(
  FLSlice s,
  ffi.Pointer<ffi.Char> buffer,
  int capacity,
);

/// Allocates an FLSliceResult of the given size, without initializing the buffer.
@ffi.Native<NativeFLSliceResult_New>()
external FLSliceResult FLSliceResult_New(
  int arg0,
);

/// Allocates an FLSliceResult, copying the given slice.
@ffi.Native<NativeFLSlice_Copy>()
external FLSliceResult FLSlice_Copy(
  FLSlice arg0,
);

@ffi.Native<NativeFLBuf_Retain>(symbol: "_FLBuf_Retain")
external void FLBuf_Retain(
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<NativeFLBuf_Release>(symbol: "_FLBuf_Release")
external void FLBuf_Release(
  ffi.Pointer<ffi.Void> arg0,
);

/// Writes zeroes to `size` bytes of memory starting at `dst`.
/// Unlike a call to `memset`, these writes cannot be optimized away by the compiler.
/// This is useful for securely removing traces of passwords or encryption keys.
@ffi.Native<NativeFL_WipeMemory>()
external void FL_WipeMemory(
  ffi.Pointer<ffi.Void> dst,
  int size,
);

/// Returns an FLTimestamp corresponding to the current time.
@ffi.Native<NativeFLTimestamp_Now>()
external int FLTimestamp_Now();

/// Formats a timestamp as a date-time string in ISO-8601 format.
/// @note  See also \ref FLEncoder_WriteDateString, which writes a timestamp to an `FLEncoder`.
/// @param timestamp  A time, given as milliseconds since the Unix epoch (1/1/1970 00:00 UTC.)
/// @param asUTC  If true, the timestamp will be given in universal time; if false, in the
/// local timezone.
/// @return  A heap-allocated string, which you are responsible for releasing.
@ffi.Native<NativeFLTimestamp_ToString>()
external FLStringResult FLTimestamp_ToString(
  int timestamp,
  bool asUTC,
);

/// Parses an ISO-8601 date-time string to a timestamp. On failure returns `FLTimestampNone`.
/// @note  See also \ref FLValue_AsTimestamp, which takes an `FLValue` and interprets numeric
/// representations as well as strings.
@ffi.Native<NativeFLTimestamp_FromString>()
external int FLTimestamp_FromString(
  FLString str,
);

/// A constant empty array value.
@ffi.Native<FLArray>()
external FLArray kFLEmptyArray;

/// Returns the number of items in an array, or 0 if the pointer is NULL.
@ffi.Native<NativeFLArray_Count>()
external int FLArray_Count(
  FLArray arg0,
);

/// Returns true if an array is empty (or NULL). Depending on the array's representation,
/// this can be faster than `FLArray_Count(a) == 0`
@ffi.Native<NativeFLArray_IsEmpty>()
external bool FLArray_IsEmpty(
  FLArray arg0,
);

/// If the array is mutable, returns it cast to FLMutableArray, else NULL.
@ffi.Native<NativeFLArray_AsMutable>()
external FLMutableArray FLArray_AsMutable(
  FLArray arg0,
);

/// Returns an value at an array index, or NULL if the index is out of range.
@ffi.Native<NativeFLArray_Get>()
external FLValue FLArray_Get(
  FLArray arg0,
  int index,
);

/// Initializes a FLArrayIterator struct to iterate over an array.
/// Call FLArrayIteratorGetValue to get the first item, then as long as the item is not NULL,
/// call FLArrayIterator_Next to advance.
@ffi.Native<NativeFLArrayIterator_Begin>()
external void FLArrayIterator_Begin(
  FLArray arg0,
  ffi.Pointer<FLArrayIterator> arg1,
);

/// Returns the current value being iterated over, or NULL at the end.
@ffi.Native<NativeFLArrayIterator_GetValue>()
external FLValue FLArrayIterator_GetValue(
  ffi.Pointer<FLArrayIterator> arg0,
);

/// Returns a value in the array at the given offset from the current value.
@ffi.Native<NativeFLArrayIterator_GetValueAt>()
external FLValue FLArrayIterator_GetValueAt(
  ffi.Pointer<FLArrayIterator> arg0,
  int offset,
);

/// Returns the number of items remaining to be iterated, including the current one.
@ffi.Native<NativeFLArrayIterator_GetCount>()
external int FLArrayIterator_GetCount(
  ffi.Pointer<FLArrayIterator> arg0,
);

/// Advances the iterator to the next value.
/// @warning It is illegal to call this when the iterator is already at the end.
/// In particular, calling this when the array is empty is always illegal.
@ffi.Native<NativeFLArrayIterator_Next>()
external bool FLArrayIterator_Next(
  ffi.Pointer<FLArrayIterator> arg0,
);

/// A constant empty array value.
@ffi.Native<FLDict>()
external FLDict kFLEmptyDict;

/// Returns the number of items in a dictionary, or 0 if the pointer is NULL.
@ffi.Native<NativeFLDict_Count>()
external int FLDict_Count(
  FLDict arg0,
);

/// Returns true if a dictionary is empty (or NULL). Depending on the dictionary's
/// representation, this can be faster than `FLDict_Count(a) == 0`
@ffi.Native<NativeFLDict_IsEmpty>()
external bool FLDict_IsEmpty(
  FLDict arg0,
);

/// If the dictionary is mutable, returns it cast to FLMutableDict, else NULL.
@ffi.Native<NativeFLDict_AsMutable>()
external FLMutableDict FLDict_AsMutable(
  FLDict arg0,
);

/// Looks up a key in a dictionary, returning its value.
/// Returns NULL if the value is not found or if the dictionary is NULL.
@ffi.Native<NativeFLDict_Get>()
external FLValue FLDict_Get(
  FLDict arg0,
  FLSlice keyString,
);

/// Initializes a FLDictIterator struct to iterate over a dictionary.
/// Call FLDictIterator_GetKey and FLDictIterator_GetValue to get the first item,
/// then as long as the item is not NULL, call FLDictIterator_Next to advance.
@ffi.Native<NativeFLDictIterator_Begin>()
external void FLDictIterator_Begin(
  FLDict arg0,
  ffi.Pointer<FLDictIterator> arg1,
);

/// Returns the current key being iterated over.
/// This Value will be a string or an integer, or NULL when there are no more keys.
@ffi.Native<NativeFLDictIterator_GetKey>()
external FLValue FLDictIterator_GetKey(
  ffi.Pointer<FLDictIterator> arg0,
);

/// Returns the current key's string value, or NULL when there are no more keys.
@ffi.Native<NativeFLDictIterator_GetKeyString>()
external FLString FLDictIterator_GetKeyString(
  ffi.Pointer<FLDictIterator> arg0,
);

/// Returns the current value being iterated over.
/// Returns NULL when there are no more values.
@ffi.Native<NativeFLDictIterator_GetValue>()
external FLValue FLDictIterator_GetValue(
  ffi.Pointer<FLDictIterator> arg0,
);

/// Returns the number of items remaining to be iterated, including the current one.
@ffi.Native<NativeFLDictIterator_GetCount>()
external int FLDictIterator_GetCount(
  ffi.Pointer<FLDictIterator> arg0,
);

/// Advances the iterator to the next value.
/// @warning It is illegal to call this when the iterator is already at the end.
/// In particular, calling this when the dict is empty is always illegal.
@ffi.Native<NativeFLDictIterator_Next>()
external bool FLDictIterator_Next(
  ffi.Pointer<FLDictIterator> arg0,
);

/// Cleans up after an iterator. Only needed if (a) the dictionary is a delta, and
/// (b) you stop iterating before the end (i.e. before FLDictIterator_Next returns false.)
@ffi.Native<NativeFLDictIterator_End>()
external void FLDictIterator_End(
  ffi.Pointer<FLDictIterator> arg0,
);

/// Initializes an FLDictKey struct with a key string.
/// @warning  The input string's memory MUST remain valid for as long as the FLDictKey is in
/// use! (The FLDictKey stores a pointer to the string, but does not copy it.)
/// @param string  The key string (UTF-8).
/// @return  An initialized FLDictKey struct.
@ffi.Native<NativeFLDictKey_Init>()
external FLDictKey FLDictKey_Init(
  FLSlice string,
);

/// Returns the string value of the key (which it was initialized with.)
@ffi.Native<NativeFLDictKey_GetString>()
external FLString FLDictKey_GetString(
  ffi.Pointer<FLDictKey> arg0,
);

/// Looks up a key in a dictionary using an FLDictKey. If the key is found, "hint" data will
/// be stored inside the FLDictKey that will speed up subsequent lookups.
@ffi.Native<NativeFLDict_GetWithKey>()
external FLValue FLDict_GetWithKey(
  FLDict arg0,
  ffi.Pointer<FLDictKey> arg1,
);

/// Creates a FLDeepIterator to iterate over a dictionary.
/// Call FLDeepIterator_GetKey and FLDeepIterator_GetValue to get the first item,
/// then FLDeepIterator_Next.
@ffi.Native<NativeFLDeepIterator_New>()
external FLDeepIterator FLDeepIterator_New(
  FLValue arg0,
);

@ffi.Native<NativeFLDeepIterator_Free>()
external void FLDeepIterator_Free(
  FLDeepIterator arg0,
);

/// Returns the current value being iterated over. or NULL at the end of iteration.
@ffi.Native<NativeFLDeepIterator_GetValue>()
external FLValue FLDeepIterator_GetValue(
  FLDeepIterator arg0,
);

/// Returns the parent/container of the current value, or NULL at the end of iteration.
@ffi.Native<NativeFLDeepIterator_GetParent>()
external FLValue FLDeepIterator_GetParent(
  FLDeepIterator arg0,
);

/// Returns the key of the current value in its parent, or an empty slice if not in a dictionary.
@ffi.Native<NativeFLDeepIterator_GetKey>()
external FLSlice FLDeepIterator_GetKey(
  FLDeepIterator arg0,
);

/// Returns the array index of the current value in its parent, or 0 if not in an array.
@ffi.Native<NativeFLDeepIterator_GetIndex>()
external int FLDeepIterator_GetIndex(
  FLDeepIterator arg0,
);

/// Returns the current depth in the hierarchy, starting at 1 for the top-level children.
@ffi.Native<NativeFLDeepIterator_GetDepth>()
external int FLDeepIterator_GetDepth(
  FLDeepIterator arg0,
);

/// Tells the iterator to skip the children of the current value.
@ffi.Native<NativeFLDeepIterator_SkipChildren>()
external void FLDeepIterator_SkipChildren(
  FLDeepIterator arg0,
);

/// Advances the iterator to the next value, or returns false if at the end.
@ffi.Native<NativeFLDeepIterator_Next>()
external bool FLDeepIterator_Next(
  FLDeepIterator arg0,
);

/// Returns the path as an array of FLPathComponents.
@ffi.Native<NativeFLDeepIterator_GetPath>()
external void FLDeepIterator_GetPath(
  FLDeepIterator arg0,
  ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
  ffi.Pointer<ffi.Size> outDepth,
);

/// Returns the current path in JavaScript format.
@ffi.Native<NativeFLDeepIterator_GetPathString>()
external FLSliceResult FLDeepIterator_GetPathString(
  FLDeepIterator arg0,
);

/// Returns the current path in JSONPointer format (RFC 6901).
@ffi.Native<NativeFLDeepIterator_GetJSONPointer>()
external FLSliceResult FLDeepIterator_GetJSONPointer(
  FLDeepIterator arg0,
);

/// Creates an FLDoc from Fleece-encoded data that's been returned as a result from
/// FLSlice_Copy or other API. The resulting document retains the data, so you don't need to
/// worry about it remaining valid.
@ffi.Native<NativeFLDoc_FromResultData>()
external FLDoc FLDoc_FromResultData(
  FLSliceResult data,
  int arg1,
  FLSharedKeys arg2,
  FLSlice externData,
);

/// Releases a reference to an FLDoc. This must be called once to free an FLDoc you created.
@ffi.Native<NativeFLDoc_Release>()
external void FLDoc_Release(
  FLDoc arg0,
);

/// Adds a reference to an FLDoc. This extends its lifespan until at least such time as you
/// call FLRelease to remove the reference.
@ffi.Native<NativeFLDoc_Retain>()
external FLDoc FLDoc_Retain(
  FLDoc arg0,
);

/// Returns the encoded Fleece data backing the document.
@ffi.Native<NativeFLDoc_GetData>()
external FLSlice FLDoc_GetData(
  FLDoc arg0,
);

/// Returns the FLSliceResult data owned by the document, if any, else a null slice.
@ffi.Native<NativeFLDoc_GetAllocedData>()
external FLSliceResult FLDoc_GetAllocedData(
  FLDoc arg0,
);

/// Returns the root value in the FLDoc, usually an FLDict.
@ffi.Native<NativeFLDoc_GetRoot>()
external FLValue FLDoc_GetRoot(
  FLDoc arg0,
);

/// Returns the FLSharedKeys used by this FLDoc, as specified when it was created.
@ffi.Native<NativeFLDoc_GetSharedKeys>()
external FLSharedKeys FLDoc_GetSharedKeys(
  FLDoc arg0,
);

/// Looks up the Doc containing the Value, or NULL if there is none.
/// @note Caller must release the FLDoc reference!!
@ffi.Native<NativeFLValue_FindDoc>()
external FLDoc FLValue_FindDoc(
  FLValue arg0,
);

/// Associates an arbitrary pointer value with a document, and thus its contained values.
/// Allows client code to associate its own pointer with this FLDoc and its Values,
/// which can later be retrieved with \ref FLDoc_GetAssociated.
/// For example, this could be a pointer to an `app::Document` object, of which this Doc's
/// root FLDict is its properties. You would store it by calling
/// `FLDoc_SetAssociated(doc, myDoc, "app::Document");`.
/// @param doc  The FLDoc to store a pointer in.
/// @param pointer  The pointer to store in the FLDoc.
/// @param type  A C string literal identifying the type. This is used to avoid collisions
/// with unrelated code that might try to store a different type of value.
/// @return  True if the pointer was stored, false if a pointer of a different type is
/// already stored.
/// @warning  Be sure to clear this before the associated object is freed/invalidated!
/// @warning  This function is not thread-safe. Do not concurrently get & set objects.
@ffi.Native<NativeFLDoc_SetAssociated>()
external bool FLDoc_SetAssociated(
  FLDoc doc,
  ffi.Pointer<ffi.Void> pointer,
  ffi.Pointer<ffi.Char> type,
);

/// Returns the pointer associated with the document. You can use this together with
/// \ref FLValue_FindDoc to associate your own object with Fleece values, for instance to find
/// your object that "owns" a value:
/// `myDoc = (app::Document*)FLDoc_GetAssociated(FLValue_FindDoc(val), "app::Document");`.
/// @param doc  The FLDoc to get a pointer from.
/// @param type  The type of object expected, i.e. the same string literal passed to
/// \ref FLDoc_SetAssociated.
/// @return  The associated pointer of that type, if any.
@ffi.Native<NativeFLDoc_GetAssociated>()
external ffi.Pointer<ffi.Void> FLDoc_GetAssociated(
  FLDoc doc,
  ffi.Pointer<ffi.Char> type,
);

/// Creates a new encoder, for generating Fleece data. Call FLEncoder_Free when done.
@ffi.Native<NativeFLEncoder_New>()
external FLEncoder FLEncoder_New();

/// Creates a new encoder, allowing some options to be customized.
/// @param format  The output format to generate (Fleece, JSON, or JSON5.)
/// @param reserveSize  The number of bytes to preallocate for the output. (Default is 256)
/// @param uniqueStrings  (Fleece only) If true, string values that appear multiple times will be written
/// as a single shared value. This saves space but makes encoding slightly slower.
/// You should only turn this off if you know you're going to be writing large numbers
/// of non-repeated strings. (Default is true)
@ffi.Native<NativeFLEncoder_NewWithOptions>()
external FLEncoder FLEncoder_NewWithOptions(
  int format,
  int reserveSize,
  bool uniqueStrings,
);

/// Creates a new Fleece encoder that writes to a file, not to memory.
@ffi.Native<NativeFLEncoder_NewWritingToFile>()
external FLEncoder FLEncoder_NewWritingToFile(
  ffi.Pointer<FILE> arg0,
  bool uniqueStrings,
);

/// Frees the space used by an encoder.
@ffi.Native<NativeFLEncoder_Free>()
external void FLEncoder_Free(
  FLEncoder arg0,
);

/// Tells the encoder to use a shared-keys mapping when encoding dictionary keys.
@ffi.Native<NativeFLEncoder_SetSharedKeys>()
external void FLEncoder_SetSharedKeys(
  FLEncoder arg0,
  FLSharedKeys arg1,
);

/// Associates an arbitrary user-defined value with the encoder.
@ffi.Native<NativeFLEncoder_SetExtraInfo>()
external void FLEncoder_SetExtraInfo(
  FLEncoder arg0,
  ffi.Pointer<ffi.Void> info,
);

/// Returns the user-defined value associated with the encoder; NULL by default.
@ffi.Native<NativeFLEncoder_GetExtraInfo>()
external ffi.Pointer<ffi.Void> FLEncoder_GetExtraInfo(
  FLEncoder arg0,
);

/// Resets the state of an encoder without freeing it. It can then be reused to encode
/// another value.
@ffi.Native<NativeFLEncoder_Reset>()
external void FLEncoder_Reset(
  FLEncoder arg0,
);

/// Returns the number of bytes encoded so far.
@ffi.Native<NativeFLEncoder_BytesWritten>()
external int FLEncoder_BytesWritten(
  FLEncoder arg0,
);

/// Writes a `null` value to an encoder. (This is an explicitly-stored null, like the JSON
/// `null`, not the "undefined" value represented by a NULL FLValue pointer.)
@ffi.Native<NativeFLEncoder_WriteNull>()
external bool FLEncoder_WriteNull(
  FLEncoder arg0,
);

/// Writes an `undefined` value to an encoder. (Its value when read will not be a `NULL`
/// pointer, but it can be recognized by `FLValue_GetType` returning `kFLUndefined`.)
/// @note The only real use for writing undefined values is to represent "holes" in an array.
/// An undefined dictionary value should be written simply by skipping the key and value.
@ffi.Native<NativeFLEncoder_WriteUndefined>()
external bool FLEncoder_WriteUndefined(
  FLEncoder arg0,
);

/// Writes a boolean value (true or false) to an encoder.
@ffi.Native<NativeFLEncoder_WriteBool>()
external bool FLEncoder_WriteBool(
  FLEncoder arg0,
  bool arg1,
);

/// Writes an integer to an encoder. The parameter is typed as `int64_t` but you can pass any
/// integral type (signed or unsigned) except for huge `uint64_t`s.
/// The number will be written in a compact form that uses only as many bytes as necessary.
@ffi.Native<NativeFLEncoder_WriteInt>()
external bool FLEncoder_WriteInt(
  FLEncoder arg0,
  int arg1,
);

/// Writes an unsigned integer to an encoder.
/// @note This function is only really necessary for huge
/// 64-bit integers greater than or equal to 2^63, which can't be represented as int64_t.
@ffi.Native<NativeFLEncoder_WriteUInt>()
external bool FLEncoder_WriteUInt(
  FLEncoder arg0,
  int arg1,
);

/// Writes a 32-bit floating point number to an encoder.
/// @note As an implementation detail, if the number has no fractional part and can be
/// represented exactly as an integer, it'll be encoded as an integer to save space. This is
/// transparent to the reader, since if it requests the value as a float it'll be returned
/// as floating-point.
@ffi.Native<NativeFLEncoder_WriteFloat>()
external bool FLEncoder_WriteFloat(
  FLEncoder arg0,
  double arg1,
);

/// Writes a 64-bit floating point number to an encoder.
/// @note As an implementation detail, the number may be encoded as a 32-bit float or even
/// as an integer, if this can be done without losing precision. For example, 123.0 will be
/// written as an integer, and 123.75 as a float.)
@ffi.Native<NativeFLEncoder_WriteDouble>()
external bool FLEncoder_WriteDouble(
  FLEncoder arg0,
  double arg1,
);

/// Writes a string to an encoder. The string must be UTF-8-encoded and must not contain any
/// zero bytes.
/// @warning Do _not_ use this to write a dictionary key; use FLEncoder_WriteKey instead.
@ffi.Native<NativeFLEncoder_WriteString>()
external bool FLEncoder_WriteString(
  FLEncoder arg0,
  FLString arg1,
);

/// Writes a timestamp to an encoder, as an ISO-8601 date string.
/// @note Since neither Fleece nor JSON have a 'Date' type, the encoded string has no
/// metadata that distinguishes it as a date. It's just a string.)
/// @param encoder  The encoder to write to.
/// @param ts  The timestamp (milliseconds since Unix epoch 1-1-1970).
/// @param asUTC  If true, date is written in UTC (GMT); if false, with the local timezone.
/// @return  True on success, false on error.
@ffi.Native<NativeFLEncoder_WriteDateString>()
external bool FLEncoder_WriteDateString(
  FLEncoder encoder,
  int ts,
  bool asUTC,
);

/// Writes a binary data value (a blob) to an encoder. This can contain absolutely anything
/// including null bytes.
/// If the encoder is generating JSON, the blob will be written as a base64-encoded string.
@ffi.Native<NativeFLEncoder_WriteData>()
external bool FLEncoder_WriteData(
  FLEncoder arg0,
  FLSlice arg1,
);

/// Writes a Fleece Value to an Encoder.
@ffi.Native<NativeFLEncoder_WriteValue>()
external bool FLEncoder_WriteValue(
  FLEncoder arg0,
  FLValue arg1,
);

/// Begins writing an array value to an encoder. This pushes a new state where each
/// subsequent value written becomes an array item, until FLEncoder_EndArray is called.
/// @param reserveCount  Number of array elements to reserve space for. If you know the size
/// of the array, providing it here speeds up encoding slightly. If you don't know,
/// just use zero.
@ffi.Native<NativeFLEncoder_BeginArray>()
external bool FLEncoder_BeginArray(
  FLEncoder arg0,
  int reserveCount,
);

/// Ends writing an array value; pops back the previous encoding state.
@ffi.Native<NativeFLEncoder_EndArray>()
external bool FLEncoder_EndArray(
  FLEncoder arg0,
);

/// Begins writing a dictionary value to an encoder. This pushes a new state where each
/// subsequent key and value written are added to the dictionary, until FLEncoder_EndDict is
/// called.
/// Before adding each value, you must call FLEncoder_WriteKey (_not_ FLEncoder_WriteString!),
/// to write the dictionary key.
/// @param reserveCount  Number of dictionary items to reserve space for. If you know the size
/// of the dictionary, providing it here speeds up encoding slightly. If you don't know,
/// just use zero.
@ffi.Native<NativeFLEncoder_BeginDict>()
external bool FLEncoder_BeginDict(
  FLEncoder arg0,
  int reserveCount,
);

/// Specifies the key for the next value to be written to the current dictionary.
@ffi.Native<NativeFLEncoder_WriteKey>()
external bool FLEncoder_WriteKey(
  FLEncoder arg0,
  FLString arg1,
);

/// Specifies the key for the next value to be written to the current dictionary.
/// The key is given as a Value, which must be a string or integer.
@ffi.Native<NativeFLEncoder_WriteKeyValue>()
external bool FLEncoder_WriteKeyValue(
  FLEncoder arg0,
  FLValue arg1,
);

/// Ends writing a dictionary value; pops back the previous encoding state.
@ffi.Native<NativeFLEncoder_EndDict>()
external bool FLEncoder_EndDict(
  FLEncoder arg0,
);

/// Writes raw data directly to the encoded output.
/// (This is not the same as \ref FLEncoder_WriteData, which safely encodes a blob.)
/// @warning **Do not call this** unless you really know what you're doing ...
/// it's quite unsafe, and only used for certain advanced purposes.
@ffi.Native<NativeFLEncoder_WriteRaw>()
external bool FLEncoder_WriteRaw(
  FLEncoder arg0,
  FLSlice arg1,
);

/// Ends encoding; if there has been no error, it returns the encoded Fleece data packaged in
/// an FLDoc. (This function does not support JSON encoding.)
/// This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next.
@ffi.Native<NativeFLEncoder_FinishDoc>()
external FLDoc FLEncoder_FinishDoc(
  FLEncoder arg0,
  ffi.Pointer<ffi.Int32> outError,
);

/// Ends encoding; if there has been no error, it returns the encoded data, else null.
/// This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next.
@ffi.Native<NativeFLEncoder_Finish>()
external FLSliceResult FLEncoder_Finish(
  FLEncoder arg0,
  ffi.Pointer<ffi.Int32> outError,
);

/// Returns the error code of an encoder, or NoError (0) if there's no error.
@ffi.Native<NativeFLEncoder_GetError>()
external int FLEncoder_GetError(
  FLEncoder arg0,
);

/// Returns the error message of an encoder, or NULL if there's no error.
@ffi.Native<NativeFLEncoder_GetErrorMessage>()
external ffi.Pointer<ffi.Char> FLEncoder_GetErrorMessage(
  FLEncoder arg0,
);

/// Encodes a Fleece value as JSON (or a JSON fragment.)
/// @note Any Data values will be encoded as base64-encoded strings.
@ffi.Native<NativeFLValue_ToJSON>()
external FLStringResult FLValue_ToJSON(
  FLValue arg0,
);

/// Encodes a Fleece value as JSON5, a more lenient variant of JSON that allows dictionary
/// keys to be unquoted if they're alphanumeric. This tends to be more readable.
/// @note Any Data values will be encoded as base64-encoded strings.
@ffi.Native<NativeFLValue_ToJSON5>()
external FLStringResult FLValue_ToJSON5(
  FLValue arg0,
);

/// Most general Fleece to JSON converter.
/// @param v  The Fleece value to encode
/// @param json5  If true, outputs JSON5, like \ref FLValue_ToJSON5
/// @param canonicalForm  If true, outputs the JSON in a consistent "canonical" form. All
/// equivalent values should produce byte-for-byte identical canonical JSON.
/// This is useful for creating digital signatures, for example.
@ffi.Native<NativeFLValue_ToJSONX>()
external FLStringResult FLValue_ToJSONX(
  FLValue v,
  bool json5,
  bool canonicalForm,
);

/// Creates an FLDoc from JSON-encoded data. The data is first encoded into Fleece, and the
/// Fleece data is kept by the doc; the input JSON data is no longer needed after this
/// function returns.
@ffi.Native<NativeFLDoc_FromJSON>()
external FLDoc FLDoc_FromJSON(
  FLSlice json,
  ffi.Pointer<ffi.Int32> outError,
);

/// Creates a new mutable Array from JSON. It is an error if the JSON is not an array.
/// Its initial ref-count is 1, so a call to FLMutableArray_Release will free it.
@ffi.Native<NativeFLMutableArray_NewFromJSON>()
external FLMutableArray FLMutableArray_NewFromJSON(
  FLString json,
  ffi.Pointer<ffi.Int32> outError,
);

/// Creates a new mutable Dict from json. It is an error if the JSON is not a dictionary/object.
/// Its initial ref-count is 1, so a call to FLMutableDict_Release will free it.
@ffi.Native<NativeFLMutableDict_NewFromJSON>()
external FLMutableDict FLMutableDict_NewFromJSON(
  FLString json,
  ffi.Pointer<ffi.Int32> outError,
);

/// Parses JSON data and writes the value(s) to the encoder as their Fleece equivalents.
/// (This acts as a single write, like WriteInt; it's just that the value written is likely to
/// be an entire dictionary or array.)
@ffi.Native<NativeFLEncoder_ConvertJSON>()
external bool FLEncoder_ConvertJSON(
  FLEncoder arg0,
  FLSlice json,
);

/// Creates a new FLKeyPath object by compiling a path specifier string.
@ffi.Native<NativeFLKeyPath_New>()
external FLKeyPath FLKeyPath_New(
  FLSlice specifier,
  ffi.Pointer<ffi.Int32> outError,
);

/// Frees a compiled FLKeyPath object. (It's ok to pass NULL.)
@ffi.Native<NativeFLKeyPath_Free>()
external void FLKeyPath_Free(
  FLKeyPath arg0,
);

/// Evaluates a compiled key-path for a given Fleece root object.
@ffi.Native<NativeFLKeyPath_Eval>()
external FLValue FLKeyPath_Eval(
  FLKeyPath arg0,
  FLValue root,
);

/// Evaluates a key-path from a specifier string, for a given Fleece root object.
/// If you only need to evaluate the path once, this is a bit faster than creating an
/// FLKeyPath object, evaluating, then freeing it.
@ffi.Native<NativeFLKeyPath_EvalOnce>()
external FLValue FLKeyPath_EvalOnce(
  FLSlice specifier,
  FLValue root,
  ffi.Pointer<ffi.Int32> outError,
);

/// Returns a path in string form.
@ffi.Native<NativeFLKeyPath_ToString>()
external FLStringResult FLKeyPath_ToString(
  FLKeyPath path,
);

/// Equality test.
@ffi.Native<NativeFLKeyPath_Equals>()
external bool FLKeyPath_Equals(
  FLKeyPath path1,
  FLKeyPath path2,
);

/// Returns an element of a path, either a key or an array index.
@ffi.Native<NativeFLKeyPath_GetElement>()
external bool FLKeyPath_GetElement(
  FLKeyPath arg0,
  int i,
  ffi.Pointer<FLSlice> outDictKey,
  ffi.Pointer<ffi.Int32> outArrayIndex,
);

/// A constant null value (like a JSON `null`, not a NULL pointer!)
@ffi.Native<FLValue>()
external FLValue kFLNullValue;

/// A constant undefined value. This is not a NULL pointer, but its type is \ref kFLUndefined.
/// It can be stored in an \ref FLMutableArray or \ref FLMutableDict if you really, really
/// need to store an undefined/empty value, not just a JSON `null`.
@ffi.Native<FLValue>()
external FLValue kFLUndefinedValue;

/// Returns the data type of an arbitrary value.
/// If the parameter is a NULL pointer, returns `kFLUndefined`.
@ffi.Native<NativeFLValue_GetType>()
external int FLValue_GetType(
  FLValue arg0,
);

/// Returns true if the value is non-NULL and represents an integer.
@ffi.Native<NativeFLValue_IsInteger>()
external bool FLValue_IsInteger(
  FLValue arg0,
);

/// Returns true if the value is non-NULL and represents an integer >= 2^63. Such a value can't
/// be represented in C as an `int64_t`, only a `uint64_t`, so you should access it by calling
/// `FLValueAsUnsigned`, _not_ FLValueAsInt, which would return  an incorrect (negative)
/// value.
@ffi.Native<NativeFLValue_IsUnsigned>()
external bool FLValue_IsUnsigned(
  FLValue arg0,
);

/// Returns true if the value is non-NULL and represents a 64-bit floating-point number.
@ffi.Native<NativeFLValue_IsDouble>()
external bool FLValue_IsDouble(
  FLValue arg0,
);

/// Returns a value coerced to boolean. This will be true unless the value is NULL (undefined),
/// null, false, or zero.
@ffi.Native<NativeFLValue_AsBool>()
external bool FLValue_AsBool(
  FLValue arg0,
);

/// Returns a value coerced to an integer. True and false are returned as 1 and 0, and
/// floating-point numbers are rounded. All other types are returned as 0.
/// @warning  Large 64-bit unsigned integers (2^63 and above) will come out wrong. You can
/// check for these by calling `FLValueIsUnsigned`.
@ffi.Native<NativeFLValue_AsInt>()
external int FLValue_AsInt(
  FLValue arg0,
);

/// Returns a value coerced to an unsigned integer.
/// This is the same as `FLValueAsInt` except that it _can't_ handle negative numbers, but
/// does correctly return large `uint64_t` values of 2^63 and up.
@ffi.Native<NativeFLValue_AsUnsigned>()
external int FLValue_AsUnsigned(
  FLValue arg0,
);

/// Returns a value coerced to a 32-bit floating point number.
/// True and false are returned as 1.0 and 0.0, and integers are converted to float. All other
/// types are returned as 0.0.
/// @warning  Large integers (outside approximately +/- 2^23) will lose precision due to the
/// limitations of IEEE 32-bit float format.
@ffi.Native<NativeFLValue_AsFloat>()
external double FLValue_AsFloat(
  FLValue arg0,
);

/// Returns a value coerced to a 32-bit floating point number.
/// True and false are returned as 1.0 and 0.0, and integers are converted to float. All other
/// types are returned as 0.0.
/// @warning  Very large integers (outside approximately +/- 2^50) will lose precision due to
/// the limitations of IEEE 32-bit float format.
@ffi.Native<NativeFLValue_AsDouble>()
external double FLValue_AsDouble(
  FLValue arg0,
);

/// Returns the exact contents of a string value, or null for all other types.
@ffi.Native<NativeFLValue_AsString>()
external FLString FLValue_AsString(
  FLValue arg0,
);

/// Converts a value to a timestamp, in milliseconds since Unix epoch, or INT64_MIN on failure.
/// - A string is parsed as ISO-8601 (standard JSON date format).
/// - A number is interpreted as a timestamp and returned as-is.
@ffi.Native<NativeFLValue_AsTimestamp>()
external int FLValue_AsTimestamp(
  FLValue arg0,
);

/// Returns the exact contents of a data value, or null for all other types.
@ffi.Native<NativeFLValue_AsData>()
external FLSlice FLValue_AsData(
  FLValue arg0,
);

/// If a FLValue represents an array, returns it cast to FLArray, else NULL.
@ffi.Native<NativeFLValue_AsArray>()
external FLArray FLValue_AsArray(
  FLValue arg0,
);

/// If a FLValue represents a dictionary, returns it as an FLDict, else NULL.
@ffi.Native<NativeFLValue_AsDict>()
external FLDict FLValue_AsDict(
  FLValue arg0,
);

/// Returns a string representation of any scalar value. Data values are returned in raw form.
/// Arrays and dictionaries don't have a representation and will return NULL.
@ffi.Native<NativeFLValue_ToString>()
external FLStringResult FLValue_ToString(
  FLValue arg0,
);

/// Compares two values for equality. This is a deep recursive comparison.
@ffi.Native<NativeFLValue_IsEqual>()
external bool FLValue_IsEqual(
  FLValue v1,
  FLValue v2,
);

/// Returns true if the value is mutable.
@ffi.Native<NativeFLValue_IsMutable>()
external bool FLValue_IsMutable(
  FLValue arg0,
);

/// Increments the ref-count of a mutable value, or of an immutable value's \ref FLDoc.
/// @warning It is illegal to call this on a value obtained from \ref FLValue_FromData.
@ffi.Native<NativeFLValue_Retain>()
external FLValue FLValue_Retain(
  FLValue arg0,
);

/// Decrements the ref-count of a mutable value, or of an immutable value's \ref FLDoc.
/// If the ref-count reaches zero the corresponding object is freed.
/// @warning It is illegal to call this on a value obtained from \ref FLValue_FromData.
@ffi.Native<NativeFLValue_Release>()
external void FLValue_Release(
  FLValue arg0,
);

/// Creates a new mutable Array that's a copy of the source Array.
/// Its initial ref-count is 1, so a call to \ref FLMutableArray_Release will free it.
///
/// Copying an immutable Array is very cheap (only one small allocation) unless the flag
/// \ref kFLCopyImmutables is set.
///
/// Copying a mutable Array is cheap if it's a shallow copy; but if \ref kFLDeepCopy is set,
/// nested mutable Arrays and Dicts are also copied, recursively; if \ref kFLCopyImmutables is
/// also set, immutable values are also copied, recursively.
///
/// If the source Array is NULL, then NULL is returned.
@ffi.Native<NativeFLArray_MutableCopy>()
external FLMutableArray FLArray_MutableCopy(
  FLArray arg0,
  int arg1,
);

/// Creates a new empty mutable Array.
/// Its initial ref-count is 1, so a call to FLMutableArray_Release will free it.
@ffi.Native<NativeFLMutableArray_New>()
external FLMutableArray FLMutableArray_New();

/// If the Array was created by FLArray_MutableCopy, returns the original source Array.
@ffi.Native<NativeFLMutableArray_GetSource>()
external FLArray FLMutableArray_GetSource(
  FLMutableArray arg0,
);

/// Returns true if the Array has been changed from the source it was copied from.
@ffi.Native<NativeFLMutableArray_IsChanged>()
external bool FLMutableArray_IsChanged(
  FLMutableArray arg0,
);

/// Sets or clears the mutable Array's "changed" flag.
@ffi.Native<NativeFLMutableArray_SetChanged>()
external void FLMutableArray_SetChanged(
  FLMutableArray arg0,
  bool changed,
);

/// Inserts a contiguous range of JSON `null` values into the array.
/// @param array  The array to operate on.
/// @param firstIndex  The zero-based index of the first value to be inserted.
/// @param count  The number of items to insert.
@ffi.Native<NativeFLMutableArray_Insert>()
external void FLMutableArray_Insert(
  FLMutableArray array,
  int firstIndex,
  int count,
);

/// Removes contiguous items from the array.
/// @param array  The array to operate on.
/// @param firstIndex  The zero-based index of the first item to remove.
/// @param count  The number of items to remove.
@ffi.Native<NativeFLMutableArray_Remove>()
external void FLMutableArray_Remove(
  FLMutableArray array,
  int firstIndex,
  int count,
);

/// Changes the size of an array.
/// If the new size is larger, the array is padded with JSON `null` values.
/// If it's smaller, values are removed from the end.
@ffi.Native<NativeFLMutableArray_Resize>()
external void FLMutableArray_Resize(
  FLMutableArray array,
  int size,
);

/// Convenience function for getting an array-valued property in mutable form.
/// - If the value for the key is not an array, returns NULL.
/// - If the value is a mutable array, returns it.
/// - If the value is an immutable array, this function makes a mutable copy, assigns the
/// copy as the property value, and returns the copy.
@ffi.Native<NativeFLMutableArray_GetMutableArray>()
external FLMutableArray FLMutableArray_GetMutableArray(
  FLMutableArray arg0,
  int index,
);

/// Convenience function for getting an array-valued property in mutable form.
/// - If the value for the key is not an array, returns NULL.
/// - If the value is a mutable array, returns it.
/// - If the value is an immutable array, this function makes a mutable copy, assigns the
/// copy as the property value, and returns the copy.
@ffi.Native<NativeFLMutableArray_GetMutableDict>()
external FLMutableDict FLMutableArray_GetMutableDict(
  FLMutableArray arg0,
  int index,
);

/// Creates a new mutable Dict that's a copy of the source Dict.
/// Its initial ref-count is 1, so a call to FLMutableDict_Release will free it.
///
/// Copying an immutable Dict is very cheap (only one small allocation.) The `deepCopy` flag
/// is ignored.
///
/// Copying a mutable Dict is cheap if it's a shallow copy, but if `deepCopy` is true,
/// nested mutable Dicts and Arrays are also copied, recursively.
///
/// If the source dict is NULL, then NULL is returned.
@ffi.Native<NativeFLDict_MutableCopy>()
external FLMutableDict FLDict_MutableCopy(
  FLDict source,
  int arg1,
);

/// Creates a new empty mutable Dict.
/// Its initial ref-count is 1, so a call to FLMutableDict_Release will free it.
@ffi.Native<NativeFLMutableDict_New>()
external FLMutableDict FLMutableDict_New();

/// If the Dict was created by FLDict_MutableCopy, returns the original source Dict.
@ffi.Native<NativeFLMutableDict_GetSource>()
external FLDict FLMutableDict_GetSource(
  FLMutableDict arg0,
);

/// Returns true if the Dict has been changed from the source it was copied from.
@ffi.Native<NativeFLMutableDict_IsChanged>()
external bool FLMutableDict_IsChanged(
  FLMutableDict arg0,
);

/// Sets or clears the mutable Dict's "changed" flag.
@ffi.Native<NativeFLMutableDict_SetChanged>()
external void FLMutableDict_SetChanged(
  FLMutableDict arg0,
  bool arg1,
);

/// Removes the value for a key.
@ffi.Native<NativeFLMutableDict_Remove>()
external void FLMutableDict_Remove(
  FLMutableDict arg0,
  FLString key,
);

/// Removes all keys and values.
@ffi.Native<NativeFLMutableDict_RemoveAll>()
external void FLMutableDict_RemoveAll(
  FLMutableDict arg0,
);

/// Convenience function for getting an array-valued property in mutable form.
/// - If the value for the key is not an array, returns NULL.
/// - If the value is a mutable array, returns it.
/// - If the value is an immutable array, this function makes a mutable copy, assigns the
/// copy as the property value, and returns the copy.
@ffi.Native<NativeFLMutableDict_GetMutableArray>()
external FLMutableArray FLMutableDict_GetMutableArray(
  FLMutableDict arg0,
  FLString key,
);

/// Convenience function for getting a dict-valued property in mutable form.
/// - If the value for the key is not a dict, returns NULL.
/// - If the value is a mutable dict, returns it.
/// - If the value is an immutable dict, this function makes a mutable copy, assigns the
/// copy as the property value, and returns the copy.
@ffi.Native<NativeFLMutableDict_GetMutableDict>()
external FLMutableDict FLMutableDict_GetMutableDict(
  FLMutableDict arg0,
  FLString key,
);

/// Allocates a string value on the heap. This is rarely needed -- usually you'd just add a string
/// to a mutable Array or Dict directly using one of their "...SetString" or "...AppendString"
/// methods.
@ffi.Native<NativeFLValue_NewString>()
external FLValue FLValue_NewString(
  FLString arg0,
);

/// Allocates a data/blob value on the heap. This is rarely needed -- usually you'd just add data
/// to a mutable Array or Dict directly using one of their "...SetData or "...AppendData"
/// methods.
@ffi.Native<NativeFLValue_NewData>()
external FLValue FLValue_NewData(
  FLSlice arg0,
);

/// Returns an \ref FLSlot that refers to the given index of the given array.
/// You store a value to it by calling one of the nine `FLSlot_Set...` functions.
/// \warning You should immediately store a value into the `FLSlot`. Do not keep it around;
/// any changes to the array invalidate it.
@ffi.Native<NativeFLMutableArray_Set>()
external FLSlot FLMutableArray_Set(
  FLMutableArray arg0,
  int index,
);

/// Appends a null value to the array and returns an \ref FLSlot that refers to that position.
/// You store a value to it by calling one of the nine `FLSlot_Set...` functions.
/// \warning You should immediately store a value into the `FLSlot`. Do not keep it around;
/// any changes to the array invalidate it.
@ffi.Native<NativeFLMutableArray_Append>()
external FLSlot FLMutableArray_Append(
  FLMutableArray arg0,
);

/// Returns an \ref FLSlot that refers to the given key/value pair of the given dictionary.
/// You store a value to it by calling one of the nine `FLSlot_Set...` functions.
/// \warning You should immediately store a value into the `FLSlot`. Do not keep it around;
/// any changes to the dictionary invalidate it.
@ffi.Native<NativeFLMutableDict_Set>()
external FLSlot FLMutableDict_Set(
  FLMutableDict arg0,
  FLString key,
);

@ffi.Native<NativeFLSlot_SetNull>()
external void FLSlot_SetNull(
  FLSlot arg0,
);

@ffi.Native<NativeFLSlot_SetBool>()
external void FLSlot_SetBool(
  FLSlot arg0,
  bool arg1,
);

@ffi.Native<NativeFLSlot_SetInt>()
external void FLSlot_SetInt(
  FLSlot arg0,
  int arg1,
);

@ffi.Native<NativeFLSlot_SetUInt>()
external void FLSlot_SetUInt(
  FLSlot arg0,
  int arg1,
);

@ffi.Native<NativeFLSlot_SetFloat>()
external void FLSlot_SetFloat(
  FLSlot arg0,
  double arg1,
);

@ffi.Native<NativeFLSlot_SetDouble>()
external void FLSlot_SetDouble(
  FLSlot arg0,
  double arg1,
);

@ffi.Native<NativeFLSlot_SetString>()
external void FLSlot_SetString(
  FLSlot arg0,
  FLString arg1,
);

@ffi.Native<NativeFLSlot_SetData>()
external void FLSlot_SetData(
  FLSlot arg0,
  FLSlice arg1,
);

@ffi.Native<NativeFLSlot_SetValue>()
external void FLSlot_SetValue(
  FLSlot arg0,
  FLValue arg1,
);

/// Returns JSON that encodes the changes to turn the value `old` into `nuu`.
/// (The format is documented in Fleece.md, but you should treat it as a black box.)
/// @param old  A value that's typically the old/original state of some data.
/// @param nuu  A value that's typically the new/changed state of the `old` data.
/// @return  JSON data representing the changes from `old` to `nuu`, or NULL on
/// (extremely unlikely) failure.
@ffi.Native<NativeFLCreateJSONDelta>()
external FLSliceResult FLCreateJSONDelta(
  FLValue old,
  FLValue nuu,
);

/// Writes JSON that describes the changes to turn the value `old` into `nuu`.
/// (The format is documented in Fleece.md, but you should treat it as a black box.)
/// @param old  A value that's typically the old/original state of some data.
/// @param nuu  A value that's typically the new/changed state of the `old` data.
/// @param jsonEncoder  An encoder to write the JSON to. Must have been created using
/// `FLEncoder_NewWithOptions`, with JSON or JSON5 format.
/// @return  True on success, false on (extremely unlikely) failure.
@ffi.Native<NativeFLEncodeJSONDelta>()
external bool FLEncodeJSONDelta(
  FLValue old,
  FLValue nuu,
  FLEncoder jsonEncoder,
);

/// Applies the JSON data created by `CreateJSONDelta` to the value `old`, which must be equal
/// to the `old` value originally passed to `FLCreateJSONDelta`, and returns a Fleece document
/// equal to the original `nuu` value.
/// @param old  A value that's typically the old/original state of some data. This must be
/// equal to the `old` value used when creating the `jsonDelta`.
/// @param jsonDelta  A JSON-encoded delta created by `FLCreateJSONDelta` or `FLEncodeJSONDelta`.
/// @param outError  On failure, error information will be stored where this points, if non-null.
/// @return  The corresponding `nuu` value, encoded as Fleece, or null if an error occurred.
@ffi.Native<NativeFLApplyJSONDelta>()
external FLSliceResult FLApplyJSONDelta(
  FLValue old,
  FLSlice jsonDelta,
  ffi.Pointer<ffi.Int32> outError,
);

/// Applies the (parsed) JSON data created by `CreateJSONDelta` to the value `old`, which must be
/// equal to the `old` value originally passed to `FLCreateJSONDelta`, and writes the corresponding
/// `nuu` value to the encoder.
/// @param old  A value that's typically the old/original state of some data. This must be
/// equal to the `old` value used when creating the `jsonDelta`.
/// @param jsonDelta  A JSON-encoded delta created by `FLCreateJSONDelta` or `FLEncodeJSONDelta`.
/// @param encoder  A Fleece encoder to write the decoded `nuu` value to. (JSON encoding is not
/// supported.)
/// @return  True on success, false on error; call `FLEncoder_GetError` for details.
@ffi.Native<NativeFLEncodeApplyingJSONDelta>()
external bool FLEncodeApplyingJSONDelta(
  FLValue old,
  FLSlice jsonDelta,
  FLEncoder encoder,
);

/// Creates a new empty FLSharedKeys object, which must eventually be released.
@ffi.Native<NativeFLSharedKeys_New>()
external FLSharedKeys FLSharedKeys_New();

@ffi.Native<NativeFLSharedKeys_NewWithRead>()
external FLSharedKeys FLSharedKeys_NewWithRead(
  FLSharedKeysReadCallback arg0,
  ffi.Pointer<ffi.Void> context,
);

/// Returns a data blob containing the current state (all the keys and their integers.)
@ffi.Native<NativeFLSharedKeys_GetStateData>()
external FLSliceResult FLSharedKeys_GetStateData(
  FLSharedKeys arg0,
);

/// Updates an FLSharedKeys with saved state data created by \ref FLSharedKeys_GetStateData.
/// Returns true if new keys were added, false if not.
@ffi.Native<NativeFLSharedKeys_LoadStateData>()
external bool FLSharedKeys_LoadStateData(
  FLSharedKeys arg0,
  FLSlice arg1,
);

/// Writes the current state to a Fleece encoder as a single value,
/// which can later be decoded and passed to \ref FLSharedKeys_LoadState.
@ffi.Native<NativeFLSharedKeys_WriteState>()
external void FLSharedKeys_WriteState(
  FLSharedKeys arg0,
  FLEncoder arg1,
);

/// Updates an FLSharedKeys object with saved state, a Fleece value previously written by
/// \ref FLSharedKeys_WriteState.
@ffi.Native<NativeFLSharedKeys_LoadState>()
external bool FLSharedKeys_LoadState(
  FLSharedKeys arg0,
  FLValue arg1,
);

/// Maps a key string to a number in the range [0...2047], or returns -1 if it isn't mapped.
/// If the key doesn't already have a mapping, and the `add` flag is true,
/// a new mapping is assigned and returned.
/// However, the `add` flag has no effect if the key is unmappable (is longer than 16 bytes
/// or contains non-identifier characters), or if all available integers have been assigned.
@ffi.Native<NativeFLSharedKeys_Encode>()
external int FLSharedKeys_Encode(
  FLSharedKeys arg0,
  FLString arg1,
  bool add,
);

/// Returns the key string that maps to the given integer `key`, else NULL.
@ffi.Native<NativeFLSharedKeys_Decode>()
external FLString FLSharedKeys_Decode(
  FLSharedKeys arg0,
  int key,
);

/// Returns the number of keys in the mapping. This number increases whenever the mapping
/// is changed, and never decreases.
@ffi.Native<NativeFLSharedKeys_Count>()
external int FLSharedKeys_Count(
  FLSharedKeys arg0,
);

/// Reverts an FLSharedKeys by "forgetting" any keys added since it had the count `oldCount`.
@ffi.Native<NativeFLSharedKeys_RevertToCount>()
external void FLSharedKeys_RevertToCount(
  FLSharedKeys arg0,
  int oldCount,
);

/// Disable caching of the SharedKeys..
@ffi.Native<NativeFLSharedKeys_DisableCaching>()
external void FLSharedKeys_DisableCaching(
  FLSharedKeys arg0,
);

/// Increments the reference count of an FLSharedKeys.
@ffi.Native<NativeFLSharedKeys_Retain>()
external FLSharedKeys FLSharedKeys_Retain(
  FLSharedKeys arg0,
);

/// Decrements the reference count of an FLSharedKeys, freeing it when it reaches zero.
@ffi.Native<NativeFLSharedKeys_Release>()
external void FLSharedKeys_Release(
  FLSharedKeys arg0,
);

/// Registers a range of memory containing Fleece data that uses the given shared keys.
/// This allows Dict accessors to look up the values of shared keys.
@ffi.Native<NativeFLSharedKeyScope_WithRange>()
external FLSharedKeyScope FLSharedKeyScope_WithRange(
  FLSlice range,
  FLSharedKeys arg1,
);

/// Unregisters a scope created by \ref FLSharedKeyScope_WithRange.
@ffi.Native<NativeFLSharedKeyScope_Free>()
external void FLSharedKeyScope_Free(
  FLSharedKeyScope arg0,
);

/// Returns a pointer to the root value in the encoded data, or NULL if validation failed.
/// You should generally use an \ref FLDoc instead; it's safer. Here's why:
///
/// On the plus side, \ref FLValue_FromData is _extremely_ fast: it allocates no memory,
/// only scans enough of the data to ensure it's valid (and if `trust` is set to `kFLTrusted`,
/// it doesn't even do that.)
///
/// But it's potentially _very_ dangerous: the FLValue, and all values found through it, are
/// only valid as long as the input `data` remains intact and unchanged. If you violate
/// that, the values will be pointing to garbage and Bad Things will happen when you access
/// them...
@ffi.Native<NativeFLValue_FromData>()
external FLValue FLValue_FromData(
  FLSlice data,
  int trust,
);

/// Converts valid JSON5 <https://json5.org> to JSON. Among other things, it converts single
/// quotes to double, adds missing quotes around dictionary keys, removes trailing commas,
/// and removes comments.
/// @note If given invalid JSON5, it will _usually_ return an error, but may just ouput
/// comparably invalid JSON, in which case the caller's subsequent JSON parsing will
/// detect the error. The types of errors it overlooks tend to be subtleties of string
/// or number encoding.
/// @param json5  The JSON5 to parse
/// @param outErrorMessage  On failure, the error message will be stored here (if not NULL.)
/// As this is a \ref FLStringResult, you will be responsible for freeing it.
/// @param outErrorPos  On a parse error, the byte offset in the input where the error occurred
/// will be stored here (if it's not NULL.)
/// @param outError  On failure, the error code will be stored here (if it's not NULL.)
/// @return  The converted JSON.
@ffi.Native<NativeFLJSON5_ToJSON>()
external FLStringResult FLJSON5_ToJSON(
  FLString json5,
  ffi.Pointer<FLStringResult> outErrorMessage,
  ffi.Pointer<ffi.Size> outErrorPos,
  ffi.Pointer<ffi.Int32> outError,
);

/// Directly converts JSON data to Fleece-encoded data. Not commonly needed.
/// Prefer \ref FLDoc_FromJSON instead.
@ffi.Native<NativeFLData_ConvertJSON>()
external FLSliceResult FLData_ConvertJSON(
  FLSlice json,
  ffi.Pointer<ffi.Int32> outError,
);

/// Tells the encoder to logically append to the given Fleece document, rather than making a
/// standalone document. Any calls to FLEncoder_WriteValue() where the value points inside the
/// base data will write a pointer back to the original value.
/// The resulting data returned by FLEncoder_FinishDoc() will *NOT* be standalone; it can only
/// be used by first appending it to the base data.
/// @param e  The FLEncoder affected.
/// @param base  The base document to create an amendment of.
/// @param reuseStrings  If true, then writing a string that already exists in the base will
/// just create a pointer back to the original. But the encoder has to scan the
/// base for strings first.
/// @param externPointers  If true, pointers into the base will be marked with the `extern`
/// flag. This allows them to be resolved using the `FLResolver_Begin` function,
/// so that when the delta is used the base document can be anywhere in memory,
/// not just immediately preceding the delta document.
@ffi.Native<NativeFLEncoder_Amend>()
external void FLEncoder_Amend(
  FLEncoder e,
  FLSlice base,
  bool reuseStrings,
  bool externPointers,
);

/// Returns the `base` value passed to FLEncoder_Amend.
@ffi.Native<NativeFLEncoder_GetBase>()
external FLSlice FLEncoder_GetBase(
  FLEncoder arg0,
);

/// Tells the encoder not to write the two-byte Fleece trailer at the end of the data.
/// This is only useful for certain special purposes.
@ffi.Native<NativeFLEncoder_SuppressTrailer>()
external void FLEncoder_SuppressTrailer(
  FLEncoder arg0,
);

/// Returns the byte offset in the encoded data where the next value will be written.
/// (Due to internal buffering, this is not the same as FLEncoder_BytesWritten.)
@ffi.Native<NativeFLEncoder_GetNextWritePos>()
external int FLEncoder_GetNextWritePos(
  FLEncoder arg0,
);

/// Returns an opaque reference to the last complete value written to the encoder, if possible.
/// Fails (returning kFLNoWrittenValue) if nothing has been written, or if the value is inline
/// and can't be referenced this way -- that only happens with small scalars or empty
/// collections.
@ffi.Native<NativeFLEncoder_LastValueWritten>()
external int FLEncoder_LastValueWritten(
  FLEncoder arg0,
);

/// Writes another reference (a "pointer") to an already-written value, given a reference previously
/// returned from \ref FLEncoder_LastValueWritten. The effect is exactly the same as if you wrote the
/// entire value again, except that the size of the encoded data only grows by 4 bytes.
/// Returns false if the reference couldn't be written.
@ffi.Native<NativeFLEncoder_WriteValueAgain>()
external bool FLEncoder_WriteValueAgain(
  FLEncoder arg0,
  int preWrittenValue,
);

/// Returns the data written so far as a standalone Fleece document, whose root is the last
/// value written. You can continue writing, and the final output returned by \ref FLEncoder_Finish will
/// consist of everything after this point. That second part can be used in the future by loading it
/// as an `FLDoc` with the first part as its `extern` reference.
@ffi.Native<NativeFLEncoder_Snip>()
external FLSliceResult FLEncoder_Snip(
  FLEncoder arg0,
);

/// Finishes encoding the current item, and returns its offset in the output data.
@ffi.Native<NativeFLEncoder_FinishItem>()
external int FLEncoder_FinishItem(
  FLEncoder arg0,
);

/// In a JSON encoder, adds a newline ('\n') and prepares to start encoding another
/// top-level object. The encoder MUST be not be within an array or dict.
/// Has no effect in a Fleece encoder.
@ffi.Native<NativeFLJSONEncoder_NextDocument>()
external void FLJSONEncoder_NextDocument(
  FLEncoder arg0,
);

/// Debugging function that returns a C string of JSON.
/// Does not free the string's memory!
@ffi.Native<NativeFLDump>()
external ffi.Pointer<ffi.Char> FLDump(
  FLValue arg0,
);

/// Debugging function that parses Fleece data and returns a C string of JSON.
/// Does not free the string's memory!
@ffi.Native<NativeFLDumpData>()
external ffi.Pointer<ffi.Char> FLDumpData(
  FLSlice data,
);

/// Produces a human-readable dump of Fleece-encoded data.
/// This is only useful if you already know, or want to learn, the encoding format.
@ffi.Native<NativeFLData_Dump>()
external FLStringResult FLData_Dump(
  FLSlice data,
);

/// A struct holding information about an error. It's declared on the stack by a caller, and
/// its address is passed to an API function. If the function's return value indicates that
/// there was an error (usually by returning NULL or false), then the CBLError will have been
/// filled in with the details.
final class CBLError extends ffi.Struct {
  /// < Domain of errors; a namespace for the `code`.
  @CBLErrorDomain()
  external int domain;

  /// < Error code, specific to the domain. 0 always means no error.
  @ffi.Int()
  external int code;

  @ffi.UnsignedInt()
  external int internal_info;
}

/// Error domains, serving as namespaces for numeric error codes.
typedef CBLErrorDomain = ffi.Uint8;
typedef DartCBLErrorDomain = int;

/// A heap-allocated block of memory returned from an API call.
/// The caller takes ownership, and must call \ref FLSliceResult_Release when done with it.
/// \warning The contents of the block must not be modified, since others may be using it.
/// \note This is equivalent to the C++ class `alloc_slice`. In C++ the easiest way to deal with
/// a `FLSliceResult` return value is to construct an `alloc_slice` from it, which will
/// adopt the reference, and release it in its destructor. For example:
/// `alloc_slice foo( CopyFoo() );`
final class FLSliceResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> buf;

  @ffi.Size()
  external int size;
}

typedef NativeCBLError_Message = FLSliceResult Function(
    ffi.Pointer<CBLError> outError);
typedef DartCBLError_Message = FLSliceResult Function(
    ffi.Pointer<CBLError> outError);

/// A date/time representation used for document expiration (and in date/time queries.)
/// Measured in milliseconds since the Unix epoch (1/1/1970, midnight UTC.)
typedef CBLTimestamp = ffi.Int64;
typedef DartCBLTimestamp = int;
typedef NativeCBL_Now = CBLTimestamp Function();
typedef DartCBL_Now = int Function();

final class CBLRefCounted extends ffi.Opaque {}

typedef NativeCBL_Retain = ffi.Pointer<CBLRefCounted> Function(
    ffi.Pointer<CBLRefCounted> arg0);
typedef DartCBL_Retain = ffi.Pointer<CBLRefCounted> Function(
    ffi.Pointer<CBLRefCounted> arg0);
typedef NativeCBL_Release = ffi.Void Function(ffi.Pointer<CBLRefCounted> arg0);
typedef DartCBL_Release = void Function(ffi.Pointer<CBLRefCounted> arg0);
typedef NativeCBL_InstanceCount = ffi.UnsignedInt Function();
typedef DartCBL_InstanceCount = int Function();
typedef NativeCBL_DumpInstances = ffi.Void Function();
typedef DartCBL_DumpInstances = void Function();

final class CBLDatabase extends ffi.Opaque {}

final class CBLScope extends ffi.Opaque {}

final class CBLCollection extends ffi.Opaque {}

final class CBLDocument extends ffi.Opaque {}

final class CBLBlob extends ffi.Opaque {}

final class CBLQuery extends ffi.Opaque {}

final class CBLResultSet extends ffi.Opaque {}

final class CBLQueryIndex extends ffi.Opaque {}

final class CBLReplicator extends ffi.Opaque {}

final class CBLListenerToken extends ffi.Opaque {}

typedef NativeCBLListener_Remove = ffi.Void Function(
    ffi.Pointer<CBLListenerToken> arg0);
typedef DartCBLListener_Remove = void Function(
    ffi.Pointer<CBLListenerToken> arg0);

/// A simple reference to a block of memory. Does not imply ownership.
/// (This is equivalent to the C++ class `slice`.)
final class FLSlice extends ffi.Struct {
  external ffi.Pointer<ffi.Void> buf;

  @ffi.Size()
  external int size;
}

typedef FLDict = ffi.Pointer<_FLDict>;

final class _FLDict extends ffi.Opaque {}

typedef NativeFLDict_IsBlob = ffi.Bool Function(FLDict arg0);
typedef DartFLDict_IsBlob = bool Function(FLDict arg0);
typedef NativeFLDict_GetBlob = ffi.Pointer<CBLBlob> Function(FLDict blobDict);
typedef DartFLDict_GetBlob = ffi.Pointer<CBLBlob> Function(FLDict blobDict);
typedef NativeCBLBlob_Length = ffi.Uint64 Function(ffi.Pointer<CBLBlob> arg0);
typedef DartCBLBlob_Length = int Function(ffi.Pointer<CBLBlob> arg0);
typedef FLString = FLSlice;
typedef NativeCBLBlob_ContentType = FLString Function(
    ffi.Pointer<CBLBlob> arg0);
typedef DartCBLBlob_ContentType = FLString Function(ffi.Pointer<CBLBlob> arg0);
typedef NativeCBLBlob_Digest = FLString Function(ffi.Pointer<CBLBlob> arg0);
typedef DartCBLBlob_Digest = FLString Function(ffi.Pointer<CBLBlob> arg0);
typedef NativeCBLBlob_Properties = FLDict Function(ffi.Pointer<CBLBlob> arg0);
typedef DartCBLBlob_Properties = FLDict Function(ffi.Pointer<CBLBlob> arg0);
typedef FLStringResult = FLSliceResult;
typedef NativeCBLBlob_CreateJSON = FLStringResult Function(
    ffi.Pointer<CBLBlob> blob);
typedef DartCBLBlob_CreateJSON = FLStringResult Function(
    ffi.Pointer<CBLBlob> blob);
typedef NativeCBLBlob_Content = FLSliceResult Function(
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLError> outError);
typedef DartCBLBlob_Content = FLSliceResult Function(
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLError> outError);

final class CBLBlobReadStream extends ffi.Opaque {}

typedef NativeCBLBlob_OpenContentStream = ffi.Pointer<CBLBlobReadStream>
    Function(ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLError> arg1);
typedef DartCBLBlob_OpenContentStream = ffi.Pointer<CBLBlobReadStream> Function(
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLError> arg1);
typedef NativeCBLBlobReader_Read = ffi.Int Function(
    ffi.Pointer<CBLBlobReadStream> stream,
    ffi.Pointer<ffi.Void> dst,
    ffi.Size maxLength,
    ffi.Pointer<CBLError> outError);
typedef DartCBLBlobReader_Read = int Function(
    ffi.Pointer<CBLBlobReadStream> stream,
    ffi.Pointer<ffi.Void> dst,
    int maxLength,
    ffi.Pointer<CBLError> outError);

/// Defines the interpretation of `offset` in \ref CBLBlobReader_Seek.
typedef CBLSeekBase = ffi.Uint8;
typedef DartCBLSeekBase = int;
typedef NativeCBLBlobReader_Seek = ffi.Int64 Function(
    ffi.Pointer<CBLBlobReadStream> stream,
    ffi.Int64 offset,
    CBLSeekBase base,
    ffi.Pointer<CBLError> outError);
typedef DartCBLBlobReader_Seek = int Function(
    ffi.Pointer<CBLBlobReadStream> stream,
    int offset,
    int base,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLBlobReader_Position = ffi.Uint64 Function(
    ffi.Pointer<CBLBlobReadStream> stream);
typedef DartCBLBlobReader_Position = int Function(
    ffi.Pointer<CBLBlobReadStream> stream);
typedef NativeCBLBlobReader_Close = ffi.Void Function(
    ffi.Pointer<CBLBlobReadStream> arg0);
typedef DartCBLBlobReader_Close = void Function(
    ffi.Pointer<CBLBlobReadStream> arg0);
typedef NativeCBLBlob_Equals = ffi.Bool Function(
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLBlob> anotherBlob);
typedef DartCBLBlob_Equals = bool Function(
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLBlob> anotherBlob);
typedef NativeCBLBlob_CreateWithData = ffi.Pointer<CBLBlob> Function(
    FLString contentType, FLSlice contents);
typedef DartCBLBlob_CreateWithData = ffi.Pointer<CBLBlob> Function(
    FLString contentType, FLSlice contents);

final class CBLBlobWriteStream extends ffi.Opaque {}

typedef NativeCBLBlobWriter_Create = ffi.Pointer<CBLBlobWriteStream> Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> arg1);
typedef DartCBLBlobWriter_Create = ffi.Pointer<CBLBlobWriteStream> Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> arg1);
typedef NativeCBLBlobWriter_Close = ffi.Void Function(
    ffi.Pointer<CBLBlobWriteStream> arg0);
typedef DartCBLBlobWriter_Close = void Function(
    ffi.Pointer<CBLBlobWriteStream> arg0);
typedef NativeCBLBlobWriter_Write = ffi.Bool Function(
    ffi.Pointer<CBLBlobWriteStream> writer,
    ffi.Pointer<ffi.Void> data,
    ffi.Size length,
    ffi.Pointer<CBLError> outError);
typedef DartCBLBlobWriter_Write = bool Function(
    ffi.Pointer<CBLBlobWriteStream> writer,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLBlob_CreateWithStream = ffi.Pointer<CBLBlob> Function(
    FLString contentType, ffi.Pointer<CBLBlobWriteStream> writer);
typedef DartCBLBlob_CreateWithStream = ffi.Pointer<CBLBlob> Function(
    FLString contentType, ffi.Pointer<CBLBlobWriteStream> writer);
typedef FLSlot = ffi.Pointer<_FLSlot>;

final class _FLSlot extends ffi.Opaque {}

typedef NativeFLSlot_SetBlob = ffi.Void Function(
    FLSlot slot, ffi.Pointer<CBLBlob> blob);
typedef DartFLSlot_SetBlob = void Function(
    FLSlot slot, ffi.Pointer<CBLBlob> blob);
typedef NativeCBLDatabase_GetBlob = ffi.Pointer<CBLBlob> Function(
    ffi.Pointer<CBLDatabase> db,
    FLDict properties,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_GetBlob = ffi.Pointer<CBLBlob> Function(
    ffi.Pointer<CBLDatabase> db,
    FLDict properties,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_SaveBlob = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLBlob> blob,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_SaveBlob = bool Function(ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_GetDocument = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_GetDocument = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_SaveDocument = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_SaveDocument = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError);

/// Conflict-handling options when saving or deleting a document.
typedef CBLConcurrencyControl = ffi.Uint8;
typedef DartCBLConcurrencyControl = int;
typedef NativeCBLDatabase_SaveDocumentWithConcurrencyControl
    = ffi.Bool Function(
        ffi.Pointer<CBLDatabase> db,
        ffi.Pointer<CBLDocument> doc,
        CBLConcurrencyControl concurrency,
        ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_SaveDocumentWithConcurrencyControl = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    int concurrency,
    ffi.Pointer<CBLError> outError);

/// Custom conflict handler for use when saving or deleting a document. This handler is called
/// if the save would cause a conflict, i.e. if the document in the database has been updated
/// (probably by a pull replicator, or by application code on another thread)
/// since it was loaded into the CBLDocument being saved.
/// @param context  The value of the \p context parameter you passed to
/// \ref CBLDatabase_SaveDocumentWithConflictHandler.
/// @param documentBeingSaved  The document being saved (same as the parameter you passed to
/// \ref CBLDatabase_SaveDocumentWithConflictHandler.) The callback may modify
/// this document's properties as necessary to resolve the conflict.
/// @param conflictingDocument  The revision of the document currently in the database,
/// which has been changed since \p documentBeingSaved was loaded.
/// May be NULL, meaning that the document has been deleted.
/// @return  True to save the document, false to abort the save.
typedef CBLConflictHandler
    = ffi.Pointer<ffi.NativeFunction<CBLConflictHandlerFunction>>;
typedef CBLConflictHandlerFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDocument> documentBeingSaved,
    ffi.Pointer<CBLDocument> conflictingDocument);
typedef DartCBLConflictHandlerFunction = bool Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDocument> documentBeingSaved,
    ffi.Pointer<CBLDocument> conflictingDocument);
typedef NativeCBLDatabase_SaveDocumentWithConflictHandler = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    CBLConflictHandler conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_SaveDocumentWithConflictHandler = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    CBLConflictHandler conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DeleteDocument = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DeleteDocument = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DeleteDocumentWithConcurrencyControl
    = ffi.Bool Function(
        ffi.Pointer<CBLDatabase> db,
        ffi.Pointer<CBLDocument> document,
        CBLConcurrencyControl concurrency,
        ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DeleteDocumentWithConcurrencyControl = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    int concurrency,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_PurgeDocument = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_PurgeDocument = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_PurgeDocumentByID = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_PurgeDocumentByID = bool Function(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_GetMutableDocument
    = ffi.Pointer<CBLDocument> Function(ffi.Pointer<CBLDatabase> database,
        FLString docID, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_GetMutableDocument = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDocument_Create = ffi.Pointer<CBLDocument> Function();
typedef DartCBLDocument_Create = ffi.Pointer<CBLDocument> Function();
typedef NativeCBLDocument_CreateWithID = ffi.Pointer<CBLDocument> Function(
    FLString docID);
typedef DartCBLDocument_CreateWithID = ffi.Pointer<CBLDocument> Function(
    FLString docID);
typedef NativeCBLDocument_MutableCopy = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLDocument> original);
typedef DartCBLDocument_MutableCopy = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLDocument> original);
typedef NativeCBLDocument_ID = FLString Function(ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_ID = FLString Function(ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_RevisionID = FLString Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_RevisionID = FLString Function(
    ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_Sequence = ffi.Uint64 Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_Sequence = int Function(ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_Properties = FLDict Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_Properties = FLDict Function(
    ffi.Pointer<CBLDocument> arg0);
typedef FLMutableDict = ffi.Pointer<_FLDict>;
typedef NativeCBLDocument_MutableProperties = FLMutableDict Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_MutableProperties = FLMutableDict Function(
    ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_SetProperties = ffi.Void Function(
    ffi.Pointer<CBLDocument> arg0, FLMutableDict properties);
typedef DartCBLDocument_SetProperties = void Function(
    ffi.Pointer<CBLDocument> arg0, FLMutableDict properties);
typedef NativeCBLDocument_CreateJSON = FLSliceResult Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_CreateJSON = FLSliceResult Function(
    ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_SetJSON = ffi.Bool Function(
    ffi.Pointer<CBLDocument> arg0,
    FLSlice json,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDocument_SetJSON = bool Function(ffi.Pointer<CBLDocument> arg0,
    FLSlice json, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_GetDocumentExpiration = CBLTimestamp Function(
    ffi.Pointer<CBLDatabase> db, FLSlice docID, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_GetDocumentExpiration = int Function(
    ffi.Pointer<CBLDatabase> db, FLSlice docID, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_SetDocumentExpiration = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    CBLTimestamp expiration,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_SetDocumentExpiration = bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    int expiration,
    ffi.Pointer<CBLError> outError);

/// A document change listener callback, invoked after a specific document is changed on disk.
/// @warning  By default, this listener may be called on arbitrary threads. If your code isn't
/// prepared for that, you may want to use \ref CBLDatabase_BufferNotifications
/// so that listeners will be called in a safe context.
/// @warning  <b>Deprecated :</b> Use CBLCollectionChangeListener instead.
/// @param context  An arbitrary value given when the callback was registered.
/// @param db  The database containing the document.
/// @param docID  The document's ID.
typedef CBLDocumentChangeListener
    = ffi.Pointer<ffi.NativeFunction<CBLDocumentChangeListenerFunction>>;
typedef CBLDocumentChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDatabase> db, FLString docID);
typedef DartCBLDocumentChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDatabase> db, FLString docID);
typedef NativeCBLDatabase_AddDocumentChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLDatabase> db,
        FLString docID,
        CBLDocumentChangeListener listener,
        ffi.Pointer<ffi.Void> context);
typedef DartCBLDatabase_AddDocumentChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLDatabase> db,
        FLString docID,
        CBLDocumentChangeListener listener,
        ffi.Pointer<ffi.Void> context);

/// Value Index Configuration.
final class CBLValueIndexConfiguration extends ffi.Struct {
  /// The language used in the expressions.
  @CBLQueryLanguage()
  external int expressionLanguage;

  /// The expressions describing each coloumn of the index. The expressions could be specified
  /// in a JSON Array or in N1QL syntax using comma delimiter.
  external FLString expressions;
}

/// Supported Query languages
typedef CBLQueryLanguage = ffi.Uint32;
typedef DartCBLQueryLanguage = int;

/// Full-Text Index Configuration.
final class CBLFullTextIndexConfiguration extends ffi.Struct {
  /// The language used in the expressions (Required).
  @CBLQueryLanguage()
  external int expressionLanguage;

  /// The expressions describing each coloumn of the index. The expressions could be specified
  /// in a JSON Array or in N1QL syntax using comma delimiter. (Required)
  external FLString expressions;

  /// Should diacritical marks (accents) be ignored?
  /// Defaults to  \ref kCBLDefaultFullTextIndexIgnoreAccents.
  /// Generally this should be left `false` for non-English text.
  @ffi.Bool()
  external bool ignoreAccents;

  /// The dominant language. Setting this enables word stemming, i.e.
  /// matching different cases of the same word ("big" and "bigger", for instance) and ignoring
  /// common "stop-words" ("the", "a", "of", etc.)
  ///
  /// Can be an ISO-639 language code or a lowercase (English) language name; supported
  /// languages are: da/danish, nl/dutch, en/english, fi/finnish, fr/french, de/german,
  /// hu/hungarian, it/italian, no/norwegian, pt/portuguese, ro/romanian, ru/russian,
  /// es/spanish, sv/swedish, tr/turkish.
  ///
  /// If left null,  or set to an unrecognized language, no language-specific behaviors
  /// such as stemming and stop-word removal occur.
  external FLString language;
}

typedef FLMutableArray = ffi.Pointer<_FLArray>;

final class _FLArray extends ffi.Opaque {}

typedef NativeCBLDatabase_ScopeNames = FLMutableArray Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_ScopeNames = FLMutableArray Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_CollectionNames = FLMutableArray Function(
    ffi.Pointer<CBLDatabase> db,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_CollectionNames = FLMutableArray Function(
    ffi.Pointer<CBLDatabase> db,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Scope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLDatabase> db,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_Scope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLDatabase> db,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_CreateCollection
    = ffi.Pointer<CBLCollection> Function(
        ffi.Pointer<CBLDatabase> db,
        FLString collectionName,
        FLString scopeName,
        ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_CreateCollection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DeleteCollection = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DeleteCollection = bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DefaultScope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DefaultScope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DefaultCollection = ffi.Pointer<CBLCollection>
    Function(ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DefaultCollection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_Scope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLCollection> collection);
typedef DartCBLCollection_Scope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLCollection> collection);
typedef NativeCBLCollection_Name = FLString Function(
    ffi.Pointer<CBLCollection> collection);
typedef DartCBLCollection_Name = FLString Function(
    ffi.Pointer<CBLCollection> collection);
typedef NativeCBLCollection_FullName = FLString Function(
    ffi.Pointer<CBLCollection> collection);
typedef DartCBLCollection_FullName = FLString Function(
    ffi.Pointer<CBLCollection> collection);
typedef NativeCBLCollection_Database = ffi.Pointer<CBLDatabase> Function(
    ffi.Pointer<CBLCollection> collection);
typedef DartCBLCollection_Database = ffi.Pointer<CBLDatabase> Function(
    ffi.Pointer<CBLCollection> collection);
typedef NativeCBLCollection_Count = ffi.Uint64 Function(
    ffi.Pointer<CBLCollection> collection);
typedef DartCBLCollection_Count = int Function(
    ffi.Pointer<CBLCollection> collection);
typedef NativeCBLCollection_GetDocument = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_GetDocument = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_SaveDocument = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_SaveDocument = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_SaveDocumentWithConcurrencyControl
    = ffi.Bool Function(
        ffi.Pointer<CBLCollection> collection,
        ffi.Pointer<CBLDocument> doc,
        CBLConcurrencyControl concurrency,
        ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_SaveDocumentWithConcurrencyControl = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    int concurrency,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_SaveDocumentWithConflictHandler = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    CBLConflictHandler conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_SaveDocumentWithConflictHandler = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    CBLConflictHandler conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_DeleteDocument = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_DeleteDocument = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_DeleteDocumentWithConcurrencyControl
    = ffi.Bool Function(
        ffi.Pointer<CBLCollection> collection,
        ffi.Pointer<CBLDocument> document,
        CBLConcurrencyControl concurrency,
        ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_DeleteDocumentWithConcurrencyControl = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    int concurrency,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_PurgeDocument = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_PurgeDocument = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_PurgeDocumentByID = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_PurgeDocumentByID = bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_GetDocumentExpiration = CBLTimestamp Function(
    ffi.Pointer<CBLCollection> collection,
    FLSlice docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_GetDocumentExpiration = int Function(
    ffi.Pointer<CBLCollection> collection,
    FLSlice docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_SetDocumentExpiration = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLSlice docID,
    CBLTimestamp expiration,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_SetDocumentExpiration = bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLSlice docID,
    int expiration,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_GetMutableDocument
    = ffi.Pointer<CBLDocument> Function(ffi.Pointer<CBLCollection> collection,
        FLString docID, ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_GetMutableDocument
    = ffi.Pointer<CBLDocument> Function(ffi.Pointer<CBLCollection> collection,
        FLString docID, ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_CreateValueIndex = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_CreateValueIndex = bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_CreateFullTextIndex = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_CreateFullTextIndex = bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_DeleteIndex = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_DeleteIndex = bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_GetIndexNames = FLMutableArray Function(
    ffi.Pointer<CBLCollection> collection, ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_GetIndexNames = FLMutableArray Function(
    ffi.Pointer<CBLCollection> collection, ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_GetIndex = ffi.Pointer<CBLQueryIndex> Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_GetIndex = ffi.Pointer<CBLQueryIndex> Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    ffi.Pointer<CBLError> outError);

/// \name  Change Listeners
/// @{
/// A collection change listener lets you detect changes made to all documents in a collection.
/// (If you want to observe specific documents, use a \ref CBLCollectionDocumentChangeListener instead.)
/// @note  If there are multiple \ref CBLCollection instances on the same database file, each one's
/// listeners will be notified of changes made by other collection instances.
/// @warning  Changes made to the database file by other processes will _not_ be notified.
final class CBLCollectionChange extends ffi.Struct {
  /// <The collection that changed.
  external ffi.Pointer<CBLCollection> collection;

  /// < The number of documents that changed (size of the `docIDs` array).
  @ffi.UnsignedInt()
  external int numDocs;

  /// <The IDs of the documents that changed.
  external ffi.Pointer<FLString> docIDs;
}

/// A collection change listener callback, invoked after one or more documents are changed on disk.
/// @warning  By default, this listener may be called on arbitrary threads. If your code isn't
/// prepared for that, you may want to use \ref CBLDatabase_BufferNotifications
/// so that listeners will be called in a safe context.
/// @param context  An arbitrary value given when the callback was registered.
/// @param change  The collection change information.
typedef CBLCollectionChangeListener
    = ffi.Pointer<ffi.NativeFunction<CBLCollectionChangeListenerFunction>>;
typedef CBLCollectionChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLCollectionChange> change);
typedef DartCBLCollectionChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLCollectionChange> change);
typedef NativeCBLCollection_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLCollection> collection,
        CBLCollectionChangeListener listener,
        ffi.Pointer<ffi.Void> context);
typedef DartCBLCollection_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLCollection> collection,
        CBLCollectionChangeListener listener,
        ffi.Pointer<ffi.Void> context);

/// \name  Document listeners
/// @{
/// A document change listener lets you detect changes made to a specific document after
/// they are persisted to the collection.
/// @note If there are multiple CBLCollection instances on the same database file,
/// each one's document listeners will be notified of changes made by other
/// collection instances.
final class CBLDocumentChange extends ffi.Struct {
  /// < The collection that changed.
  external ffi.Pointer<CBLCollection> collection;

  /// <The document's ID.
  external FLString docID;
}

/// A document change listener callback, invoked after a specific document is changed on disk.
/// @warning  By default, this listener may be called on arbitrary threads. If your code isn't
/// prepared for that, you may want to use \ref CBLDatabase_BufferNotifications
/// so that listeners will be called in a safe context.
/// @param context  An arbitrary value given when the callback was registered.
/// @param change  The document change info.
typedef CBLCollectionDocumentChangeListener = ffi
    .Pointer<ffi.NativeFunction<CBLCollectionDocumentChangeListenerFunction>>;
typedef CBLCollectionDocumentChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDocumentChange> change);
typedef DartCBLCollectionDocumentChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDocumentChange> change);
typedef NativeCBLCollection_AddDocumentChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLCollection> collection,
        FLString docID,
        CBLCollectionDocumentChangeListener listener,
        ffi.Pointer<ffi.Void> context);
typedef DartCBLCollection_AddDocumentChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLCollection> collection,
        FLString docID,
        CBLCollectionDocumentChangeListener listener,
        ffi.Pointer<ffi.Void> context);

/// Database configuration options.
final class CBLDatabaseConfiguration extends ffi.Struct {
  /// < The parent directory of the database
  external FLString directory;
}

typedef NativeCBLDatabaseConfiguration_Default = CBLDatabaseConfiguration
    Function();
typedef DartCBLDatabaseConfiguration_Default = CBLDatabaseConfiguration
    Function();
typedef NativeCBL_DatabaseExists = ffi.Bool Function(
    FLString name, FLString inDirectory);
typedef DartCBL_DatabaseExists = bool Function(
    FLString name, FLString inDirectory);
typedef NativeCBL_CopyDatabase = ffi.Bool Function(
    FLString fromPath,
    FLString toName,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError);
typedef DartCBL_CopyDatabase = bool Function(
    FLString fromPath,
    FLString toName,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBL_DeleteDatabase = ffi.Bool Function(
    FLString name, FLString inDirectory, ffi.Pointer<CBLError> outError);
typedef DartCBL_DeleteDatabase = bool Function(
    FLString name, FLString inDirectory, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Open = ffi.Pointer<CBLDatabase> Function(
    FLSlice name,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_Open = ffi.Pointer<CBLDatabase> Function(
    FLSlice name,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Close = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_Close = bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Delete = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_Delete = bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_BeginTransaction = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_BeginTransaction = bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_EndTransaction = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Bool commit,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_EndTransaction = bool Function(
    ffi.Pointer<CBLDatabase> arg0, bool commit, ffi.Pointer<CBLError> outError);

/// Maintenance Type used when performing database maintenance.
typedef CBLMaintenanceType = ffi.Uint32;
typedef DartCBLMaintenanceType = int;
typedef NativeCBLDatabase_PerformMaintenance = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    CBLMaintenanceType type,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_PerformMaintenance = bool Function(
    ffi.Pointer<CBLDatabase> db, int type, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Name = FLString Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef DartCBLDatabase_Name = FLString Function(ffi.Pointer<CBLDatabase> arg0);
typedef NativeCBLDatabase_Path = FLStringResult Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef DartCBLDatabase_Path = FLStringResult Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef NativeCBLDatabase_Count = ffi.Uint64 Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef DartCBLDatabase_Count = int Function(ffi.Pointer<CBLDatabase> arg0);
typedef NativeCBLDatabase_Config = CBLDatabaseConfiguration Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef DartCBLDatabase_Config = CBLDatabaseConfiguration Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef NativeCBLDatabase_CreateValueIndex = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_CreateValueIndex = bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_CreateFullTextIndex = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_CreateFullTextIndex = bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DeleteIndex = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db, FLString name, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DeleteIndex = bool Function(
    ffi.Pointer<CBLDatabase> db, FLString name, ffi.Pointer<CBLError> outError);
typedef FLArray = ffi.Pointer<_FLArray>;
typedef NativeCBLDatabase_GetIndexNames = FLArray Function(
    ffi.Pointer<CBLDatabase> db);
typedef DartCBLDatabase_GetIndexNames = FLArray Function(
    ffi.Pointer<CBLDatabase> db);

/// A default collection change listener callback, invoked after one or more documents in the default collection are changed on disk.
/// @warning  By default, this listener may be called on arbitrary threads. If your code isn't
/// prepared for that, you may want to use \ref CBLDatabase_BufferNotifications
/// so that listeners will be called in a safe context.
/// @warning  <b>Deprecated :</b> CBLCollectionChangeListener instead.
/// @param context  An arbitrary value given when the callback was registered.
/// @param db  The database that changed.
/// @param numDocs  The number of documents that changed (size of the `docIDs` array)
/// @param docIDs  The IDs of the documents that changed, as a C array of `numDocs` C strings.
typedef CBLDatabaseChangeListener
    = ffi.Pointer<ffi.NativeFunction<CBLDatabaseChangeListenerFunction>>;
typedef CBLDatabaseChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDatabase> db,
    ffi.UnsignedInt numDocs,
    ffi.Pointer<FLString> docIDs);
typedef DartCBLDatabaseChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDatabase> db,
    int numDocs,
    ffi.Pointer<FLString> docIDs);
typedef NativeCBLDatabase_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLDatabase> db,
        CBLDatabaseChangeListener listener, ffi.Pointer<ffi.Void> context);
typedef DartCBLDatabase_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLDatabase> db,
        CBLDatabaseChangeListener listener, ffi.Pointer<ffi.Void> context);

/// Callback indicating that the database (or an object belonging to it) is ready to call one
/// or more listeners. You should call \ref CBLDatabase_SendNotifications at your earliest
/// convenience, in the context (thread, dispatch queue, etc.) you want them to run.
/// @note  This callback is called _only once_ until the next time \ref CBLDatabase_SendNotifications
/// is called. If you don't respond by (sooner or later) calling that function,
/// you will not be informed that any listeners are ready.
/// @warning  This can be called from arbitrary threads. It should do as little work as
/// possible, just scheduling a future call to \ref CBLDatabase_SendNotifications.
typedef CBLNotificationsReadyCallback
    = ffi.Pointer<ffi.NativeFunction<CBLNotificationsReadyCallbackFunction>>;
typedef CBLNotificationsReadyCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDatabase> db);
typedef DartCBLNotificationsReadyCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDatabase> db);
typedef NativeCBLDatabase_BufferNotifications = ffi.Void Function(
    ffi.Pointer<CBLDatabase> db,
    CBLNotificationsReadyCallback callback,
    ffi.Pointer<ffi.Void> context);
typedef DartCBLDatabase_BufferNotifications = void Function(
    ffi.Pointer<CBLDatabase> db,
    CBLNotificationsReadyCallback callback,
    ffi.Pointer<ffi.Void> context);
typedef NativeCBLDatabase_SendNotifications = ffi.Void Function(
    ffi.Pointer<CBLDatabase> db);
typedef DartCBLDatabase_SendNotifications = void Function(
    ffi.Pointer<CBLDatabase> db);

final class CBLEndpoint extends ffi.Opaque {}

typedef NativeCBLEndpoint_CreateWithURL = ffi.Pointer<CBLEndpoint> Function(
    FLString url, ffi.Pointer<CBLError> outError);
typedef DartCBLEndpoint_CreateWithURL = ffi.Pointer<CBLEndpoint> Function(
    FLString url, ffi.Pointer<CBLError> outError);
typedef NativeCBLEndpoint_Free = ffi.Void Function(
    ffi.Pointer<CBLEndpoint> arg0);
typedef DartCBLEndpoint_Free = void Function(ffi.Pointer<CBLEndpoint> arg0);

final class CBLAuthenticator extends ffi.Opaque {}

typedef NativeCBLAuth_CreatePassword = ffi.Pointer<CBLAuthenticator> Function(
    FLString username, FLString password);
typedef DartCBLAuth_CreatePassword = ffi.Pointer<CBLAuthenticator> Function(
    FLString username, FLString password);
typedef NativeCBLAuth_CreateSession = ffi.Pointer<CBLAuthenticator> Function(
    FLString sessionID, FLString cookieName);
typedef DartCBLAuth_CreateSession = ffi.Pointer<CBLAuthenticator> Function(
    FLString sessionID, FLString cookieName);
typedef NativeCBLAuth_Free = ffi.Void Function(
    ffi.Pointer<CBLAuthenticator> arg0);
typedef DartCBLAuth_Free = void Function(ffi.Pointer<CBLAuthenticator> arg0);

/// Conflict-resolution callback for use in replications. This callback will be invoked
/// when the replicator finds a newer server-side revision of a document that also has local
/// changes. The local and remote changes must be resolved before the document can be pushed
/// to the server.
/// @note  Any new CBLBlob objects set to the resolved document returned by the callback must
/// not be released. They need to be retained for installation while the resolved document
/// is being saved into the database, and the replicator will be responsible for
/// releasing them after they are installed.
/// @warning  This callback will be called on a background thread managed by the replicator.
/// It must pay attention to thread-safety. However, unlike a filter callback,
/// it does not need to return quickly. If it needs to prompt for user input,
/// that's OK.
/// @param context  The `context` field of the \ref CBLReplicatorConfiguration.
/// @param documentID  The ID of the conflicted document.
/// @param localDocument  The current revision of the document in the local database,
/// or NULL if the local document has been deleted.
/// @param remoteDocument  The revision of the document found on the server,
/// or NULL if the document has been deleted on the server.
/// @return  The resolved document to save locally (and push, if the replicator is pushing.)
/// This can be the same as \p localDocument or \p remoteDocument, or you can create
/// a mutable copy of either one and modify it appropriately.
/// Or return NULL if the resolution is to delete the document.
typedef CBLConflictResolver
    = ffi.Pointer<ffi.NativeFunction<CBLConflictResolverFunction>>;
typedef CBLConflictResolverFunction = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<ffi.Void> context,
    FLString documentID,
    ffi.Pointer<CBLDocument> localDocument,
    ffi.Pointer<CBLDocument> remoteDocument);

/// Proxy settings for the replicator.
final class CBLProxySettings extends ffi.Struct {
  /// < Type of proxy
  @CBLProxyType()
  external int type;

  /// < Proxy server hostname or IP address
  external FLString hostname;

  /// < Proxy server port
  @ffi.Uint16()
  external int port;

  /// < Username for proxy auth (optional)
  external FLString username;

  /// < Password for proxy auth
  external FLString password;
}

/// Types of proxy servers, for CBLProxySettings.
typedef CBLProxyType = ffi.Uint8;
typedef DartCBLProxyType = int;

/// The collection and the configuration that can be configured specifically for the replication.
final class CBLReplicationCollection extends ffi.Struct {
  /// < The collection.
  external ffi.Pointer<CBLCollection> collection;

  /// < Optional conflict-resolver callback
  external CBLConflictResolver conflictResolver;

  /// < Optional callback to filter which docs are pushed
  external CBLReplicationFilter pushFilter;

  /// < Optional callback to validate incoming docs.
  external CBLReplicationFilter pullFilter;

  /// Optional set of channels to pull from.
  /// @note Channels are not supported in Peer-to-Peer and Database-to-Database replication.
  external FLArray channels;

  /// < Optional set of document IDs to replicate
  external FLArray documentIDs;
}

/// A callback that can decide whether a particular document should be pushed or pulled.
/// @warning  This callback will be called on a background thread managed by the replicator.
/// It must pay attention to thread-safety. It should not take a long time to return,
/// or it will slow down the replicator.
/// @param context  The `context` field of the \ref CBLReplicatorConfiguration.
/// @param document  The document in question.
/// @param flags  Indicates whether the document was deleted or removed.
/// @return  True if the document should be replicated, false to skip it.
typedef CBLReplicationFilter
    = ffi.Pointer<ffi.NativeFunction<CBLReplicationFilterFunction>>;
typedef CBLReplicationFilterFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDocument> document,
    CBLDocumentFlags flags);
typedef DartCBLReplicationFilterFunction = bool Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDocument> document,
    DartCBLDocumentFlags flags);

/// Flags describing a replicated document.
typedef CBLDocumentFlags = ffi.UnsignedInt;
typedef DartCBLDocumentFlags = int;

/// The configuration of a replicator.
final class CBLReplicatorConfiguration extends ffi.Struct {
  /// The database to replicate. When setting the database, ONLY the default collection will be used for replication.
  /// (Required if collections is not set)
  /// @warning  <b>Deprecated :</b> Use collections instead.
  external ffi.Pointer<CBLDatabase> database;

  /// <
  external ffi.Pointer<CBLEndpoint> endpoint;

  /// Push, pull or both. The default value is \ref kCBLDefaultReplicatorType.
  @CBLReplicatorType()
  external int replicatorType;

  /// Continuous replication?. The default value is \ref kCBLDefaultReplicatorContinuous.
  @ffi.Bool()
  external bool continuous;

  /// If auto purge is active, then the library will automatically purge any documents that
  /// the replicating user loses access to via the Sync Function on Sync Gateway.
  /// If disableAutoPurge is true, this behavior is disabled and an access removed
  /// event will be sent to any document listeners that are active on the replicator.
  /// The default value is \ref kCBLDefaultReplicatorDisableAutoPurge.
  ///
  /// \note Auto Purge will not be performed when documentIDs filter is specified.
  @ffi.Bool()
  external bool disableAutoPurge;

  /// Max retry attempts where the initial connect to replicate counts toward the given value.
  /// The default value is  \ref kCBLDefaultReplicatorMaxAttemptsSingleShot for a one-shot replicator
  /// and \ref kCBLDefaultReplicatorMaxAttemptsContinuous for a continuous replicator.
  /// Specify 1 means there will be no retry after the first attempt.
  @ffi.UnsignedInt()
  external int maxAttempts;

  /// Max wait time between retry attempts in seconds.
  /// The default value \ref kCBLDefaultReplicatorMaxAttemptsWaitTime.
  @ffi.UnsignedInt()
  external int maxAttemptWaitTime;

  /// The heartbeat interval in seconds.
  /// The default value is \ref kCBLDefaultReplicatorHeartbeat.
  @ffi.UnsignedInt()
  external int heartbeat;

  /// < Authentication credentials, if needed
  external ffi.Pointer<CBLAuthenticator> authenticator;

  /// < HTTP client proxy settings
  external ffi.Pointer<CBLProxySettings> proxy;

  /// < Extra HTTP headers to add to the WebSocket request
  external FLDict headers;

  /// An X.509 cert (PEM or DER) to "pin" for TLS connections. The pinned cert will be evaluated against any certs
  /// in a cert chain, and the cert chain will be valid only if the cert chain contains the pinned cert.
  external FLSlice pinnedServerCertificate;

  /// < Set of anchor certs (PEM format)
  external FLSlice trustedRootCertificates;

  /// Optional set of channels to pull from when replicating with the default collection.
  /// @note This property can only be used when setting the config object with the database instead of collections.
  /// @note Channels are not supported in Peer-to-Peer and Database-to-Database replication.
  /// @warning  <b>Deprecated :</b> Use CBLReplicationCollection.channels instead.
  external FLArray channels;

  /// Optional set of document IDs to replicate when replicating with the default collection.
  /// @note This property can only be used when setting the config object with the database instead of collections.
  /// @warning  <b>Deprecated :</b> Use CBLReplicationCollection.documentIDs instead.
  external FLArray documentIDs;

  /// Optional callback to filter which docs are pushed when replicating with the default collection.
  /// @note This property can only be used when setting the config object with the database instead of collections.
  /// @warning  <b>Deprecated :</b> Use CBLReplicationCollection.pushFilter instead.
  external CBLReplicationFilter pushFilter;

  /// Optional callback to validate incoming docs when replicating with the default collection.
  /// @note This property can only be used when setting the config object with the database instead of collections.
  /// @warning  <b>Deprecated :</b> Use CBLReplicationCollection.pullFilter instead.
  external CBLReplicationFilter pullFilter;

  /// Optional conflict-resolver callback.
  /// @note This property can only be used when setting the config object with the database instead of collections.
  /// @warning  <b>Deprecated :</b> Use CBLReplicationCollection.conflictResolver instead.
  external CBLConflictResolver conflictResolver;

  /// < Arbitrary value that will be passed to callbacks
  external ffi.Pointer<ffi.Void> context;

  /// The collections to replicate with the target's endpoint (Required if the database is not set).
  external ffi.Pointer<CBLReplicationCollection> collections;

  /// The number of collections (Required if the database is not set
  @ffi.Size()
  external int collectionCount;

  /// The option to remove the restriction that does not allow the replicator to save the parent-domain
  /// cookies, the cookies whose domains are the parent domain of the remote host, from the HTTP
  /// response. For example, when the option is set to true, the cookies whose domain are .foo.com
  /// returned by bar.foo.com host will be permitted to save. This is only recommended if the host
  /// issuing the cookie is well trusted.
  ///
  /// This option is disabled by default (see \ref kCBLDefaultReplicatorAcceptParentCookies) which means
  /// that the parent-domain cookies are not permitted to save by default.
  @ffi.Bool()
  external bool acceptParentDomainCookies;
}

/// Direction of replication: push, pull, or both.
typedef CBLReplicatorType = ffi.Uint8;
typedef DartCBLReplicatorType = int;
typedef NativeCBLReplicator_Create = ffi.Pointer<CBLReplicator> Function(
    ffi.Pointer<CBLReplicatorConfiguration> arg0,
    ffi.Pointer<CBLError> outError);
typedef DartCBLReplicator_Create = ffi.Pointer<CBLReplicator> Function(
    ffi.Pointer<CBLReplicatorConfiguration> arg0,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLReplicator_Config = ffi.Pointer<CBLReplicatorConfiguration>
    Function(ffi.Pointer<CBLReplicator> arg0);
typedef DartCBLReplicator_Config = ffi.Pointer<CBLReplicatorConfiguration>
    Function(ffi.Pointer<CBLReplicator> arg0);
typedef NativeCBLReplicator_Start = ffi.Void Function(
    ffi.Pointer<CBLReplicator> replicator, ffi.Bool resetCheckpoint);
typedef DartCBLReplicator_Start = void Function(
    ffi.Pointer<CBLReplicator> replicator, bool resetCheckpoint);
typedef NativeCBLReplicator_Stop = ffi.Void Function(
    ffi.Pointer<CBLReplicator> arg0);
typedef DartCBLReplicator_Stop = void Function(ffi.Pointer<CBLReplicator> arg0);
typedef NativeCBLReplicator_SetHostReachable = ffi.Void Function(
    ffi.Pointer<CBLReplicator> arg0, ffi.Bool reachable);
typedef DartCBLReplicator_SetHostReachable = void Function(
    ffi.Pointer<CBLReplicator> arg0, bool reachable);
typedef NativeCBLReplicator_SetSuspended = ffi.Void Function(
    ffi.Pointer<CBLReplicator> repl, ffi.Bool suspended);
typedef DartCBLReplicator_SetSuspended = void Function(
    ffi.Pointer<CBLReplicator> repl, bool suspended);

/// A fractional progress value, ranging from 0.0 to 1.0 as replication progresses.
/// The value is very approximate and may bounce around during replication; making it more
/// accurate would require slowing down the replicator and incurring more load on the server.
/// It's fine to use in a progress bar, though.
final class CBLReplicatorProgress extends ffi.Struct {
  /// <Very-approximate fractional completion, from 0.0 to 1.0
  @ffi.Float()
  external double complete;

  /// < Number of documents transferred so far
  @ffi.Uint64()
  external int documentCount;
}

/// A replicator's current status.
final class CBLReplicatorStatus extends ffi.Struct {
  /// < Current state
  @CBLReplicatorActivityLevel()
  external int activity;

  /// < Approximate fraction complete
  external CBLReplicatorProgress progress;

  /// < Error, if any
  external CBLError error;
}

/// The possible states a replicator can be in during its lifecycle.
typedef CBLReplicatorActivityLevel = ffi.Uint8;
typedef DartCBLReplicatorActivityLevel = int;
typedef NativeCBLReplicator_Status = CBLReplicatorStatus Function(
    ffi.Pointer<CBLReplicator> arg0);
typedef DartCBLReplicator_Status = CBLReplicatorStatus Function(
    ffi.Pointer<CBLReplicator> arg0);
typedef NativeCBLReplicator_PendingDocumentIDs = FLDict Function(
    ffi.Pointer<CBLReplicator> arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLReplicator_PendingDocumentIDs = FLDict Function(
    ffi.Pointer<CBLReplicator> arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLReplicator_IsDocumentPending = ffi.Bool Function(
    ffi.Pointer<CBLReplicator> repl,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLReplicator_IsDocumentPending = bool Function(
    ffi.Pointer<CBLReplicator> repl,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLReplicator_PendingDocumentIDs2 = FLDict Function(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError);
typedef DartCBLReplicator_PendingDocumentIDs2 = FLDict Function(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLReplicator_IsDocumentPending2 = ffi.Bool Function(
    ffi.Pointer<CBLReplicator> repl,
    FLString docID,
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError);
typedef DartCBLReplicator_IsDocumentPending2 = bool Function(
    ffi.Pointer<CBLReplicator> repl,
    FLString docID,
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError);

/// A callback that notifies you when the replicator's status changes.
/// @note This callback will be called on a background thread managed by the replicator.
/// It must pay attention to thread-safety. It should not take a long time to return,
/// or it will slow down the replicator.
/// @param context  The value given when the listener was added.
/// @param replicator  The replicator.
/// @param status  The replicator's status.
typedef CBLReplicatorChangeListener
    = ffi.Pointer<ffi.NativeFunction<CBLReplicatorChangeListenerFunction>>;
typedef CBLReplicatorChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLReplicator> replicator,
    ffi.Pointer<CBLReplicatorStatus> status);
typedef DartCBLReplicatorChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLReplicator> replicator,
    ffi.Pointer<CBLReplicatorStatus> status);
typedef NativeCBLReplicator_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLReplicator> arg0,
        CBLReplicatorChangeListener arg1, ffi.Pointer<ffi.Void> context);
typedef DartCBLReplicator_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLReplicator> arg0,
        CBLReplicatorChangeListener arg1, ffi.Pointer<ffi.Void> context);

/// Information about a document that's been pushed or pulled.
final class CBLReplicatedDocument extends ffi.Struct {
  /// < The document ID.
  external FLString ID;

  /// < Indicates whether the document was deleted or removed.
  @CBLDocumentFlags()
  external int flags;

  /// < If the code is nonzero, the document failed to replicate.
  external CBLError error;

  /// <The scope name of the collection
  external FLString scope;

  /// <The collection name.
  external FLString collection;
}

/// A callback that notifies you when documents are replicated.
/// @note This callback will be called on a background thread managed by the replicator.
/// It must pay attention to thread-safety. It should not take a long time to return,
/// or it will slow down the replicator.
/// @param context  The value given when the listener was added.
/// @param replicator  The replicator.
/// @param isPush  True if the document(s) were pushed, false if pulled.
/// @param numDocuments  The number of documents reported by this callback.
/// @param documents  An array with information about each document.
typedef CBLDocumentReplicationListener
    = ffi.Pointer<ffi.NativeFunction<CBLDocumentReplicationListenerFunction>>;
typedef CBLDocumentReplicationListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLReplicator> replicator,
    ffi.Bool isPush,
    ffi.UnsignedInt numDocuments,
    ffi.Pointer<CBLReplicatedDocument> documents);
typedef DartCBLDocumentReplicationListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLReplicator> replicator,
    bool isPush,
    int numDocuments,
    ffi.Pointer<CBLReplicatedDocument> documents);
typedef NativeCBLReplicator_AddDocumentReplicationListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLReplicator> arg0,
        CBLDocumentReplicationListener arg1, ffi.Pointer<ffi.Void> context);
typedef DartCBLReplicator_AddDocumentReplicationListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLReplicator> arg0,
        CBLDocumentReplicationListener arg1, ffi.Pointer<ffi.Void> context);

/// Subsystems that log information.
typedef CBLLogDomain = ffi.Uint8;
typedef DartCBLLogDomain = int;

/// Levels of log messages. Higher values are more important/severe. Each level includes the lower ones.
typedef CBLLogLevel = ffi.Uint8;
typedef DartCBLLogLevel = int;
typedef NativeCBL_Log = ffi.Void Function(
    CBLLogDomain domain, CBLLogLevel level, ffi.Pointer<ffi.Char> format);
typedef DartCBL_Log = void Function(
    int domain, int level, ffi.Pointer<ffi.Char> format);
typedef NativeCBL_LogMessage = ffi.Void Function(
    CBLLogDomain domain, CBLLogLevel level, FLSlice message);
typedef DartCBL_LogMessage = void Function(
    int domain, int level, FLSlice message);
typedef NativeCBLLog_ConsoleLevel = CBLLogLevel Function();
typedef DartCBLLog_ConsoleLevel = int Function();
typedef NativeCBLLog_SetConsoleLevel = ffi.Void Function(CBLLogLevel arg0);
typedef DartCBLLog_SetConsoleLevel = void Function(int arg0);
typedef NativeCBLLog_CallbackLevel = CBLLogLevel Function();
typedef DartCBLLog_CallbackLevel = int Function();
typedef NativeCBLLog_SetCallbackLevel = ffi.Void Function(CBLLogLevel arg0);
typedef DartCBLLog_SetCallbackLevel = void Function(int arg0);

/// A logging callback that the application can register.
/// @param domain  The domain of the message
/// @param level  The severity level of the message.
/// @param message  The actual formatted message.
typedef CBLLogCallback
    = ffi.Pointer<ffi.NativeFunction<CBLLogCallbackFunction>>;
typedef CBLLogCallbackFunction = ffi.Void Function(
    CBLLogDomain domain, CBLLogLevel level, FLString message);
typedef DartCBLLogCallbackFunction = void Function(
    DartCBLLogDomain domain, DartCBLLogLevel level, FLString message);
typedef NativeCBLLog_Callback = CBLLogCallback Function();
typedef DartCBLLog_Callback = CBLLogCallback Function();
typedef NativeCBLLog_SetCallback = ffi.Void Function(CBLLogCallback callback);
typedef DartCBLLog_SetCallback = void Function(CBLLogCallback callback);

/// The properties for configuring logging to files.
/// @warning `usePlaintext` results in significantly larger log files and higher CPU usage that may slow
/// down your app; we recommend turning it off in production.
final class CBLLogFileConfiguration extends ffi.Struct {
  /// < The minimum level of message to write (Required).
  @CBLLogLevel()
  external int level;

  /// < The directory where log files will be created (Required).
  external FLString directory;

  /// Max number of older log files to keep (in addition to current one.)
  /// The default is \ref kCBLDefaultLogFileMaxRotateCount.
  @ffi.Uint32()
  external int maxRotateCount;

  /// The size in bytes at which a file will be rotated out (best effort).
  /// The default is \ref kCBLDefaultLogFileMaxSize.
  @ffi.Size()
  external int maxSize;

  /// Whether or not to log in plaintext (as opposed to binary.) Plaintext logging is slower and bigger.
  /// The default is \ref kCBLDefaultLogFileUsePlaintext.
  @ffi.Bool()
  external bool usePlaintext;
}

typedef NativeCBLLog_FileConfig = ffi.Pointer<CBLLogFileConfiguration>
    Function();
typedef DartCBLLog_FileConfig = ffi.Pointer<CBLLogFileConfiguration> Function();
typedef NativeCBLLog_SetFileConfig = ffi.Bool Function(
    CBLLogFileConfiguration arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLLog_SetFileConfig = bool Function(
    CBLLogFileConfiguration arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_CreateQuery = ffi.Pointer<CBLQuery> Function(
    ffi.Pointer<CBLDatabase> db,
    CBLQueryLanguage language,
    FLString queryString,
    ffi.Pointer<ffi.Int> outErrorPos,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_CreateQuery = ffi.Pointer<CBLQuery> Function(
    ffi.Pointer<CBLDatabase> db,
    int language,
    FLString queryString,
    ffi.Pointer<ffi.Int> outErrorPos,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLQuery_SetParameters = ffi.Void Function(
    ffi.Pointer<CBLQuery> query, FLDict parameters);
typedef DartCBLQuery_SetParameters = void Function(
    ffi.Pointer<CBLQuery> query, FLDict parameters);
typedef NativeCBLQuery_Parameters = FLDict Function(
    ffi.Pointer<CBLQuery> query);
typedef DartCBLQuery_Parameters = FLDict Function(ffi.Pointer<CBLQuery> query);
typedef NativeCBLQuery_Execute = ffi.Pointer<CBLResultSet> Function(
    ffi.Pointer<CBLQuery> arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLQuery_Execute = ffi.Pointer<CBLResultSet> Function(
    ffi.Pointer<CBLQuery> arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLQuery_Explain = FLSliceResult Function(
    ffi.Pointer<CBLQuery> arg0);
typedef DartCBLQuery_Explain = FLSliceResult Function(
    ffi.Pointer<CBLQuery> arg0);
typedef NativeCBLQuery_ColumnCount = ffi.UnsignedInt Function(
    ffi.Pointer<CBLQuery> arg0);
typedef DartCBLQuery_ColumnCount = int Function(ffi.Pointer<CBLQuery> arg0);
typedef NativeCBLQuery_ColumnName = FLSlice Function(
    ffi.Pointer<CBLQuery> arg0, ffi.UnsignedInt columnIndex);
typedef DartCBLQuery_ColumnName = FLSlice Function(
    ffi.Pointer<CBLQuery> arg0, int columnIndex);
typedef NativeCBLResultSet_Next = ffi.Bool Function(
    ffi.Pointer<CBLResultSet> arg0);
typedef DartCBLResultSet_Next = bool Function(ffi.Pointer<CBLResultSet> arg0);
typedef FLValue = ffi.Pointer<_FLValue>;

final class _FLValue extends ffi.Opaque {}

typedef NativeCBLResultSet_ValueAtIndex = FLValue Function(
    ffi.Pointer<CBLResultSet> arg0, ffi.UnsignedInt index);
typedef DartCBLResultSet_ValueAtIndex = FLValue Function(
    ffi.Pointer<CBLResultSet> arg0, int index);
typedef NativeCBLResultSet_ValueForKey = FLValue Function(
    ffi.Pointer<CBLResultSet> arg0, FLString key);
typedef DartCBLResultSet_ValueForKey = FLValue Function(
    ffi.Pointer<CBLResultSet> arg0, FLString key);
typedef NativeCBLResultSet_ResultArray = FLArray Function(
    ffi.Pointer<CBLResultSet> arg0);
typedef DartCBLResultSet_ResultArray = FLArray Function(
    ffi.Pointer<CBLResultSet> arg0);
typedef NativeCBLResultSet_ResultDict = FLDict Function(
    ffi.Pointer<CBLResultSet> arg0);
typedef DartCBLResultSet_ResultDict = FLDict Function(
    ffi.Pointer<CBLResultSet> arg0);
typedef NativeCBLResultSet_GetQuery = ffi.Pointer<CBLQuery> Function(
    ffi.Pointer<CBLResultSet> rs);
typedef DartCBLResultSet_GetQuery = ffi.Pointer<CBLQuery> Function(
    ffi.Pointer<CBLResultSet> rs);

/// A callback to be invoked after the query's results have changed.
/// The actual result set can be obtained by calling \ref CBLQuery_CopyCurrentResults, either during
/// the callback or at any time thereafter.
/// @warning  By default, this listener may be called on arbitrary threads. If your code isn't
/// prepared for that, you may want to use \ref CBLDatabase_BufferNotifications
/// so that listeners will be called in a safe context.
/// @param context  The same `context` value that you passed when adding the listener.
/// @param query  The query that triggered the listener.
/// @param token  The token for obtaining the query results by calling \ref CBLQuery_CopyCurrentResults.
typedef CBLQueryChangeListener
    = ffi.Pointer<ffi.NativeFunction<CBLQueryChangeListenerFunction>>;
typedef CBLQueryChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> token);
typedef DartCBLQueryChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> token);
typedef NativeCBLQuery_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLQuery> query,
        CBLQueryChangeListener listener, ffi.Pointer<ffi.Void> context);
typedef DartCBLQuery_AddChangeListener = ffi.Pointer<CBLListenerToken> Function(
    ffi.Pointer<CBLQuery> query,
    CBLQueryChangeListener listener,
    ffi.Pointer<ffi.Void> context);
typedef NativeCBLQuery_CopyCurrentResults = ffi.Pointer<CBLResultSet> Function(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> listener,
    ffi.Pointer<CBLError> outError);
typedef DartCBLQuery_CopyCurrentResults = ffi.Pointer<CBLResultSet> Function(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> listener,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLQueryIndex_Name = FLString Function(
    ffi.Pointer<CBLQueryIndex> index);
typedef DartCBLQueryIndex_Name = FLString Function(
    ffi.Pointer<CBLQueryIndex> index);
typedef NativeCBLQueryIndex_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLQueryIndex> index);
typedef DartCBLQueryIndex_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLQueryIndex> index);
typedef NativeCBLScope_Name = FLString Function(ffi.Pointer<CBLScope> scope);
typedef DartCBLScope_Name = FLString Function(ffi.Pointer<CBLScope> scope);
typedef NativeCBLScope_Database = ffi.Pointer<CBLDatabase> Function(
    ffi.Pointer<CBLScope> scope);
typedef DartCBLScope_Database = ffi.Pointer<CBLDatabase> Function(
    ffi.Pointer<CBLScope> scope);
typedef NativeCBLScope_CollectionNames = FLMutableArray Function(
    ffi.Pointer<CBLScope> scope, ffi.Pointer<CBLError> outError);
typedef DartCBLScope_CollectionNames = FLMutableArray Function(
    ffi.Pointer<CBLScope> scope, ffi.Pointer<CBLError> outError);
typedef NativeCBLScope_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLScope> scope,
    FLString collectionName,
    ffi.Pointer<CBLError> outError);
typedef DartCBLScope_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLScope> scope,
    FLString collectionName,
    ffi.Pointer<CBLError> outError);
typedef NativeFLSlice_Equal = ffi.Bool Function(FLSlice a, FLSlice b);
typedef DartFLSlice_Equal = bool Function(FLSlice a, FLSlice b);
typedef NativeFLSlice_Compare = ffi.Int Function(FLSlice arg0, FLSlice arg1);
typedef DartFLSlice_Compare = int Function(FLSlice arg0, FLSlice arg1);
typedef NativeFLSlice_Hash = ffi.Uint32 Function(FLSlice s);
typedef DartFLSlice_Hash = int Function(FLSlice s);
typedef NativeFLSlice_ToCString = ffi.Bool Function(
    FLSlice s, ffi.Pointer<ffi.Char> buffer, ffi.Size capacity);
typedef DartFLSlice_ToCString = bool Function(
    FLSlice s, ffi.Pointer<ffi.Char> buffer, int capacity);
typedef NativeFLSliceResult_New = FLSliceResult Function(ffi.Size arg0);
typedef DartFLSliceResult_New = FLSliceResult Function(int arg0);
typedef NativeFLSlice_Copy = FLSliceResult Function(FLSlice arg0);
typedef DartFLSlice_Copy = FLSliceResult Function(FLSlice arg0);
typedef NativeFLBuf_Retain = ffi.Void Function(ffi.Pointer<ffi.Void> arg0);
typedef DartFLBuf_Retain = void Function(ffi.Pointer<ffi.Void> arg0);
typedef NativeFLBuf_Release = ffi.Void Function(ffi.Pointer<ffi.Void> arg0);
typedef DartFLBuf_Release = void Function(ffi.Pointer<ffi.Void> arg0);
typedef NativeFL_WipeMemory = ffi.Void Function(
    ffi.Pointer<ffi.Void> dst, ffi.Size size);
typedef DartFL_WipeMemory = void Function(ffi.Pointer<ffi.Void> dst, int size);

final class _FLEncoder extends ffi.Opaque {}

final class _FLDoc extends ffi.Opaque {}

final class _FLSharedKeys extends ffi.Opaque {}

/// Error codes returned from some API calls.
abstract class FLError {
  static const int kFLNoError = 0;
  static const int kFLMemoryError = 1;
  static const int kFLOutOfRange = 2;
  static const int kFLInvalidData = 3;
  static const int kFLEncodeError = 4;
  static const int kFLJSONError = 5;
  static const int kFLUnknownValue = 6;
  static const int kFLInternalError = 7;
  static const int kFLNotFound = 8;
  static const int kFLSharedKeysStateError = 9;
  static const int kFLPOSIXError = 10;
  static const int kFLUnsupported = 11;
}

/// Specifies whether not input data is trusted to be 100% valid Fleece.
abstract class FLTrust {
  /// Input data is not trusted to be valid, and will be fully validated by the API call.
  static const int kFLUntrusted = 0;

  /// Input data is trusted to be valid. The API will perform only minimal validation when
  /// reading it. This is faster than kFLUntrusted, but should only be used if
  /// the data was generated by a trusted encoder and has not been altered or corrupted. For
  /// example, this can be used to parse Fleece data previously stored by your code in local
  /// storage.
  /// If invalid data is read by this call, subsequent calls to Value accessor functions can
  /// crash or return bogus results (including data from arbitrary memory locations.)
  static const int kFLTrusted = 1;
}

/// A point in time, expressed as milliseconds since the Unix epoch (1-1-1970 midnight UTC.)
typedef FLTimestamp = ffi.Int64;
typedef DartFLTimestamp = int;
typedef NativeFLTimestamp_Now = FLTimestamp Function();
typedef DartFLTimestamp_Now = int Function();
typedef NativeFLTimestamp_ToString = FLStringResult Function(
    FLTimestamp timestamp, ffi.Bool asUTC);
typedef DartFLTimestamp_ToString = FLStringResult Function(
    int timestamp, bool asUTC);
typedef NativeFLTimestamp_FromString = FLTimestamp Function(FLString str);
typedef DartFLTimestamp_FromString = int Function(FLString str);
typedef NativeFLArray_Count = ffi.Uint32 Function(FLArray arg0);
typedef DartFLArray_Count = int Function(FLArray arg0);
typedef NativeFLArray_IsEmpty = ffi.Bool Function(FLArray arg0);
typedef DartFLArray_IsEmpty = bool Function(FLArray arg0);
typedef NativeFLArray_AsMutable = FLMutableArray Function(FLArray arg0);
typedef DartFLArray_AsMutable = FLMutableArray Function(FLArray arg0);
typedef NativeFLArray_Get = FLValue Function(FLArray arg0, ffi.Uint32 index);
typedef DartFLArray_Get = FLValue Function(FLArray arg0, int index);

/// Opaque array iterator. Declare one on the stack and pass its address to
/// `FLArrayIteratorBegin`.
final class FLArrayIterator extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _private1;

  @ffi.Uint32()
  external int _private2;

  @ffi.Bool()
  external bool _private3;

  external ffi.Pointer<ffi.Void> _private4;
}

typedef NativeFLArrayIterator_Begin = ffi.Void Function(
    FLArray arg0, ffi.Pointer<FLArrayIterator> arg1);
typedef DartFLArrayIterator_Begin = void Function(
    FLArray arg0, ffi.Pointer<FLArrayIterator> arg1);
typedef NativeFLArrayIterator_GetValue = FLValue Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef DartFLArrayIterator_GetValue = FLValue Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef NativeFLArrayIterator_GetValueAt = FLValue Function(
    ffi.Pointer<FLArrayIterator> arg0, ffi.Uint32 offset);
typedef DartFLArrayIterator_GetValueAt = FLValue Function(
    ffi.Pointer<FLArrayIterator> arg0, int offset);
typedef NativeFLArrayIterator_GetCount = ffi.Uint32 Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef DartFLArrayIterator_GetCount = int Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef NativeFLArrayIterator_Next = ffi.Bool Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef DartFLArrayIterator_Next = bool Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef NativeFLDict_Count = ffi.Uint32 Function(FLDict arg0);
typedef DartFLDict_Count = int Function(FLDict arg0);
typedef NativeFLDict_IsEmpty = ffi.Bool Function(FLDict arg0);
typedef DartFLDict_IsEmpty = bool Function(FLDict arg0);
typedef NativeFLDict_AsMutable = FLMutableDict Function(FLDict arg0);
typedef DartFLDict_AsMutable = FLMutableDict Function(FLDict arg0);
typedef NativeFLDict_Get = FLValue Function(FLDict arg0, FLSlice keyString);
typedef DartFLDict_Get = FLValue Function(FLDict arg0, FLSlice keyString);

/// Opaque dictionary iterator. Declare one on the stack, and pass its address to
/// FLDictIterator_Begin.
final class FLDictIterator extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _private1;

  @ffi.Uint32()
  external int _private2;

  @ffi.Bool()
  external bool _private3;

  external ffi.Pointer<ffi.Void> _private4;

  external ffi.Pointer<ffi.Void> _private5;

  external ffi.Pointer<ffi.Void> _private6;

  external ffi.Pointer<ffi.Void> _private7;

  @ffi.Int()
  external int _private8;
}

typedef NativeFLDictIterator_Begin = ffi.Void Function(
    FLDict arg0, ffi.Pointer<FLDictIterator> arg1);
typedef DartFLDictIterator_Begin = void Function(
    FLDict arg0, ffi.Pointer<FLDictIterator> arg1);
typedef NativeFLDictIterator_GetKey = FLValue Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_GetKey = FLValue Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef NativeFLDictIterator_GetKeyString = FLString Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_GetKeyString = FLString Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef NativeFLDictIterator_GetValue = FLValue Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_GetValue = FLValue Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef NativeFLDictIterator_GetCount = ffi.Uint32 Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_GetCount = int Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef NativeFLDictIterator_Next = ffi.Bool Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_Next = bool Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef NativeFLDictIterator_End = ffi.Void Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_End = void Function(
    ffi.Pointer<FLDictIterator> arg0);

/// Opaque key for a dictionary. You are responsible for creating space for these; they can
/// go on the stack, on the heap, inside other objects, anywhere.
/// Be aware that the lookup operations that use these will write into the struct to store
/// "hints" that speed up future searches.
final class FLDictKey extends ffi.Struct {
  external FLSlice _private1;

  external ffi.Pointer<ffi.Void> _private2;

  @ffi.Uint32()
  external int _private3;

  @ffi.Uint32()
  external int private4;

  @ffi.Bool()
  external bool private5;
}

typedef NativeFLDictKey_Init = FLDictKey Function(FLSlice string);
typedef DartFLDictKey_Init = FLDictKey Function(FLSlice string);
typedef NativeFLDictKey_GetString = FLString Function(
    ffi.Pointer<FLDictKey> arg0);
typedef DartFLDictKey_GetString = FLString Function(
    ffi.Pointer<FLDictKey> arg0);
typedef NativeFLDict_GetWithKey = FLValue Function(
    FLDict arg0, ffi.Pointer<FLDictKey> arg1);
typedef DartFLDict_GetWithKey = FLValue Function(
    FLDict arg0, ffi.Pointer<FLDictKey> arg1);

final class _FLDeepIterator extends ffi.Opaque {}

typedef FLDeepIterator = ffi.Pointer<_FLDeepIterator>;
typedef NativeFLDeepIterator_New = FLDeepIterator Function(FLValue arg0);
typedef DartFLDeepIterator_New = FLDeepIterator Function(FLValue arg0);
typedef NativeFLDeepIterator_Free = ffi.Void Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_Free = void Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetValue = FLValue Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_GetValue = FLValue Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetParent = FLValue Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_GetParent = FLValue Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetKey = FLSlice Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_GetKey = FLSlice Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetIndex = ffi.Uint32 Function(
    FLDeepIterator arg0);
typedef DartFLDeepIterator_GetIndex = int Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetDepth = ffi.Size Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_GetDepth = int Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_SkipChildren = ffi.Void Function(
    FLDeepIterator arg0);
typedef DartFLDeepIterator_SkipChildren = void Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_Next = ffi.Bool Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_Next = bool Function(FLDeepIterator arg0);

final class FLPathComponent extends ffi.Struct {
  /// < Dict key, or kFLSliceNull if none
  external FLSlice key;

  /// < Array index, only if there's no key
  @ffi.Uint32()
  external int index;
}

typedef NativeFLDeepIterator_GetPath = ffi.Void Function(
    FLDeepIterator arg0,
    ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
    ffi.Pointer<ffi.Size> outDepth);
typedef DartFLDeepIterator_GetPath = void Function(
    FLDeepIterator arg0,
    ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
    ffi.Pointer<ffi.Size> outDepth);
typedef NativeFLDeepIterator_GetPathString = FLSliceResult Function(
    FLDeepIterator arg0);
typedef DartFLDeepIterator_GetPathString = FLSliceResult Function(
    FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetJSONPointer = FLSliceResult Function(
    FLDeepIterator arg0);
typedef DartFLDeepIterator_GetJSONPointer = FLSliceResult Function(
    FLDeepIterator arg0);
typedef FLDoc = ffi.Pointer<_FLDoc>;
typedef FLSharedKeys = ffi.Pointer<_FLSharedKeys>;
typedef NativeFLDoc_FromResultData = FLDoc Function(
    FLSliceResult data, ffi.Int32 arg1, FLSharedKeys arg2, FLSlice externData);
typedef DartFLDoc_FromResultData = FLDoc Function(
    FLSliceResult data, int arg1, FLSharedKeys arg2, FLSlice externData);
typedef NativeFLDoc_Release = ffi.Void Function(FLDoc arg0);
typedef DartFLDoc_Release = void Function(FLDoc arg0);
typedef NativeFLDoc_Retain = FLDoc Function(FLDoc arg0);
typedef DartFLDoc_Retain = FLDoc Function(FLDoc arg0);
typedef NativeFLDoc_GetData = FLSlice Function(FLDoc arg0);
typedef DartFLDoc_GetData = FLSlice Function(FLDoc arg0);
typedef NativeFLDoc_GetAllocedData = FLSliceResult Function(FLDoc arg0);
typedef DartFLDoc_GetAllocedData = FLSliceResult Function(FLDoc arg0);
typedef NativeFLDoc_GetRoot = FLValue Function(FLDoc arg0);
typedef DartFLDoc_GetRoot = FLValue Function(FLDoc arg0);
typedef NativeFLDoc_GetSharedKeys = FLSharedKeys Function(FLDoc arg0);
typedef DartFLDoc_GetSharedKeys = FLSharedKeys Function(FLDoc arg0);
typedef NativeFLValue_FindDoc = FLDoc Function(FLValue arg0);
typedef DartFLValue_FindDoc = FLDoc Function(FLValue arg0);
typedef NativeFLDoc_SetAssociated = ffi.Bool Function(
    FLDoc doc, ffi.Pointer<ffi.Void> pointer, ffi.Pointer<ffi.Char> type);
typedef DartFLDoc_SetAssociated = bool Function(
    FLDoc doc, ffi.Pointer<ffi.Void> pointer, ffi.Pointer<ffi.Char> type);
typedef NativeFLDoc_GetAssociated = ffi.Pointer<ffi.Void> Function(
    FLDoc doc, ffi.Pointer<ffi.Char> type);
typedef DartFLDoc_GetAssociated = ffi.Pointer<ffi.Void> Function(
    FLDoc doc, ffi.Pointer<ffi.Char> type);

/// Output formats a FLEncoder can generate.
abstract class FLEncoderFormat {
  /// < Fleece encoding
  static const int kFLEncodeFleece = 0;

  /// < JSON encoding
  static const int kFLEncodeJSON = 1;

  /// < [JSON5](http://json5.org), an extension of JSON with a more readable syntax
  static const int kFLEncodeJSON5 = 2;
}

typedef FLEncoder = ffi.Pointer<_FLEncoder>;
typedef NativeFLEncoder_New = FLEncoder Function();
typedef DartFLEncoder_New = FLEncoder Function();
typedef NativeFLEncoder_NewWithOptions = FLEncoder Function(
    ffi.Int32 format, ffi.Size reserveSize, ffi.Bool uniqueStrings);
typedef DartFLEncoder_NewWithOptions = FLEncoder Function(
    int format, int reserveSize, bool uniqueStrings);
typedef FILE = __sFILE;

final class __sFILE extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _p;

  @ffi.Int()
  external int _r;

  @ffi.Int()
  external int _w;

  @ffi.Short()
  external int _flags;

  @ffi.Short()
  external int _file;

  external __sbuf _bf;

  @ffi.Int()
  external int _lbfsize;

  external ffi.Pointer<ffi.Void> _cookie;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
      _close;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _read;

  external ffi.Pointer<
      ffi.NativeFunction<
          fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>> _seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _write;

  external __sbuf _ub;

  external ffi.Pointer<__sFILEX> _extra;

  @ffi.Int()
  external int _ur;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedChar> _ubuf;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.UnsignedChar> _nbuf;

  external __sbuf _lb;

  @ffi.Int()
  external int _blksize;

  @fpos_t()
  external int _offset;
}

final class __sbuf extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _base;

  @ffi.Int()
  external int _size;
}

typedef fpos_t = __darwin_off_t;
typedef __darwin_off_t = __int64_t;
typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;

final class __sFILEX extends ffi.Opaque {}

typedef NativeFLEncoder_NewWritingToFile = FLEncoder Function(
    ffi.Pointer<FILE> arg0, ffi.Bool uniqueStrings);
typedef DartFLEncoder_NewWritingToFile = FLEncoder Function(
    ffi.Pointer<FILE> arg0, bool uniqueStrings);
typedef NativeFLEncoder_Free = ffi.Void Function(FLEncoder arg0);
typedef DartFLEncoder_Free = void Function(FLEncoder arg0);
typedef NativeFLEncoder_SetSharedKeys = ffi.Void Function(
    FLEncoder arg0, FLSharedKeys arg1);
typedef DartFLEncoder_SetSharedKeys = void Function(
    FLEncoder arg0, FLSharedKeys arg1);
typedef NativeFLEncoder_SetExtraInfo = ffi.Void Function(
    FLEncoder arg0, ffi.Pointer<ffi.Void> info);
typedef DartFLEncoder_SetExtraInfo = void Function(
    FLEncoder arg0, ffi.Pointer<ffi.Void> info);
typedef NativeFLEncoder_GetExtraInfo = ffi.Pointer<ffi.Void> Function(
    FLEncoder arg0);
typedef DartFLEncoder_GetExtraInfo = ffi.Pointer<ffi.Void> Function(
    FLEncoder arg0);
typedef NativeFLEncoder_Reset = ffi.Void Function(FLEncoder arg0);
typedef DartFLEncoder_Reset = void Function(FLEncoder arg0);
typedef NativeFLEncoder_BytesWritten = ffi.Size Function(FLEncoder arg0);
typedef DartFLEncoder_BytesWritten = int Function(FLEncoder arg0);
typedef NativeFLEncoder_WriteNull = ffi.Bool Function(FLEncoder arg0);
typedef DartFLEncoder_WriteNull = bool Function(FLEncoder arg0);
typedef NativeFLEncoder_WriteUndefined = ffi.Bool Function(FLEncoder arg0);
typedef DartFLEncoder_WriteUndefined = bool Function(FLEncoder arg0);
typedef NativeFLEncoder_WriteBool = ffi.Bool Function(
    FLEncoder arg0, ffi.Bool arg1);
typedef DartFLEncoder_WriteBool = bool Function(FLEncoder arg0, bool arg1);
typedef NativeFLEncoder_WriteInt = ffi.Bool Function(
    FLEncoder arg0, ffi.Int64 arg1);
typedef DartFLEncoder_WriteInt = bool Function(FLEncoder arg0, int arg1);
typedef NativeFLEncoder_WriteUInt = ffi.Bool Function(
    FLEncoder arg0, ffi.Uint64 arg1);
typedef DartFLEncoder_WriteUInt = bool Function(FLEncoder arg0, int arg1);
typedef NativeFLEncoder_WriteFloat = ffi.Bool Function(
    FLEncoder arg0, ffi.Float arg1);
typedef DartFLEncoder_WriteFloat = bool Function(FLEncoder arg0, double arg1);
typedef NativeFLEncoder_WriteDouble = ffi.Bool Function(
    FLEncoder arg0, ffi.Double arg1);
typedef DartFLEncoder_WriteDouble = bool Function(FLEncoder arg0, double arg1);
typedef NativeFLEncoder_WriteString = ffi.Bool Function(
    FLEncoder arg0, FLString arg1);
typedef DartFLEncoder_WriteString = bool Function(
    FLEncoder arg0, FLString arg1);
typedef NativeFLEncoder_WriteDateString = ffi.Bool Function(
    FLEncoder encoder, FLTimestamp ts, ffi.Bool asUTC);
typedef DartFLEncoder_WriteDateString = bool Function(
    FLEncoder encoder, int ts, bool asUTC);
typedef NativeFLEncoder_WriteData = ffi.Bool Function(
    FLEncoder arg0, FLSlice arg1);
typedef DartFLEncoder_WriteData = bool Function(FLEncoder arg0, FLSlice arg1);
typedef NativeFLEncoder_WriteValue = ffi.Bool Function(
    FLEncoder arg0, FLValue arg1);
typedef DartFLEncoder_WriteValue = bool Function(FLEncoder arg0, FLValue arg1);
typedef NativeFLEncoder_BeginArray = ffi.Bool Function(
    FLEncoder arg0, ffi.Size reserveCount);
typedef DartFLEncoder_BeginArray = bool Function(
    FLEncoder arg0, int reserveCount);
typedef NativeFLEncoder_EndArray = ffi.Bool Function(FLEncoder arg0);
typedef DartFLEncoder_EndArray = bool Function(FLEncoder arg0);
typedef NativeFLEncoder_BeginDict = ffi.Bool Function(
    FLEncoder arg0, ffi.Size reserveCount);
typedef DartFLEncoder_BeginDict = bool Function(
    FLEncoder arg0, int reserveCount);
typedef NativeFLEncoder_WriteKey = ffi.Bool Function(
    FLEncoder arg0, FLString arg1);
typedef DartFLEncoder_WriteKey = bool Function(FLEncoder arg0, FLString arg1);
typedef NativeFLEncoder_WriteKeyValue = ffi.Bool Function(
    FLEncoder arg0, FLValue arg1);
typedef DartFLEncoder_WriteKeyValue = bool Function(
    FLEncoder arg0, FLValue arg1);
typedef NativeFLEncoder_EndDict = ffi.Bool Function(FLEncoder arg0);
typedef DartFLEncoder_EndDict = bool Function(FLEncoder arg0);
typedef NativeFLEncoder_WriteRaw = ffi.Bool Function(
    FLEncoder arg0, FLSlice arg1);
typedef DartFLEncoder_WriteRaw = bool Function(FLEncoder arg0, FLSlice arg1);
typedef NativeFLEncoder_FinishDoc = FLDoc Function(
    FLEncoder arg0, ffi.Pointer<ffi.Int32> outError);
typedef DartFLEncoder_FinishDoc = FLDoc Function(
    FLEncoder arg0, ffi.Pointer<ffi.Int32> outError);
typedef NativeFLEncoder_Finish = FLSliceResult Function(
    FLEncoder arg0, ffi.Pointer<ffi.Int32> outError);
typedef DartFLEncoder_Finish = FLSliceResult Function(
    FLEncoder arg0, ffi.Pointer<ffi.Int32> outError);
typedef NativeFLEncoder_GetError = ffi.Int32 Function(FLEncoder arg0);
typedef DartFLEncoder_GetError = int Function(FLEncoder arg0);
typedef NativeFLEncoder_GetErrorMessage = ffi.Pointer<ffi.Char> Function(
    FLEncoder arg0);
typedef DartFLEncoder_GetErrorMessage = ffi.Pointer<ffi.Char> Function(
    FLEncoder arg0);
typedef NativeFLValue_ToJSON = FLStringResult Function(FLValue arg0);
typedef DartFLValue_ToJSON = FLStringResult Function(FLValue arg0);
typedef NativeFLValue_ToJSON5 = FLStringResult Function(FLValue arg0);
typedef DartFLValue_ToJSON5 = FLStringResult Function(FLValue arg0);
typedef NativeFLValue_ToJSONX = FLStringResult Function(
    FLValue v, ffi.Bool json5, ffi.Bool canonicalForm);
typedef DartFLValue_ToJSONX = FLStringResult Function(
    FLValue v, bool json5, bool canonicalForm);
typedef NativeFLDoc_FromJSON = FLDoc Function(
    FLSlice json, ffi.Pointer<ffi.Int32> outError);
typedef DartFLDoc_FromJSON = FLDoc Function(
    FLSlice json, ffi.Pointer<ffi.Int32> outError);
typedef NativeFLMutableArray_NewFromJSON = FLMutableArray Function(
    FLString json, ffi.Pointer<ffi.Int32> outError);
typedef DartFLMutableArray_NewFromJSON = FLMutableArray Function(
    FLString json, ffi.Pointer<ffi.Int32> outError);
typedef NativeFLMutableDict_NewFromJSON = FLMutableDict Function(
    FLString json, ffi.Pointer<ffi.Int32> outError);
typedef DartFLMutableDict_NewFromJSON = FLMutableDict Function(
    FLString json, ffi.Pointer<ffi.Int32> outError);
typedef NativeFLEncoder_ConvertJSON = ffi.Bool Function(
    FLEncoder arg0, FLSlice json);
typedef DartFLEncoder_ConvertJSON = bool Function(FLEncoder arg0, FLSlice json);

final class _FLKeyPath extends ffi.Opaque {}

typedef FLKeyPath = ffi.Pointer<_FLKeyPath>;
typedef NativeFLKeyPath_New = FLKeyPath Function(
    FLSlice specifier, ffi.Pointer<ffi.Int32> outError);
typedef DartFLKeyPath_New = FLKeyPath Function(
    FLSlice specifier, ffi.Pointer<ffi.Int32> outError);
typedef NativeFLKeyPath_Free = ffi.Void Function(FLKeyPath arg0);
typedef DartFLKeyPath_Free = void Function(FLKeyPath arg0);
typedef NativeFLKeyPath_Eval = FLValue Function(FLKeyPath arg0, FLValue root);
typedef DartFLKeyPath_Eval = FLValue Function(FLKeyPath arg0, FLValue root);
typedef NativeFLKeyPath_EvalOnce = FLValue Function(
    FLSlice specifier, FLValue root, ffi.Pointer<ffi.Int32> outError);
typedef DartFLKeyPath_EvalOnce = FLValue Function(
    FLSlice specifier, FLValue root, ffi.Pointer<ffi.Int32> outError);
typedef NativeFLKeyPath_ToString = FLStringResult Function(FLKeyPath path);
typedef DartFLKeyPath_ToString = FLStringResult Function(FLKeyPath path);
typedef NativeFLKeyPath_Equals = ffi.Bool Function(
    FLKeyPath path1, FLKeyPath path2);
typedef DartFLKeyPath_Equals = bool Function(FLKeyPath path1, FLKeyPath path2);
typedef NativeFLKeyPath_GetElement = ffi.Bool Function(
    FLKeyPath arg0,
    ffi.Size i,
    ffi.Pointer<FLSlice> outDictKey,
    ffi.Pointer<ffi.Int32> outArrayIndex);
typedef DartFLKeyPath_GetElement = bool Function(FLKeyPath arg0, int i,
    ffi.Pointer<FLSlice> outDictKey, ffi.Pointer<ffi.Int32> outArrayIndex);

/// Types of Fleece values. Basically JSON, with the addition of Data (raw blob).
abstract class FLValueType {
  /// < Type of a NULL pointer, i.e. no such value, like JSON `undefined`.
  /// Also the type of \ref kFLUndefinedValue, and of a value created by
  /// \ref FLEncoder_WriteUndefined().
  static const int kFLUndefined = -1;

  /// < Equivalent to a JSON 'null'
  static const int kFLNull = 0;

  /// < A `true` or `false` value
  static const int kFLBoolean = 1;

  /// < A numeric value, either integer or floating-point
  static const int kFLNumber = 2;

  /// < A string
  static const int kFLString = 3;

  /// < Binary data (no JSON equivalent)
  static const int kFLData = 4;

  /// < An array of values
  static const int kFLArray = 5;

  /// < A mapping of strings to values (AKA "object" in JSON.)
  static const int kFLDict = 6;
}

typedef NativeFLValue_GetType = ffi.Int32 Function(FLValue arg0);
typedef DartFLValue_GetType = int Function(FLValue arg0);
typedef NativeFLValue_IsInteger = ffi.Bool Function(FLValue arg0);
typedef DartFLValue_IsInteger = bool Function(FLValue arg0);
typedef NativeFLValue_IsUnsigned = ffi.Bool Function(FLValue arg0);
typedef DartFLValue_IsUnsigned = bool Function(FLValue arg0);
typedef NativeFLValue_IsDouble = ffi.Bool Function(FLValue arg0);
typedef DartFLValue_IsDouble = bool Function(FLValue arg0);
typedef NativeFLValue_AsBool = ffi.Bool Function(FLValue arg0);
typedef DartFLValue_AsBool = bool Function(FLValue arg0);
typedef NativeFLValue_AsInt = ffi.Int64 Function(FLValue arg0);
typedef DartFLValue_AsInt = int Function(FLValue arg0);
typedef NativeFLValue_AsUnsigned = ffi.Uint64 Function(FLValue arg0);
typedef DartFLValue_AsUnsigned = int Function(FLValue arg0);
typedef NativeFLValue_AsFloat = ffi.Float Function(FLValue arg0);
typedef DartFLValue_AsFloat = double Function(FLValue arg0);
typedef NativeFLValue_AsDouble = ffi.Double Function(FLValue arg0);
typedef DartFLValue_AsDouble = double Function(FLValue arg0);
typedef NativeFLValue_AsString = FLString Function(FLValue arg0);
typedef DartFLValue_AsString = FLString Function(FLValue arg0);
typedef NativeFLValue_AsTimestamp = FLTimestamp Function(FLValue arg0);
typedef DartFLValue_AsTimestamp = int Function(FLValue arg0);
typedef NativeFLValue_AsData = FLSlice Function(FLValue arg0);
typedef DartFLValue_AsData = FLSlice Function(FLValue arg0);
typedef NativeFLValue_AsArray = FLArray Function(FLValue arg0);
typedef DartFLValue_AsArray = FLArray Function(FLValue arg0);
typedef NativeFLValue_AsDict = FLDict Function(FLValue arg0);
typedef DartFLValue_AsDict = FLDict Function(FLValue arg0);
typedef NativeFLValue_ToString = FLStringResult Function(FLValue arg0);
typedef DartFLValue_ToString = FLStringResult Function(FLValue arg0);
typedef NativeFLValue_IsEqual = ffi.Bool Function(FLValue v1, FLValue v2);
typedef DartFLValue_IsEqual = bool Function(FLValue v1, FLValue v2);
typedef NativeFLValue_IsMutable = ffi.Bool Function(FLValue arg0);
typedef DartFLValue_IsMutable = bool Function(FLValue arg0);
typedef NativeFLValue_Retain = FLValue Function(FLValue arg0);
typedef DartFLValue_Retain = FLValue Function(FLValue arg0);
typedef NativeFLValue_Release = ffi.Void Function(FLValue arg0);
typedef DartFLValue_Release = void Function(FLValue arg0);

/// Option flags for making mutable copies of values.
abstract class FLCopyFlags {
  /// < Shallow copy. References immutables instead of copying.
  static const int kFLDefaultCopy = 0;

  /// < Deep copy of mutable values
  static const int kFLDeepCopy = 1;

  /// < Makes mutable copies of immutables instead of just refs.
  static const int kFLCopyImmutables = 2;

  /// < Both deep-copy and copy-immutables.
  static const int kFLDeepCopyImmutables = 3;
}

typedef NativeFLArray_MutableCopy = FLMutableArray Function(
    FLArray arg0, ffi.Int32 arg1);
typedef DartFLArray_MutableCopy = FLMutableArray Function(
    FLArray arg0, int arg1);
typedef NativeFLMutableArray_New = FLMutableArray Function();
typedef DartFLMutableArray_New = FLMutableArray Function();
typedef NativeFLMutableArray_GetSource = FLArray Function(FLMutableArray arg0);
typedef DartFLMutableArray_GetSource = FLArray Function(FLMutableArray arg0);
typedef NativeFLMutableArray_IsChanged = ffi.Bool Function(FLMutableArray arg0);
typedef DartFLMutableArray_IsChanged = bool Function(FLMutableArray arg0);
typedef NativeFLMutableArray_SetChanged = ffi.Void Function(
    FLMutableArray arg0, ffi.Bool changed);
typedef DartFLMutableArray_SetChanged = void Function(
    FLMutableArray arg0, bool changed);
typedef NativeFLMutableArray_Insert = ffi.Void Function(
    FLMutableArray array, ffi.Uint32 firstIndex, ffi.Uint32 count);
typedef DartFLMutableArray_Insert = void Function(
    FLMutableArray array, int firstIndex, int count);
typedef NativeFLMutableArray_Remove = ffi.Void Function(
    FLMutableArray array, ffi.Uint32 firstIndex, ffi.Uint32 count);
typedef DartFLMutableArray_Remove = void Function(
    FLMutableArray array, int firstIndex, int count);
typedef NativeFLMutableArray_Resize = ffi.Void Function(
    FLMutableArray array, ffi.Uint32 size);
typedef DartFLMutableArray_Resize = void Function(
    FLMutableArray array, int size);
typedef NativeFLMutableArray_GetMutableArray = FLMutableArray Function(
    FLMutableArray arg0, ffi.Uint32 index);
typedef DartFLMutableArray_GetMutableArray = FLMutableArray Function(
    FLMutableArray arg0, int index);
typedef NativeFLMutableArray_GetMutableDict = FLMutableDict Function(
    FLMutableArray arg0, ffi.Uint32 index);
typedef DartFLMutableArray_GetMutableDict = FLMutableDict Function(
    FLMutableArray arg0, int index);
typedef NativeFLDict_MutableCopy = FLMutableDict Function(
    FLDict source, ffi.Int32 arg1);
typedef DartFLDict_MutableCopy = FLMutableDict Function(
    FLDict source, int arg1);
typedef NativeFLMutableDict_New = FLMutableDict Function();
typedef DartFLMutableDict_New = FLMutableDict Function();
typedef NativeFLMutableDict_GetSource = FLDict Function(FLMutableDict arg0);
typedef DartFLMutableDict_GetSource = FLDict Function(FLMutableDict arg0);
typedef NativeFLMutableDict_IsChanged = ffi.Bool Function(FLMutableDict arg0);
typedef DartFLMutableDict_IsChanged = bool Function(FLMutableDict arg0);
typedef NativeFLMutableDict_SetChanged = ffi.Void Function(
    FLMutableDict arg0, ffi.Bool arg1);
typedef DartFLMutableDict_SetChanged = void Function(
    FLMutableDict arg0, bool arg1);
typedef NativeFLMutableDict_Remove = ffi.Void Function(
    FLMutableDict arg0, FLString key);
typedef DartFLMutableDict_Remove = void Function(
    FLMutableDict arg0, FLString key);
typedef NativeFLMutableDict_RemoveAll = ffi.Void Function(FLMutableDict arg0);
typedef DartFLMutableDict_RemoveAll = void Function(FLMutableDict arg0);
typedef NativeFLMutableDict_GetMutableArray = FLMutableArray Function(
    FLMutableDict arg0, FLString key);
typedef DartFLMutableDict_GetMutableArray = FLMutableArray Function(
    FLMutableDict arg0, FLString key);
typedef NativeFLMutableDict_GetMutableDict = FLMutableDict Function(
    FLMutableDict arg0, FLString key);
typedef DartFLMutableDict_GetMutableDict = FLMutableDict Function(
    FLMutableDict arg0, FLString key);
typedef NativeFLValue_NewString = FLValue Function(FLString arg0);
typedef DartFLValue_NewString = FLValue Function(FLString arg0);
typedef NativeFLValue_NewData = FLValue Function(FLSlice arg0);
typedef DartFLValue_NewData = FLValue Function(FLSlice arg0);
typedef NativeFLMutableArray_Set = FLSlot Function(
    FLMutableArray arg0, ffi.Uint32 index);
typedef DartFLMutableArray_Set = FLSlot Function(
    FLMutableArray arg0, int index);
typedef NativeFLMutableArray_Append = FLSlot Function(FLMutableArray arg0);
typedef DartFLMutableArray_Append = FLSlot Function(FLMutableArray arg0);
typedef NativeFLMutableDict_Set = FLSlot Function(
    FLMutableDict arg0, FLString key);
typedef DartFLMutableDict_Set = FLSlot Function(
    FLMutableDict arg0, FLString key);
typedef NativeFLSlot_SetNull = ffi.Void Function(FLSlot arg0);
typedef DartFLSlot_SetNull = void Function(FLSlot arg0);
typedef NativeFLSlot_SetBool = ffi.Void Function(FLSlot arg0, ffi.Bool arg1);
typedef DartFLSlot_SetBool = void Function(FLSlot arg0, bool arg1);
typedef NativeFLSlot_SetInt = ffi.Void Function(FLSlot arg0, ffi.Int64 arg1);
typedef DartFLSlot_SetInt = void Function(FLSlot arg0, int arg1);
typedef NativeFLSlot_SetUInt = ffi.Void Function(FLSlot arg0, ffi.Uint64 arg1);
typedef DartFLSlot_SetUInt = void Function(FLSlot arg0, int arg1);
typedef NativeFLSlot_SetFloat = ffi.Void Function(FLSlot arg0, ffi.Float arg1);
typedef DartFLSlot_SetFloat = void Function(FLSlot arg0, double arg1);
typedef NativeFLSlot_SetDouble = ffi.Void Function(
    FLSlot arg0, ffi.Double arg1);
typedef DartFLSlot_SetDouble = void Function(FLSlot arg0, double arg1);
typedef NativeFLSlot_SetString = ffi.Void Function(FLSlot arg0, FLString arg1);
typedef DartFLSlot_SetString = void Function(FLSlot arg0, FLString arg1);
typedef NativeFLSlot_SetData = ffi.Void Function(FLSlot arg0, FLSlice arg1);
typedef DartFLSlot_SetData = void Function(FLSlot arg0, FLSlice arg1);
typedef NativeFLSlot_SetValue = ffi.Void Function(FLSlot arg0, FLValue arg1);
typedef DartFLSlot_SetValue = void Function(FLSlot arg0, FLValue arg1);
typedef NativeFLCreateJSONDelta = FLSliceResult Function(
    FLValue old, FLValue nuu);
typedef DartFLCreateJSONDelta = FLSliceResult Function(
    FLValue old, FLValue nuu);
typedef NativeFLEncodeJSONDelta = ffi.Bool Function(
    FLValue old, FLValue nuu, FLEncoder jsonEncoder);
typedef DartFLEncodeJSONDelta = bool Function(
    FLValue old, FLValue nuu, FLEncoder jsonEncoder);
typedef NativeFLApplyJSONDelta = FLSliceResult Function(
    FLValue old, FLSlice jsonDelta, ffi.Pointer<ffi.Int32> outError);
typedef DartFLApplyJSONDelta = FLSliceResult Function(
    FLValue old, FLSlice jsonDelta, ffi.Pointer<ffi.Int32> outError);
typedef NativeFLEncodeApplyingJSONDelta = ffi.Bool Function(
    FLValue old, FLSlice jsonDelta, FLEncoder encoder);
typedef DartFLEncodeApplyingJSONDelta = bool Function(
    FLValue old, FLSlice jsonDelta, FLEncoder encoder);
typedef NativeFLSharedKeys_New = FLSharedKeys Function();
typedef DartFLSharedKeys_New = FLSharedKeys Function();
typedef FLSharedKeysReadCallback
    = ffi.Pointer<ffi.NativeFunction<FLSharedKeysReadCallbackFunction>>;
typedef FLSharedKeysReadCallbackFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void>, FLSharedKeys);
typedef DartFLSharedKeysReadCallbackFunction = bool Function(
    ffi.Pointer<ffi.Void>, FLSharedKeys);
typedef NativeFLSharedKeys_NewWithRead = FLSharedKeys Function(
    FLSharedKeysReadCallback arg0, ffi.Pointer<ffi.Void> context);
typedef DartFLSharedKeys_NewWithRead = FLSharedKeys Function(
    FLSharedKeysReadCallback arg0, ffi.Pointer<ffi.Void> context);
typedef NativeFLSharedKeys_GetStateData = FLSliceResult Function(
    FLSharedKeys arg0);
typedef DartFLSharedKeys_GetStateData = FLSliceResult Function(
    FLSharedKeys arg0);
typedef NativeFLSharedKeys_LoadStateData = ffi.Bool Function(
    FLSharedKeys arg0, FLSlice arg1);
typedef DartFLSharedKeys_LoadStateData = bool Function(
    FLSharedKeys arg0, FLSlice arg1);
typedef NativeFLSharedKeys_WriteState = ffi.Void Function(
    FLSharedKeys arg0, FLEncoder arg1);
typedef DartFLSharedKeys_WriteState = void Function(
    FLSharedKeys arg0, FLEncoder arg1);
typedef NativeFLSharedKeys_LoadState = ffi.Bool Function(
    FLSharedKeys arg0, FLValue arg1);
typedef DartFLSharedKeys_LoadState = bool Function(
    FLSharedKeys arg0, FLValue arg1);
typedef NativeFLSharedKeys_Encode = ffi.Int Function(
    FLSharedKeys arg0, FLString arg1, ffi.Bool add);
typedef DartFLSharedKeys_Encode = int Function(
    FLSharedKeys arg0, FLString arg1, bool add);
typedef NativeFLSharedKeys_Decode = FLString Function(
    FLSharedKeys arg0, ffi.Int key);
typedef DartFLSharedKeys_Decode = FLString Function(FLSharedKeys arg0, int key);
typedef NativeFLSharedKeys_Count = ffi.UnsignedInt Function(FLSharedKeys arg0);
typedef DartFLSharedKeys_Count = int Function(FLSharedKeys arg0);
typedef NativeFLSharedKeys_RevertToCount = ffi.Void Function(
    FLSharedKeys arg0, ffi.UnsignedInt oldCount);
typedef DartFLSharedKeys_RevertToCount = void Function(
    FLSharedKeys arg0, int oldCount);
typedef NativeFLSharedKeys_DisableCaching = ffi.Void Function(
    FLSharedKeys arg0);
typedef DartFLSharedKeys_DisableCaching = void Function(FLSharedKeys arg0);
typedef NativeFLSharedKeys_Retain = FLSharedKeys Function(FLSharedKeys arg0);
typedef DartFLSharedKeys_Retain = FLSharedKeys Function(FLSharedKeys arg0);
typedef NativeFLSharedKeys_Release = ffi.Void Function(FLSharedKeys arg0);
typedef DartFLSharedKeys_Release = void Function(FLSharedKeys arg0);

final class _FLSharedKeyScope extends ffi.Opaque {}

typedef FLSharedKeyScope = ffi.Pointer<_FLSharedKeyScope>;
typedef NativeFLSharedKeyScope_WithRange = FLSharedKeyScope Function(
    FLSlice range, FLSharedKeys arg1);
typedef DartFLSharedKeyScope_WithRange = FLSharedKeyScope Function(
    FLSlice range, FLSharedKeys arg1);
typedef NativeFLSharedKeyScope_Free = ffi.Void Function(FLSharedKeyScope arg0);
typedef DartFLSharedKeyScope_Free = void Function(FLSharedKeyScope arg0);
typedef NativeFLValue_FromData = FLValue Function(
    FLSlice data, ffi.Int32 trust);
typedef DartFLValue_FromData = FLValue Function(FLSlice data, int trust);
typedef NativeFLJSON5_ToJSON = FLStringResult Function(
    FLString json5,
    ffi.Pointer<FLStringResult> outErrorMessage,
    ffi.Pointer<ffi.Size> outErrorPos,
    ffi.Pointer<ffi.Int32> outError);
typedef DartFLJSON5_ToJSON = FLStringResult Function(
    FLString json5,
    ffi.Pointer<FLStringResult> outErrorMessage,
    ffi.Pointer<ffi.Size> outErrorPos,
    ffi.Pointer<ffi.Int32> outError);
typedef NativeFLData_ConvertJSON = FLSliceResult Function(
    FLSlice json, ffi.Pointer<ffi.Int32> outError);
typedef DartFLData_ConvertJSON = FLSliceResult Function(
    FLSlice json, ffi.Pointer<ffi.Int32> outError);
typedef NativeFLEncoder_Amend = ffi.Void Function(
    FLEncoder e, FLSlice base, ffi.Bool reuseStrings, ffi.Bool externPointers);
typedef DartFLEncoder_Amend = void Function(
    FLEncoder e, FLSlice base, bool reuseStrings, bool externPointers);
typedef NativeFLEncoder_GetBase = FLSlice Function(FLEncoder arg0);
typedef DartFLEncoder_GetBase = FLSlice Function(FLEncoder arg0);
typedef NativeFLEncoder_SuppressTrailer = ffi.Void Function(FLEncoder arg0);
typedef DartFLEncoder_SuppressTrailer = void Function(FLEncoder arg0);
typedef NativeFLEncoder_GetNextWritePos = ffi.Size Function(FLEncoder arg0);
typedef DartFLEncoder_GetNextWritePos = int Function(FLEncoder arg0);
typedef NativeFLEncoder_LastValueWritten = ffi.IntPtr Function(FLEncoder arg0);
typedef DartFLEncoder_LastValueWritten = int Function(FLEncoder arg0);
typedef NativeFLEncoder_WriteValueAgain = ffi.Bool Function(
    FLEncoder arg0, ffi.IntPtr preWrittenValue);
typedef DartFLEncoder_WriteValueAgain = bool Function(
    FLEncoder arg0, int preWrittenValue);
typedef NativeFLEncoder_Snip = FLSliceResult Function(FLEncoder arg0);
typedef DartFLEncoder_Snip = FLSliceResult Function(FLEncoder arg0);
typedef NativeFLEncoder_FinishItem = ffi.Size Function(FLEncoder arg0);
typedef DartFLEncoder_FinishItem = int Function(FLEncoder arg0);
typedef NativeFLJSONEncoder_NextDocument = ffi.Void Function(FLEncoder arg0);
typedef DartFLJSONEncoder_NextDocument = void Function(FLEncoder arg0);
typedef NativeFLDump = ffi.Pointer<ffi.Char> Function(FLValue arg0);
typedef DartFLDump = ffi.Pointer<ffi.Char> Function(FLValue arg0);
typedef NativeFLDumpData = ffi.Pointer<ffi.Char> Function(FLSlice data);
typedef DartFLDumpData = ffi.Pointer<ffi.Char> Function(FLSlice data);
typedef NativeFLData_Dump = FLStringResult Function(FLSlice data);
typedef DartFLData_Dump = FLStringResult Function(FLSlice data);

const int kCBLDomain = 1;

const int kCBLPOSIXDomain = 2;

const int kCBLSQLiteDomain = 3;

const int kCBLFleeceDomain = 4;

const int kCBLNetworkDomain = 5;

const int kCBLWebSocketDomain = 6;

const int kCBLErrorAssertionFailed = 1;

const int kCBLErrorUnimplemented = 2;

const int kCBLErrorUnsupportedEncryption = 3;

const int kCBLErrorBadRevisionID = 4;

const int kCBLErrorCorruptRevisionData = 5;

const int kCBLErrorNotOpen = 6;

const int kCBLErrorNotFound = 7;

const int kCBLErrorConflict = 8;

const int kCBLErrorInvalidParameter = 9;

const int kCBLErrorUnexpectedError = 10;

const int kCBLErrorCantOpenFile = 11;

const int kCBLErrorIOError = 12;

const int kCBLErrorMemoryError = 13;

const int kCBLErrorNotWriteable = 14;

const int kCBLErrorCorruptData = 15;

const int kCBLErrorBusy = 16;

const int kCBLErrorNotInTransaction = 17;

const int kCBLErrorTransactionNotClosed = 18;

const int kCBLErrorUnsupported = 19;

const int kCBLErrorNotADatabaseFile = 20;

const int kCBLErrorWrongFormat = 21;

const int kCBLErrorCrypto = 22;

const int kCBLErrorInvalidQuery = 23;

const int kCBLErrorMissingIndex = 24;

const int kCBLErrorInvalidQueryParam = 25;

const int kCBLErrorRemoteError = 26;

const int kCBLErrorDatabaseTooOld = 27;

const int kCBLErrorDatabaseTooNew = 28;

const int kCBLErrorBadDocID = 29;

const int kCBLErrorCantUpgradeDatabase = 30;

const int kCBLNetErrDNSFailure = 1;

const int kCBLNetErrUnknownHost = 2;

const int kCBLNetErrTimeout = 3;

const int kCBLNetErrInvalidURL = 4;

const int kCBLNetErrTooManyRedirects = 5;

const int kCBLNetErrTLSHandshakeFailed = 6;

const int kCBLNetErrTLSCertExpired = 7;

const int kCBLNetErrTLSCertUntrusted = 8;

const int kCBLNetErrTLSClientCertRequired = 9;

const int kCBLNetErrTLSClientCertRejected = 10;

const int kCBLNetErrTLSCertUnknownRoot = 11;

const int kCBLNetErrInvalidRedirect = 12;

const int kCBLNetErrUnknown = 13;

const int kCBLNetErrTLSCertRevoked = 14;

const int kCBLNetErrTLSCertNameMismatch = 15;

const int kCBLSeekModeFromStart = 0;

const int kCBLSeekModeRelative = 1;

const int kCBLSeekModeFromEnd = 2;

const int kCBLConcurrencyControlLastWriteWins = 0;

const int kCBLConcurrencyControlFailOnConflict = 1;

const int kCBLJSONLanguage = 0;

const int kCBLN1QLLanguage = 1;

const int kCBLMaintenanceTypeCompact = 0;

const int kCBLMaintenanceTypeReindex = 1;

const int kCBLMaintenanceTypeIntegrityCheck = 2;

const int kCBLMaintenanceTypeOptimize = 3;

const int kCBLMaintenanceTypeFullOptimize = 4;

const int kCBLReplicatorTypePushAndPull = 0;

const int kCBLReplicatorTypePush = 1;

const int kCBLReplicatorTypePull = 2;

const int kCBLDocumentFlagsDeleted = 1;

const int kCBLDocumentFlagsAccessRemoved = 2;

const int kCBLProxyHTTP = 0;

const int kCBLProxyHTTPS = 1;

const int kCBLReplicatorStopped = 0;

const int kCBLReplicatorOffline = 1;

const int kCBLReplicatorConnecting = 2;

const int kCBLReplicatorIdle = 3;

const int kCBLReplicatorBusy = 4;

const int kCBLLogDomainDatabase = 0;

const int kCBLLogDomainQuery = 1;

const int kCBLLogDomainReplicator = 2;

const int kCBLLogDomainNetwork = 3;

const int kCBLLogDebug = 0;

const int kCBLLogVerbose = 1;

const int kCBLLogInfo = 2;

const int kCBLLogWarning = 3;

const int kCBLLogError = 4;

const int kCBLLogNone = 5;

const String CBLITE_VERSION = '3.2.0';

const int CBLITE_VERSION_NUMBER = 3002000;

const int CBLITE_BUILD_NUMBER = 63;

const String CBLITE_SOURCE_ID = '42c42c4+bc179d9';

const String CBLITE_BUILD_TIMESTAMP = '2024-07-20T02:48:21Z';

const String HOTLEVEL = 'Ofast';

const String COLDLEVEL = 'Oz';

const int FLTimestampNone = -9223372036854775808;

const int kFLTrustedDontParse = 4294967295;

const int kFLNoWrittenValue = -9223372036854775808;
