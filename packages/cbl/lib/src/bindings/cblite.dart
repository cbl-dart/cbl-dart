// ignore_for_file: unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for Couchbase Lite C API
class cblite {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  cblite(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  cblite.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Returns a message describing an error. @note You are responsible for
  /// releasing the result by calling \ref FLSliceResult_Release.
  FLSliceResult CBLError_Message(
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLError_Message(
      outError,
    );
  }

  late final _CBLError_MessagePtr =
      _lookup<ffi.NativeFunction<NativeCBLError_Message>>('CBLError_Message');
  late final _CBLError_Message =
      _CBLError_MessagePtr.asFunction<DartCBLError_Message>();

  /// Returns the current time, in milliseconds since 1/1/1970.
  int CBL_Now() {
    return _CBL_Now();
  }

  late final _CBL_NowPtr =
      _lookup<ffi.NativeFunction<NativeCBL_Now>>('CBL_Now');
  late final _CBL_Now = _CBL_NowPtr.asFunction<DartCBL_Now>();

  /// Increments an object's reference-count. Usually you'll call one of the
  /// type-safe synonyms specific to the object type, like \ref
  /// CBLDatabase_Retain`
  ffi.Pointer<CBLRefCounted> CBL_Retain(
    ffi.Pointer<CBLRefCounted> arg0,
  ) {
    return _CBL_Retain(
      arg0,
    );
  }

  late final _CBL_RetainPtr =
      _lookup<ffi.NativeFunction<NativeCBL_Retain>>('CBL_Retain');
  late final _CBL_Retain = _CBL_RetainPtr.asFunction<DartCBL_Retain>();

  /// Decrements an object's reference-count, freeing the object if the count
  /// hits zero. Usually you'll call one of the type-safe synonyms specific to
  /// the object type, like \ref CBLDatabase_Release.
  void CBL_Release(
    ffi.Pointer<CBLRefCounted> arg0,
  ) {
    return _CBL_Release(
      arg0,
    );
  }

  late final _CBL_ReleasePtr =
      _lookup<ffi.NativeFunction<NativeCBL_Release>>('CBL_Release');
  late final _CBL_Release = _CBL_ReleasePtr.asFunction<DartCBL_Release>();

  /// Returns the total number of Couchbase Lite objects. Useful for leak
  /// checking.
  int CBL_InstanceCount() {
    return _CBL_InstanceCount();
  }

  late final _CBL_InstanceCountPtr =
      _lookup<ffi.NativeFunction<NativeCBL_InstanceCount>>('CBL_InstanceCount');
  late final _CBL_InstanceCount =
      _CBL_InstanceCountPtr.asFunction<DartCBL_InstanceCount>();

  /// Logs the class and address of each Couchbase Lite object. Useful for leak
  /// checking. @note May only be functional in debug builds of Couchbase Lite.
  void CBL_DumpInstances() {
    return _CBL_DumpInstances();
  }

  late final _CBL_DumpInstancesPtr =
      _lookup<ffi.NativeFunction<NativeCBL_DumpInstances>>('CBL_DumpInstances');
  late final _CBL_DumpInstances =
      _CBL_DumpInstancesPtr.asFunction<DartCBL_DumpInstances>();

  /// Removes a listener callback, given the token that was returned when it was
  /// added.
  void CBLListener_Remove(
    ffi.Pointer<CBLListenerToken> arg0,
  ) {
    return _CBLListener_Remove(
      arg0,
    );
  }

  late final _CBLListener_RemovePtr =
      _lookup<ffi.NativeFunction<NativeCBLListener_Remove>>(
          'CBLListener_Remove');
  late final _CBLListener_Remove =
      _CBLListener_RemovePtr.asFunction<DartCBLListener_Remove>();

  /// < `"blob"`
  late final ffi.Pointer<FLSlice> _kCBLBlobType =
      _lookup<FLSlice>('kCBLBlobType');

  FLSlice get kCBLBlobType => _kCBLBlobType.ref;

  /// < `"digest"`
  late final ffi.Pointer<FLSlice> _kCBLBlobDigestProperty =
      _lookup<FLSlice>('kCBLBlobDigestProperty');

  FLSlice get kCBLBlobDigestProperty => _kCBLBlobDigestProperty.ref;

  /// < `"length"`
  late final ffi.Pointer<FLSlice> _kCBLBlobLengthProperty =
      _lookup<FLSlice>('kCBLBlobLengthProperty');

  FLSlice get kCBLBlobLengthProperty => _kCBLBlobLengthProperty.ref;

  /// < `"content_type"`
  late final ffi.Pointer<FLSlice> _kCBLBlobContentTypeProperty =
      _lookup<FLSlice>('kCBLBlobContentTypeProperty');

  FLSlice get kCBLBlobContentTypeProperty => _kCBLBlobContentTypeProperty.ref;

  /// Returns true if a dictionary in a document is a blob reference. If so, you
  /// can call \ref FLDict_GetBlob to access it. @note This function tests
  /// whether the dictionary has a `@type` property, whose value is `"blob"`.
  bool FLDict_IsBlob(
    FLDict arg0,
  ) {
    return _FLDict_IsBlob(
      arg0,
    );
  }

  late final _FLDict_IsBlobPtr =
      _lookup<ffi.NativeFunction<NativeFLDict_IsBlob>>('FLDict_IsBlob');
  late final _FLDict_IsBlob = _FLDict_IsBlobPtr.asFunction<DartFLDict_IsBlob>();

  /// Returns a CBLBlob object corresponding to a blob dictionary in a document.
  /// @param blobDict A dictionary in a document. @return A CBLBlob instance for
  /// this blob, or NULL if the dictionary is not a blob.
  ffi.Pointer<CBLBlob> FLDict_GetBlob(
    FLDict blobDict,
  ) {
    return _FLDict_GetBlob(
      blobDict,
    );
  }

  late final _FLDict_GetBlobPtr =
      _lookup<ffi.NativeFunction<NativeFLDict_GetBlob>>('FLDict_GetBlob');
  late final _FLDict_GetBlob =
      _FLDict_GetBlobPtr.asFunction<DartFLDict_GetBlob>();

  /// Returns the length in bytes of a blob's content (from its `length`
  /// property).
  int CBLBlob_Length(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_Length(
      arg0,
    );
  }

  late final _CBLBlob_LengthPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlob_Length>>('CBLBlob_Length');
  late final _CBLBlob_Length =
      _CBLBlob_LengthPtr.asFunction<DartCBLBlob_Length>();

  /// Returns a blob's MIME type, if its metadata has a `content_type` property.
  FLString CBLBlob_ContentType(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_ContentType(
      arg0,
    );
  }

  late final _CBLBlob_ContentTypePtr =
      _lookup<ffi.NativeFunction<NativeCBLBlob_ContentType>>(
          'CBLBlob_ContentType');
  late final _CBLBlob_ContentType =
      _CBLBlob_ContentTypePtr.asFunction<DartCBLBlob_ContentType>();

  /// Returns the cryptographic digest of a blob's content (from its `digest`
  /// property).
  FLString CBLBlob_Digest(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_Digest(
      arg0,
    );
  }

  late final _CBLBlob_DigestPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlob_Digest>>('CBLBlob_Digest');
  late final _CBLBlob_Digest =
      _CBLBlob_DigestPtr.asFunction<DartCBLBlob_Digest>();

  /// Returns a blob's metadata. This includes the `digest`, `length`,
  /// `content_type`, and `@type` properties, as well as any custom ones that
  /// may have been added.
  FLDict CBLBlob_Properties(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_Properties(
      arg0,
    );
  }

  late final _CBLBlob_PropertiesPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlob_Properties>>(
          'CBLBlob_Properties');
  late final _CBLBlob_Properties =
      _CBLBlob_PropertiesPtr.asFunction<DartCBLBlob_Properties>();

  /// Returns a blob's metadata as JSON.
  FLStringResult CBLBlob_CreateJSON(
    ffi.Pointer<CBLBlob> blob,
  ) {
    return _CBLBlob_CreateJSON(
      blob,
    );
  }

  late final _CBLBlob_CreateJSONPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlob_CreateJSON>>(
          'CBLBlob_CreateJSON');
  late final _CBLBlob_CreateJSON =
      _CBLBlob_CreateJSONPtr.asFunction<DartCBLBlob_CreateJSON>();

  /// Reads the blob's content into memory and returns them. @note You are
  /// responsible for releasing the result by calling \ref
  /// FLSliceResult_Release.
  FLSliceResult CBLBlob_Content(
    ffi.Pointer<CBLBlob> blob,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlob_Content(
      blob,
      outError,
    );
  }

  late final _CBLBlob_ContentPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlob_Content>>('CBLBlob_Content');
  late final _CBLBlob_Content =
      _CBLBlob_ContentPtr.asFunction<DartCBLBlob_Content>();

  /// Opens a stream for reading a blob's content.
  ffi.Pointer<CBLBlobReadStream> CBLBlob_OpenContentStream(
    ffi.Pointer<CBLBlob> blob,
    ffi.Pointer<CBLError> arg1,
  ) {
    return _CBLBlob_OpenContentStream(
      blob,
      arg1,
    );
  }

  late final _CBLBlob_OpenContentStreamPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlob_OpenContentStream>>(
          'CBLBlob_OpenContentStream');
  late final _CBLBlob_OpenContentStream =
      _CBLBlob_OpenContentStreamPtr.asFunction<DartCBLBlob_OpenContentStream>();

  /// Reads data from a blob. @param stream The stream to read from. @param dst
  /// The address to copy the read data to. @param maxLength The maximum number
  /// of bytes to read. @param outError On failure, an error will be stored here
  /// if non-NULL. @return The actual number of bytes read; 0 if at EOF, -1 on
  /// error.
  int CBLBlobReader_Read(
    ffi.Pointer<CBLBlobReadStream> stream,
    ffi.Pointer<ffi.Void> dst,
    int maxLength,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlobReader_Read(
      stream,
      dst,
      maxLength,
      outError,
    );
  }

  late final _CBLBlobReader_ReadPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlobReader_Read>>(
          'CBLBlobReader_Read');
  late final _CBLBlobReader_Read =
      _CBLBlobReader_ReadPtr.asFunction<DartCBLBlobReader_Read>();

  /// Sets the position of a CBLBlobReadStream. @param stream The stream to
  /// reposition. @param offset The byte offset in the stream (relative to the
  /// `mode`). @param base The base position from which the offset is
  /// calculated. @param outError On failure, an error will be stored here if
  /// non-NULL. @return The new absolute position, or -1 on failure.
  int CBLBlobReader_Seek(
    ffi.Pointer<CBLBlobReadStream> stream,
    int offset,
    int base,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlobReader_Seek(
      stream,
      offset,
      base,
      outError,
    );
  }

  late final _CBLBlobReader_SeekPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlobReader_Seek>>(
          'CBLBlobReader_Seek');
  late final _CBLBlobReader_Seek =
      _CBLBlobReader_SeekPtr.asFunction<DartCBLBlobReader_Seek>();

  /// Returns the current position of a CBLBlobReadStream.
  int CBLBlobReader_Position(
    ffi.Pointer<CBLBlobReadStream> stream,
  ) {
    return _CBLBlobReader_Position(
      stream,
    );
  }

  late final _CBLBlobReader_PositionPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlobReader_Position>>(
          'CBLBlobReader_Position');
  late final _CBLBlobReader_Position =
      _CBLBlobReader_PositionPtr.asFunction<DartCBLBlobReader_Position>();

  /// Closes a CBLBlobReadStream.
  void CBLBlobReader_Close(
    ffi.Pointer<CBLBlobReadStream> arg0,
  ) {
    return _CBLBlobReader_Close(
      arg0,
    );
  }

  late final _CBLBlobReader_ClosePtr =
      _lookup<ffi.NativeFunction<NativeCBLBlobReader_Close>>(
          'CBLBlobReader_Close');
  late final _CBLBlobReader_Close =
      _CBLBlobReader_ClosePtr.asFunction<DartCBLBlobReader_Close>();

  /// Compares whether the two given blobs are equal based on their content.
  bool CBLBlob_Equals(
    ffi.Pointer<CBLBlob> blob,
    ffi.Pointer<CBLBlob> anotherBlob,
  ) {
    return _CBLBlob_Equals(
      blob,
      anotherBlob,
    );
  }

  late final _CBLBlob_EqualsPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlob_Equals>>('CBLBlob_Equals');
  late final _CBLBlob_Equals =
      _CBLBlob_EqualsPtr.asFunction<DartCBLBlob_Equals>();

  /// Creates a new blob given its contents as a single block of data. @note You
  /// are responsible for releasing the \ref CBLBlob, but not until after its
  /// document has been saved. @param contentType The MIME type (optional).
  /// @param contents The data's address and length. @return A new CBLBlob
  /// instance.
  ffi.Pointer<CBLBlob> CBLBlob_CreateWithData(
    FLString contentType,
    FLSlice contents,
  ) {
    return _CBLBlob_CreateWithData(
      contentType,
      contents,
    );
  }

  late final _CBLBlob_CreateWithDataPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlob_CreateWithData>>(
          'CBLBlob_CreateWithData');
  late final _CBLBlob_CreateWithData =
      _CBLBlob_CreateWithDataPtr.asFunction<DartCBLBlob_CreateWithData>();

  /// Opens a stream for writing a new blob. You should next call \ref
  /// CBLBlobWriter_Write one or more times to write the data, then \ref
  /// CBLBlob_CreateWithStream to create the blob.
  ///
  /// If for some reason you need to abort, just call \ref CBLBlobWriter_Close.
  ffi.Pointer<CBLBlobWriteStream> CBLBlobWriter_Create(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLError> arg1,
  ) {
    return _CBLBlobWriter_Create(
      db,
      arg1,
    );
  }

  late final _CBLBlobWriter_CreatePtr =
      _lookup<ffi.NativeFunction<NativeCBLBlobWriter_Create>>(
          'CBLBlobWriter_Create');
  late final _CBLBlobWriter_Create =
      _CBLBlobWriter_CreatePtr.asFunction<DartCBLBlobWriter_Create>();

  /// Closes a blob-writing stream, if you need to give up without creating a
  /// \ref CBLBlob.
  void CBLBlobWriter_Close(
    ffi.Pointer<CBLBlobWriteStream> arg0,
  ) {
    return _CBLBlobWriter_Close(
      arg0,
    );
  }

  late final _CBLBlobWriter_ClosePtr =
      _lookup<ffi.NativeFunction<NativeCBLBlobWriter_Close>>(
          'CBLBlobWriter_Close');
  late final _CBLBlobWriter_Close =
      _CBLBlobWriter_ClosePtr.asFunction<DartCBLBlobWriter_Close>();

  /// Writes data to a new blob. @param writer The stream to write to. @param
  /// data The address of the data to write. @param length The length of the
  /// data to write. @param outError On failure, error info will be written
  /// here. @return True on success, false on failure.
  bool CBLBlobWriter_Write(
    ffi.Pointer<CBLBlobWriteStream> writer,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlobWriter_Write(
      writer,
      data,
      length,
      outError,
    );
  }

  late final _CBLBlobWriter_WritePtr =
      _lookup<ffi.NativeFunction<NativeCBLBlobWriter_Write>>(
          'CBLBlobWriter_Write');
  late final _CBLBlobWriter_Write =
      _CBLBlobWriter_WritePtr.asFunction<DartCBLBlobWriter_Write>();

  /// Creates a new blob after its data has been written to a \ref
  /// CBLBlobWriteStream. You should then add the blob to a mutable document as
  /// a property -- see \ref FLSlot_SetBlob. @note You are responsible for
  /// releasing the CBLBlob reference. @note Do not free the stream; the blob
  /// will do that. @param contentType The MIME type (optional). @param writer
  /// The blob-writing stream the data was written to. @return A new CBLBlob
  /// instance.
  ffi.Pointer<CBLBlob> CBLBlob_CreateWithStream(
    FLString contentType,
    ffi.Pointer<CBLBlobWriteStream> writer,
  ) {
    return _CBLBlob_CreateWithStream(
      contentType,
      writer,
    );
  }

  late final _CBLBlob_CreateWithStreamPtr =
      _lookup<ffi.NativeFunction<NativeCBLBlob_CreateWithStream>>(
          'CBLBlob_CreateWithStream');
  late final _CBLBlob_CreateWithStream =
      _CBLBlob_CreateWithStreamPtr.asFunction<DartCBLBlob_CreateWithStream>();

  void FLSlot_SetBlob(
    FLSlot slot,
    ffi.Pointer<CBLBlob> blob,
  ) {
    return _FLSlot_SetBlob(
      slot,
      blob,
    );
  }

  late final _FLSlot_SetBlobPtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetBlob>>('FLSlot_SetBlob');
  late final _FLSlot_SetBlob =
      _FLSlot_SetBlobPtr.asFunction<DartFLSlot_SetBlob>();

  /// Get a \ref CBLBlob object from the database using the \ref CBLBlob
  /// properties.
  ///
  /// The \ref CBLBlob properties is a blob's metadata containing two required
  /// fields which are a special marker property `"@type":"blob"`, and property
  /// `digest` whose value is a hex SHA-1 digest of the blob's data. The other
  /// optional properties are `length` and `content_type`. To obtain the \ref
  /// CBLBlob properties from a \ref CBLBlob, call \ref CBLBlob_Properties
  /// function.
  ///
  /// @note You must release the \ref CBLBlob when you're finished with it.
  /// @param db The database. @param properties The properties for getting the
  /// \ref CBLBlob object. @param outError On failure, error info will be
  /// written here if specified. A nonexistent blob is not considered a failure;
  /// in that event the error code will be zero. @return A \ref CBLBlob
  /// instance, or NULL if the doc doesn't exist or an error occurred.
  ffi.Pointer<CBLBlob> CBLDatabase_GetBlob(
    ffi.Pointer<CBLDatabase> db,
    FLDict properties,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_GetBlob(
      db,
      properties,
      outError,
    );
  }

  late final _CBLDatabase_GetBlobPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_GetBlob>>(
          'CBLDatabase_GetBlob');
  late final _CBLDatabase_GetBlob =
      _CBLDatabase_GetBlobPtr.asFunction<DartCBLDatabase_GetBlob>();

  /// Save a new \ref CBLBlob object into the database without associating it
  /// with any documents. The properties of the saved \ref CBLBlob object will
  /// include information necessary for referencing the \ref CBLBlob object in
  /// the properties of the document to be saved into the database.
  ///
  /// Normally you do not need to use this function unless you are in the
  /// situation (e.g. developing javascript binding) that you cannot retain the
  /// \ref CBLBlob object until the document containing the \ref CBLBlob object
  /// is successfully saved into the database. \note The saved \ref CBLBlob
  /// objects that are not associated with any documents will be removed from
  /// the database when compacting the database. @param db The database. @param
  /// blob The The CBLBlob to save. @param outError On failure, error info will
  /// be written here.
  bool CBLDatabase_SaveBlob(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLBlob> blob,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_SaveBlob(
      db,
      blob,
      outError,
    );
  }

  late final _CBLDatabase_SaveBlobPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_SaveBlob>>(
          'CBLDatabase_SaveBlob');
  late final _CBLDatabase_SaveBlob =
      _CBLDatabase_SaveBlobPtr.asFunction<DartCBLDatabase_SaveBlob>();

  /// < `"@type"`
  late final ffi.Pointer<FLSlice> _kCBLTypeProperty =
      _lookup<FLSlice>('kCBLTypeProperty');

  FLSlice get kCBLTypeProperty => _kCBLTypeProperty.ref;

  /// Reads a document from the default collection in an immutable form. Each
  /// call to this function creates a new object (which must later be released.)
  /// @note If you are reading the document in order to make changes to it, call
  /// \ref CBLDatabase_GetMutableDocument instead. @warning <b>Deprecated :</b>
  /// Use CBLCollection_GetDocument on the default collection instead. @param
  /// database The database. @param docID The ID of the document. @param
  /// outError On failure, the error will be written here. (A nonexistent
  /// document is not considered a failure; in that event the error code will be
  /// zero.) @return A new \ref CBLDocument instance, or NULL if the doc doesn't
  /// exist or an error occurred.
  ffi.Pointer<CBLDocument> CBLDatabase_GetDocument(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_GetDocument(
      database,
      docID,
      outError,
    );
  }

  late final _CBLDatabase_GetDocumentPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_GetDocument>>(
          'CBLDatabase_GetDocument');
  late final _CBLDatabase_GetDocument =
      _CBLDatabase_GetDocumentPtr.asFunction<DartCBLDatabase_GetDocument>();

  /// Saves a (mutable) document to the default collection. @warning If a newer
  /// revision has been saved since \p doc was loaded, it will be overwritten by
  /// this one. This can lead to data loss! To avoid this, call \ref
  /// CBLDatabase_SaveDocumentWithConcurrencyControl or \ref
  /// CBLDatabase_SaveDocumentWithConflictHandler instead. @warning
  /// <b>Deprecated :</b> Use CBLCollection_SaveDocument on the default
  /// collection instead. @param db The database. @param doc The mutable
  /// document to save. @param outError On failure, the error will be written
  /// here. @return True on success, false on failure.
  bool CBLDatabase_SaveDocument(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_SaveDocument(
      db,
      doc,
      outError,
    );
  }

  late final _CBLDatabase_SaveDocumentPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_SaveDocument>>(
          'CBLDatabase_SaveDocument');
  late final _CBLDatabase_SaveDocument =
      _CBLDatabase_SaveDocumentPtr.asFunction<DartCBLDatabase_SaveDocument>();

  /// Saves a (mutable) document to the default collection. If a conflicting
  /// revision has been saved since \p doc was loaded, the \p concurrency
  /// parameter specifies whether the save should fail, or the conflicting
  /// revision should be overwritten with the revision being saved. If you need
  /// finer-grained control, call \ref
  /// CBLDatabase_SaveDocumentWithConflictHandler instead. @warning
  /// <b>Deprecated :</b> Use CBLCollection_SaveDocumentWithConcurrencyControl
  /// on the default collection instead. @param db The database. @param doc The
  /// mutable document to save. @param concurrency Conflict-handling strategy
  /// (fail or overwrite). @param outError On failure, the error will be written
  /// here. @return True on success, false on failure.
  bool CBLDatabase_SaveDocumentWithConcurrencyControl(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    int concurrency,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_SaveDocumentWithConcurrencyControl(
      db,
      doc,
      concurrency,
      outError,
    );
  }

  late final _CBLDatabase_SaveDocumentWithConcurrencyControlPtr = _lookup<
          ffi.NativeFunction<
              NativeCBLDatabase_SaveDocumentWithConcurrencyControl>>(
      'CBLDatabase_SaveDocumentWithConcurrencyControl');
  late final _CBLDatabase_SaveDocumentWithConcurrencyControl =
      _CBLDatabase_SaveDocumentWithConcurrencyControlPtr.asFunction<
          DartCBLDatabase_SaveDocumentWithConcurrencyControl>();

  /// Saves a (mutable) document to the default collection, allowing for custom
  /// conflict handling in the event that the document has been updated since \p
  /// doc was loaded. @warning <b>Deprecated :</b> Use
  /// CBLCollection_SaveDocumentWithConflictHandler on the default collection
  /// instead. @param db The database. @param doc The mutable document to save.
  /// @param conflictHandler The callback to be invoked if there is a conflict.
  /// @param context An arbitrary value to be passed to the \p conflictHandler.
  /// @param outError On failure, the error will be written here. @return True
  /// on success, false on failure.
  bool CBLDatabase_SaveDocumentWithConflictHandler(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    CBLConflictHandler conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_SaveDocumentWithConflictHandler(
      db,
      doc,
      conflictHandler,
      context,
      outError,
    );
  }

  late final _CBLDatabase_SaveDocumentWithConflictHandlerPtr = _lookup<
          ffi
          .NativeFunction<NativeCBLDatabase_SaveDocumentWithConflictHandler>>(
      'CBLDatabase_SaveDocumentWithConflictHandler');
  late final _CBLDatabase_SaveDocumentWithConflictHandler =
      _CBLDatabase_SaveDocumentWithConflictHandlerPtr.asFunction<
          DartCBLDatabase_SaveDocumentWithConflictHandler>();

  /// Deletes a document from the default collection. Deletions are replicated.
  /// @warning You are still responsible for releasing the CBLDocument. @warning
  /// <b>Deprecated :</b> Use CBLCollection_DeleteDocument on the default
  /// collection instead. @param db The database. @param document The document
  /// to delete. @param outError On failure, the error will be written here.
  /// @return True if the document was deleted, false if an error occurred.
  bool CBLDatabase_DeleteDocument(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_DeleteDocument(
      db,
      document,
      outError,
    );
  }

  late final _CBLDatabase_DeleteDocumentPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_DeleteDocument>>(
          'CBLDatabase_DeleteDocument');
  late final _CBLDatabase_DeleteDocument = _CBLDatabase_DeleteDocumentPtr
      .asFunction<DartCBLDatabase_DeleteDocument>();

  /// Deletes a document from the default collection. Deletions are replicated.
  /// @warning You are still responsible for releasing the CBLDocument. @warning
  /// <b>Deprecated :</b> Use CBLCollection_DeleteDocumentWithConcurrencyControl
  /// on the default collection instead. @param db The database. @param document
  /// The document to delete. @param concurrency Conflict-handling strategy.
  /// @param outError On failure, the error will be written here. @return True
  /// if the document was deleted, false if an error occurred.
  bool CBLDatabase_DeleteDocumentWithConcurrencyControl(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    int concurrency,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_DeleteDocumentWithConcurrencyControl(
      db,
      document,
      concurrency,
      outError,
    );
  }

  late final _CBLDatabase_DeleteDocumentWithConcurrencyControlPtr = _lookup<
          ffi.NativeFunction<
              NativeCBLDatabase_DeleteDocumentWithConcurrencyControl>>(
      'CBLDatabase_DeleteDocumentWithConcurrencyControl');
  late final _CBLDatabase_DeleteDocumentWithConcurrencyControl =
      _CBLDatabase_DeleteDocumentWithConcurrencyControlPtr.asFunction<
          DartCBLDatabase_DeleteDocumentWithConcurrencyControl>();

  /// Purges a document from the default collection. This removes all traces of
  /// the document. Purges are _not_ replicated. If the document is changed on a
  /// server, it will be re-created when pulled. @warning You are still
  /// responsible for releasing the \ref CBLDocument reference. @warning
  /// <b>Deprecated :</b> Use CBLCollection_PurgeDocument on the default
  /// collection instead. @note If you don't have the document in memory
  /// already, \ref CBLDatabase_PurgeDocumentByID is a simpler shortcut. @param
  /// db The database. @param document The document to purge. @param outError On
  /// failure, the error will be written here. @return True if the document was
  /// purged, false if it doesn't exist or the purge failed.
  bool CBLDatabase_PurgeDocument(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_PurgeDocument(
      db,
      document,
      outError,
    );
  }

  late final _CBLDatabase_PurgeDocumentPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_PurgeDocument>>(
          'CBLDatabase_PurgeDocument');
  late final _CBLDatabase_PurgeDocument =
      _CBLDatabase_PurgeDocumentPtr.asFunction<DartCBLDatabase_PurgeDocument>();

  /// Purges a document by its ID from the default collection. @note If no
  /// document with that ID exists, this function will return false but the
  /// error code will be zero. @warning <b>Deprecated :</b> Use
  /// CBLCollection_PurgeDocumentByID on the default collection instead. @param
  /// database The database. @param docID The document ID to purge. @param
  /// outError On failure, the error will be written here. @return True if the
  /// document was purged, false if it doesn't exist or the purge failed.
  bool CBLDatabase_PurgeDocumentByID(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_PurgeDocumentByID(
      database,
      docID,
      outError,
    );
  }

  late final _CBLDatabase_PurgeDocumentByIDPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_PurgeDocumentByID>>(
          'CBLDatabase_PurgeDocumentByID');
  late final _CBLDatabase_PurgeDocumentByID = _CBLDatabase_PurgeDocumentByIDPtr
      .asFunction<DartCBLDatabase_PurgeDocumentByID>();

  /// Reads a document from the default collection in mutable form that can be
  /// updated and saved. (This function is otherwise identical to \ref
  /// CBLDatabase_GetDocument.) @note You must release the document when you're
  /// done with it. @warning <b>Deprecated :</b> Use
  /// CBLCollection_GetMutableDocument on the default collection instead. @param
  /// database The database. @param docID The ID of the document. @param
  /// outError On failure, the error will be written here. (A nonexistent
  /// document is not considered a failure; in that event the error code will be
  /// zero.) @return A new \ref CBLDocument instance, or NULL if the doc doesn't
  /// exist or an error occurred.
  ffi.Pointer<CBLDocument> CBLDatabase_GetMutableDocument(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_GetMutableDocument(
      database,
      docID,
      outError,
    );
  }

  late final _CBLDatabase_GetMutableDocumentPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_GetMutableDocument>>(
          'CBLDatabase_GetMutableDocument');
  late final _CBLDatabase_GetMutableDocument =
      _CBLDatabase_GetMutableDocumentPtr.asFunction<
          DartCBLDatabase_GetMutableDocument>();

  /// Creates a new, empty document in memory, with a randomly-generated unique
  /// ID. It will not be added to a database until saved. @return The new
  /// mutable document instance.
  ffi.Pointer<CBLDocument> CBLDocument_Create() {
    return _CBLDocument_Create();
  }

  late final _CBLDocument_CreatePtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_Create>>(
          'CBLDocument_Create');
  late final _CBLDocument_Create =
      _CBLDocument_CreatePtr.asFunction<DartCBLDocument_Create>();

  /// Creates a new, empty document in memory, with the given ID. It will not be
  /// added to a database until saved. @note If the given ID conflicts with a
  /// document already in the database, that will not be apparent until this
  /// document is saved. At that time, the result depends on the conflict
  /// handling mode used when saving; see the save functions for details. @param
  /// docID The ID of the new document, or NULL to assign a new unique ID.
  /// @return The new mutable document instance.
  ffi.Pointer<CBLDocument> CBLDocument_CreateWithID(
    FLString docID,
  ) {
    return _CBLDocument_CreateWithID(
      docID,
    );
  }

  late final _CBLDocument_CreateWithIDPtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_CreateWithID>>(
          'CBLDocument_CreateWithID');
  late final _CBLDocument_CreateWithID =
      _CBLDocument_CreateWithIDPtr.asFunction<DartCBLDocument_CreateWithID>();

  /// Creates a new mutable CBLDocument instance that refers to the same
  /// document as the original. If the original document has unsaved changes,
  /// the new one will also start out with the same changes; but mutating one
  /// document thereafter will not affect the other. @note You must release the
  /// new reference when you're done with it. Similarly, the original document
  /// still exists and must also be released when you're done with it.
  ffi.Pointer<CBLDocument> CBLDocument_MutableCopy(
    ffi.Pointer<CBLDocument> original,
  ) {
    return _CBLDocument_MutableCopy(
      original,
    );
  }

  late final _CBLDocument_MutableCopyPtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_MutableCopy>>(
          'CBLDocument_MutableCopy');
  late final _CBLDocument_MutableCopy =
      _CBLDocument_MutableCopyPtr.asFunction<DartCBLDocument_MutableCopy>();

  /// Returns a document's ID.
  FLString CBLDocument_ID(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_ID(
      arg0,
    );
  }

  late final _CBLDocument_IDPtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_ID>>('CBLDocument_ID');
  late final _CBLDocument_ID =
      _CBLDocument_IDPtr.asFunction<DartCBLDocument_ID>();

  /// Returns a document's revision ID, which is a short opaque string that's
  /// guaranteed to be unique to every change made to the document. If the
  /// document doesn't exist yet, this function returns NULL.
  FLString CBLDocument_RevisionID(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_RevisionID(
      arg0,
    );
  }

  late final _CBLDocument_RevisionIDPtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_RevisionID>>(
          'CBLDocument_RevisionID');
  late final _CBLDocument_RevisionID =
      _CBLDocument_RevisionIDPtr.asFunction<DartCBLDocument_RevisionID>();

  /// Returns a document's current sequence in the local database. This number
  /// increases every time the document is saved, and a more recently saved
  /// document will have a greater sequence number than one saved earlier, so
  /// sequences may be used as an abstract 'clock' to tell relative modification
  /// times.
  int CBLDocument_Sequence(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_Sequence(
      arg0,
    );
  }

  late final _CBLDocument_SequencePtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_Sequence>>(
          'CBLDocument_Sequence');
  late final _CBLDocument_Sequence =
      _CBLDocument_SequencePtr.asFunction<DartCBLDocument_Sequence>();

  /// Returns a document's collection or NULL for the new document that hasn't
  /// been saved.
  ffi.Pointer<CBLCollection> CBLDocument_Collection(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_Collection(
      arg0,
    );
  }

  late final _CBLDocument_CollectionPtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_Collection>>(
          'CBLDocument_Collection');
  late final _CBLDocument_Collection =
      _CBLDocument_CollectionPtr.asFunction<DartCBLDocument_Collection>();

  /// Returns a document's properties as a dictionary. @note The dictionary
  /// object is owned by the document; you do not need to release it. @warning
  /// When the document is released, this reference to the properties becomes
  /// invalid. If you need to use any properties after releasing the document,
  /// you must retain them by calling \ref FLValue*Retain (and of course later
  /// release them.) @warning This dictionary \_reference* is immutable, but if
  /// the document is mutable the underlying dictionary itself is mutable and
  /// could be modified through a mutable reference obtained via \ref
  /// CBLDocument_MutableProperties. If you need to preserve the properties,
  /// call \ref FLDict_MutableCopy to make a deep copy.
  FLDict CBLDocument_Properties(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_Properties(
      arg0,
    );
  }

  late final _CBLDocument_PropertiesPtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_Properties>>(
          'CBLDocument_Properties');
  late final _CBLDocument_Properties =
      _CBLDocument_PropertiesPtr.asFunction<DartCBLDocument_Properties>();

  /// Returns a mutable document's properties as a mutable dictionary. You may
  /// modify this dictionary and then call \ref CBLDatabase_SaveDocument to
  /// persist the changes. @note The dictionary object is owned by the document;
  /// you do not need to release it. @note Every call to this function returns
  /// the same mutable collection. This is the same collection returned by \ref
  /// CBLDocument_Properties. @note When accessing nested collections inside the
  /// properties as a mutable collection for modification, use \ref
  /// FLMutableDict_GetMutableDict or \ref FLMutableDict_GetMutableArray.
  /// @warning When the document is released, this reference to the properties
  /// becomes invalid. If you need to use any properties after releasing the
  /// document, you must retain them by calling \ref FLValue_Retain (and of
  /// course later release them.)
  FLMutableDict CBLDocument_MutableProperties(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_MutableProperties(
      arg0,
    );
  }

  late final _CBLDocument_MutablePropertiesPtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_MutableProperties>>(
          'CBLDocument_MutableProperties');
  late final _CBLDocument_MutableProperties = _CBLDocument_MutablePropertiesPtr
      .asFunction<DartCBLDocument_MutableProperties>();

  /// Sets a mutable document's properties. Call \ref CBLDatabase_SaveDocument
  /// to persist the changes. @note The dictionary object will be retained by
  /// the document. You are responsible for releasing any retained reference(s)
  /// you have to it.
  void CBLDocument_SetProperties(
    ffi.Pointer<CBLDocument> arg0,
    FLMutableDict properties,
  ) {
    return _CBLDocument_SetProperties(
      arg0,
      properties,
    );
  }

  late final _CBLDocument_SetPropertiesPtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_SetProperties>>(
          'CBLDocument_SetProperties');
  late final _CBLDocument_SetProperties =
      _CBLDocument_SetPropertiesPtr.asFunction<DartCBLDocument_SetProperties>();

  /// Returns a document's properties as JSON. @note You are responsible for
  /// releasing the result by calling \ref FLSliceResult_Release.
  FLSliceResult CBLDocument_CreateJSON(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_CreateJSON(
      arg0,
    );
  }

  late final _CBLDocument_CreateJSONPtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_CreateJSON>>(
          'CBLDocument_CreateJSON');
  late final _CBLDocument_CreateJSON =
      _CBLDocument_CreateJSONPtr.asFunction<DartCBLDocument_CreateJSON>();

  /// Sets a mutable document's properties from a JSON string.
  bool CBLDocument_SetJSON(
    ffi.Pointer<CBLDocument> arg0,
    FLSlice json,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDocument_SetJSON(
      arg0,
      json,
      outError,
    );
  }

  late final _CBLDocument_SetJSONPtr =
      _lookup<ffi.NativeFunction<NativeCBLDocument_SetJSON>>(
          'CBLDocument_SetJSON');
  late final _CBLDocument_SetJSON =
      _CBLDocument_SetJSONPtr.asFunction<DartCBLDocument_SetJSON>();

  /// Returns the time, if any, at which a given document will expire and be
  /// purged. Documents don't normally expire; you have to call \ref
  /// CBLDatabase_SetDocumentExpiration to set a document's expiration time.
  /// @warning <b>Deprecated :</b> Use CBLCollection_GetDocumentExpiration
  /// instead. @param db The database. @param docID The ID of the document.
  /// @param outError On failure, an error is written here. @return The
  /// expiration time as a CBLTimestamp (milliseconds since Unix epoch), or 0 if
  /// the document does not have an expiration, or -1 if the call failed.
  int CBLDatabase_GetDocumentExpiration(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_GetDocumentExpiration(
      db,
      docID,
      outError,
    );
  }

  late final _CBLDatabase_GetDocumentExpirationPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_GetDocumentExpiration>>(
          'CBLDatabase_GetDocumentExpiration');
  late final _CBLDatabase_GetDocumentExpiration =
      _CBLDatabase_GetDocumentExpirationPtr.asFunction<
          DartCBLDatabase_GetDocumentExpiration>();

  /// Sets or clears the expiration time of a document. @warning <b>Deprecated
  /// :</b> Use CBLCollection_SetDocumentExpiration instead. @param db The
  /// database. @param docID The ID of the document. @param expiration The
  /// expiration time as a CBLTimestamp (milliseconds since Unix epoch), or 0 if
  /// the document should never expire. @param outError On failure, an error is
  /// written here. @return True on success, false on failure.
  bool CBLDatabase_SetDocumentExpiration(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    int expiration,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_SetDocumentExpiration(
      db,
      docID,
      expiration,
      outError,
    );
  }

  late final _CBLDatabase_SetDocumentExpirationPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_SetDocumentExpiration>>(
          'CBLDatabase_SetDocumentExpiration');
  late final _CBLDatabase_SetDocumentExpiration =
      _CBLDatabase_SetDocumentExpirationPtr.asFunction<
          DartCBLDatabase_SetDocumentExpiration>();

  /// Registers a document change listener callback. It will be called after a
  /// specific document is changed on disk. @warning <b>Deprecated :</b> Use
  /// CBLCollection_AddDocumentChangeListener on the default collection instead.
  /// @param db The database to observe. @param docID The ID of the document to
  /// observe. @param listener The callback to be invoked. @param context An
  /// opaque value that will be passed to the callback. @return A token to be
  /// passed to \ref CBLListener_Remove when it's time to remove the listener.
  ffi.Pointer<CBLListenerToken> CBLDatabase_AddDocumentChangeListener(
    ffi.Pointer<CBLDatabase> db,
    FLString docID,
    CBLDocumentChangeListener listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLDatabase_AddDocumentChangeListener(
      db,
      docID,
      listener,
      context,
    );
  }

  late final _CBLDatabase_AddDocumentChangeListenerPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_AddDocumentChangeListener>>(
          'CBLDatabase_AddDocumentChangeListener');
  late final _CBLDatabase_AddDocumentChangeListener =
      _CBLDatabase_AddDocumentChangeListenerPtr.asFunction<
          DartCBLDatabase_AddDocumentChangeListener>();

  /// Creates a new query by compiling the input string. This is fast, but not
  /// instantaneous. If you need to run the same query many times, keep the \ref
  /// CBLQuery around instead of compiling it each time. If you need to run
  /// related queries with only some values different, create one query with
  /// placeholder parameter(s), and substitute the desired value(s) with \ref
  /// CBLQuery_SetParameters each time you run the query. @note You must release
  /// the \ref CBLQuery when you're finished with it. @param db The database to
  /// query. @param language The query language,
  /// [JSON](https://github.com/couchbase/couchbase-lite-core/wiki/JSON-Query-Schema)
  /// or
  /// [N1QL](https://docs.couchbase.com/server/4.0/n1ql/n1ql-language-reference/index.html).
  /// @param queryString The query string. @param outErrorPos If non-NULL, then
  /// on a parse error the approximate byte offset in the input expression will
  /// be stored here (or -1 if not known/applicable.) @param outError On
  /// failure, the error will be written here. @return The new query object.
  ffi.Pointer<CBLQuery> CBLDatabase_CreateQuery(
    ffi.Pointer<CBLDatabase> db,
    int language,
    FLString queryString,
    ffi.Pointer<ffi.Int> outErrorPos,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_CreateQuery(
      db,
      language,
      queryString,
      outErrorPos,
      outError,
    );
  }

  late final _CBLDatabase_CreateQueryPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_CreateQuery>>(
          'CBLDatabase_CreateQuery');
  late final _CBLDatabase_CreateQuery =
      _CBLDatabase_CreateQueryPtr.asFunction<DartCBLDatabase_CreateQuery>();

  /// Assigns values to the query's parameters. These values will be substited
  /// for those parameters whenever the query is executed, until they are next
  /// assigned.
  ///
  /// Parameters are specified in the query source as e.g. `$PARAM` (N1QL) or
  /// `["$PARAM"]` (JSON). In this example, the `parameters` dictionary to this
  /// call should have a key `PARAM` that maps to the value of the parameter.
  /// @param query The query. @param parameters The parameters in the form of a
  /// Fleece \ref FLDict "dictionary" whose keys are the parameter names. (It's
  /// easiest to construct this by using the mutable API, i.e. calling \ref
  /// FLMutableDict_New and adding keys/values.)
  void CBLQuery_SetParameters(
    ffi.Pointer<CBLQuery> query,
    FLDict parameters,
  ) {
    return _CBLQuery_SetParameters(
      query,
      parameters,
    );
  }

  late final _CBLQuery_SetParametersPtr =
      _lookup<ffi.NativeFunction<NativeCBLQuery_SetParameters>>(
          'CBLQuery_SetParameters');
  late final _CBLQuery_SetParameters =
      _CBLQuery_SetParametersPtr.asFunction<DartCBLQuery_SetParameters>();

  /// Returns the query's current parameter bindings, if any.
  FLDict CBLQuery_Parameters(
    ffi.Pointer<CBLQuery> query,
  ) {
    return _CBLQuery_Parameters(
      query,
    );
  }

  late final _CBLQuery_ParametersPtr =
      _lookup<ffi.NativeFunction<NativeCBLQuery_Parameters>>(
          'CBLQuery_Parameters');
  late final _CBLQuery_Parameters =
      _CBLQuery_ParametersPtr.asFunction<DartCBLQuery_Parameters>();

  /// Runs the query, returning the results. To obtain the results you'll
  /// typically call \ref CBLResultSet_Next in a `while` loop, examining the
  /// values in the \ref CBLResultSet each time around. @note You must release
  /// the result set when you're finished with it.
  ffi.Pointer<CBLResultSet> CBLQuery_Execute(
    ffi.Pointer<CBLQuery> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLQuery_Execute(
      arg0,
      outError,
    );
  }

  late final _CBLQuery_ExecutePtr =
      _lookup<ffi.NativeFunction<NativeCBLQuery_Execute>>('CBLQuery_Execute');
  late final _CBLQuery_Execute =
      _CBLQuery_ExecutePtr.asFunction<DartCBLQuery_Execute>();

  /// Returns information about the query, including the translated SQLite form,
  /// and the search strategy. You can use this to help optimize the query: the
  /// word `SCAN` in the strategy indicates a linear scan of the entire
  /// database, which should be avoided by adding an index. The strategy will
  /// also show which index(es), if any, are used. @note You are responsible for
  /// releasing the result by calling \ref FLSliceResult_Release.
  FLSliceResult CBLQuery_Explain(
    ffi.Pointer<CBLQuery> arg0,
  ) {
    return _CBLQuery_Explain(
      arg0,
    );
  }

  late final _CBLQuery_ExplainPtr =
      _lookup<ffi.NativeFunction<NativeCBLQuery_Explain>>('CBLQuery_Explain');
  late final _CBLQuery_Explain =
      _CBLQuery_ExplainPtr.asFunction<DartCBLQuery_Explain>();

  /// Returns the number of columns in each result.
  int CBLQuery_ColumnCount(
    ffi.Pointer<CBLQuery> arg0,
  ) {
    return _CBLQuery_ColumnCount(
      arg0,
    );
  }

  late final _CBLQuery_ColumnCountPtr =
      _lookup<ffi.NativeFunction<NativeCBLQuery_ColumnCount>>(
          'CBLQuery_ColumnCount');
  late final _CBLQuery_ColumnCount =
      _CBLQuery_ColumnCountPtr.asFunction<DartCBLQuery_ColumnCount>();

  /// Returns the name of a column in the result. The column name is based on
  /// its expression in the `SELECT...` or `WHAT:` section of the query. A
  /// column that returns a property or property path will be named after that
  /// property. A column that returns an expression will have an
  /// automatically-generated name like `$1`. To give a column a custom name,
  /// use the `AS` syntax in the query. Every column is guaranteed to have a
  /// unique name.
  FLSlice CBLQuery_ColumnName(
    ffi.Pointer<CBLQuery> arg0,
    int columnIndex,
  ) {
    return _CBLQuery_ColumnName(
      arg0,
      columnIndex,
    );
  }

  late final _CBLQuery_ColumnNamePtr =
      _lookup<ffi.NativeFunction<NativeCBLQuery_ColumnName>>(
          'CBLQuery_ColumnName');
  late final _CBLQuery_ColumnName =
      _CBLQuery_ColumnNamePtr.asFunction<DartCBLQuery_ColumnName>();

  /// Moves the result-set iterator to the next result. Returns false if there
  /// are no more results. @warning This must be called _before_ examining the
  /// first result.
  bool CBLResultSet_Next(
    ffi.Pointer<CBLResultSet> arg0,
  ) {
    return _CBLResultSet_Next(
      arg0,
    );
  }

  late final _CBLResultSet_NextPtr =
      _lookup<ffi.NativeFunction<NativeCBLResultSet_Next>>('CBLResultSet_Next');
  late final _CBLResultSet_Next =
      _CBLResultSet_NextPtr.asFunction<DartCBLResultSet_Next>();

  /// Returns the value of a column of the current result, given its
  /// (zero-based) numeric index. This may return a NULL pointer, indicating
  /// `MISSING`, if the value doesn't exist, e.g. if the column is a property
  /// that doesn't exist in the document.
  FLValue CBLResultSet_ValueAtIndex(
    ffi.Pointer<CBLResultSet> arg0,
    int index,
  ) {
    return _CBLResultSet_ValueAtIndex(
      arg0,
      index,
    );
  }

  late final _CBLResultSet_ValueAtIndexPtr =
      _lookup<ffi.NativeFunction<NativeCBLResultSet_ValueAtIndex>>(
          'CBLResultSet_ValueAtIndex');
  late final _CBLResultSet_ValueAtIndex =
      _CBLResultSet_ValueAtIndexPtr.asFunction<DartCBLResultSet_ValueAtIndex>();

  /// Returns the value of a column of the current result, given its name. This
  /// may return a NULL pointer, indicating `MISSING`, if the value doesn't
  /// exist, e.g. if the column is a property that doesn't exist in the
  /// document. (Or, of course, if the key is not a column name in this query.)
  /// @note See \ref CBLQuery_ColumnName for a discussion of column names.
  FLValue CBLResultSet_ValueForKey(
    ffi.Pointer<CBLResultSet> arg0,
    FLString key,
  ) {
    return _CBLResultSet_ValueForKey(
      arg0,
      key,
    );
  }

  late final _CBLResultSet_ValueForKeyPtr =
      _lookup<ffi.NativeFunction<NativeCBLResultSet_ValueForKey>>(
          'CBLResultSet_ValueForKey');
  late final _CBLResultSet_ValueForKey =
      _CBLResultSet_ValueForKeyPtr.asFunction<DartCBLResultSet_ValueForKey>();

  /// Returns the current result as an array of column values. @warning The
  /// array reference is only valid until the result-set is advanced or
  /// released. If you want to keep it for longer, call \ref FLArray_Retain (and
  /// release it when done.)
  FLArray CBLResultSet_ResultArray(
    ffi.Pointer<CBLResultSet> arg0,
  ) {
    return _CBLResultSet_ResultArray(
      arg0,
    );
  }

  late final _CBLResultSet_ResultArrayPtr =
      _lookup<ffi.NativeFunction<NativeCBLResultSet_ResultArray>>(
          'CBLResultSet_ResultArray');
  late final _CBLResultSet_ResultArray =
      _CBLResultSet_ResultArrayPtr.asFunction<DartCBLResultSet_ResultArray>();

  /// Returns the current result as a dictionary mapping column names to values.
  /// @warning The dict reference is only valid until the result-set is advanced
  /// or released. If you want to keep it for longer, call \ref FLDict_Retain
  /// (and release it when done.)
  FLDict CBLResultSet_ResultDict(
    ffi.Pointer<CBLResultSet> arg0,
  ) {
    return _CBLResultSet_ResultDict(
      arg0,
    );
  }

  late final _CBLResultSet_ResultDictPtr =
      _lookup<ffi.NativeFunction<NativeCBLResultSet_ResultDict>>(
          'CBLResultSet_ResultDict');
  late final _CBLResultSet_ResultDict =
      _CBLResultSet_ResultDictPtr.asFunction<DartCBLResultSet_ResultDict>();

  /// Returns the Query that created this ResultSet.
  ffi.Pointer<CBLQuery> CBLResultSet_GetQuery(
    ffi.Pointer<CBLResultSet> rs,
  ) {
    return _CBLResultSet_GetQuery(
      rs,
    );
  }

  late final _CBLResultSet_GetQueryPtr =
      _lookup<ffi.NativeFunction<NativeCBLResultSet_GetQuery>>(
          'CBLResultSet_GetQuery');
  late final _CBLResultSet_GetQuery =
      _CBLResultSet_GetQueryPtr.asFunction<DartCBLResultSet_GetQuery>();

  /// Registers a change listener callback with a query, turning it into a "live
  /// query" until the listener is removed (via \ref CBLListener_Remove).
  ///
  /// When the first change listener is added, the query will run (in the
  /// background) and notify the listener(s) of the results when ready. After
  /// that, it will run in the background after the database changes, and only
  /// notify the listeners when the result set changes. @param query The query
  /// to observe. @param listener The callback to be invoked. @param context An
  /// opaque value that will be passed to the callback. @return A token to be
  /// passed to \ref CBLListener_Remove when it's time to remove the listener.
  ffi.Pointer<CBLListenerToken> CBLQuery_AddChangeListener(
    ffi.Pointer<CBLQuery> query,
    CBLQueryChangeListener listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLQuery_AddChangeListener(
      query,
      listener,
      context,
    );
  }

  late final _CBLQuery_AddChangeListenerPtr =
      _lookup<ffi.NativeFunction<NativeCBLQuery_AddChangeListener>>(
          'CBLQuery_AddChangeListener');
  late final _CBLQuery_AddChangeListener = _CBLQuery_AddChangeListenerPtr
      .asFunction<DartCBLQuery_AddChangeListener>();

  /// Returns the query's _entire_ current result set, after it's been announced
  /// via a call to the listener's callback. @note You must release the result
  /// set when you're finished with it. @param query The query being listened
  /// to. @param listener The query listener that was notified. @param outError
  /// If the query failed to run, the error will be stored here. @return A new
  /// object containing the query's current results, or NULL if the query failed
  /// to run.
  ffi.Pointer<CBLResultSet> CBLQuery_CopyCurrentResults(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> listener,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLQuery_CopyCurrentResults(
      query,
      listener,
      outError,
    );
  }

  late final _CBLQuery_CopyCurrentResultsPtr =
      _lookup<ffi.NativeFunction<NativeCBLQuery_CopyCurrentResults>>(
          'CBLQuery_CopyCurrentResults');
  late final _CBLQuery_CopyCurrentResults = _CBLQuery_CopyCurrentResultsPtr
      .asFunction<DartCBLQuery_CopyCurrentResults>();

  /// Creates a value index. Indexes are persistent. If an identical index with
  /// that name already exists, nothing happens (and no error is returned.) If a
  /// non-identical index with that name already exists, it is deleted and
  /// re-created. @warning <b>Deprecated :</b> Use
  /// CBLCollection_CreateValueIndex on the default collection instead.
  bool CBLDatabase_CreateValueIndex(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_CreateValueIndex(
      db,
      name,
      config,
      outError,
    );
  }

  late final _CBLDatabase_CreateValueIndexPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_CreateValueIndex>>(
          'CBLDatabase_CreateValueIndex');
  late final _CBLDatabase_CreateValueIndex = _CBLDatabase_CreateValueIndexPtr
      .asFunction<DartCBLDatabase_CreateValueIndex>();

  /// Creates a full-text index. Indexes are persistent. If an identical index
  /// with that name already exists, nothing happens (and no error is returned.)
  /// If a non-identical index with that name already exists, it is deleted and
  /// re-created. @warning <b>Deprecated :</b> Use
  /// CBLCollection_CreateFullTextIndex on the default collection instead.
  bool CBLDatabase_CreateFullTextIndex(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_CreateFullTextIndex(
      db,
      name,
      config,
      outError,
    );
  }

  late final _CBLDatabase_CreateFullTextIndexPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_CreateFullTextIndex>>(
          'CBLDatabase_CreateFullTextIndex');
  late final _CBLDatabase_CreateFullTextIndex =
      _CBLDatabase_CreateFullTextIndexPtr.asFunction<
          DartCBLDatabase_CreateFullTextIndex>();

  /// Deletes an index given its name. @warning <b>Deprecated :</b> Use
  /// CBLCollection_DeleteIndex on the default collection instead.
  bool CBLDatabase_DeleteIndex(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_DeleteIndex(
      db,
      name,
      outError,
    );
  }

  late final _CBLDatabase_DeleteIndexPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_DeleteIndex>>(
          'CBLDatabase_DeleteIndex');
  late final _CBLDatabase_DeleteIndex =
      _CBLDatabase_DeleteIndexPtr.asFunction<DartCBLDatabase_DeleteIndex>();

  /// Returns the names of the indexes on this database, as a Fleece array of
  /// strings. @note You are responsible for releasing the returned Fleece
  /// array. @warning <b>Deprecated :</b> Use CBLCollection_GetIndexNames on the
  /// default collection instead.
  FLArray CBLDatabase_GetIndexNames(
    ffi.Pointer<CBLDatabase> db,
  ) {
    return _CBLDatabase_GetIndexNames(
      db,
    );
  }

  late final _CBLDatabase_GetIndexNamesPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_GetIndexNames>>(
          'CBLDatabase_GetIndexNames');
  late final _CBLDatabase_GetIndexNames =
      _CBLDatabase_GetIndexNamesPtr.asFunction<DartCBLDatabase_GetIndexNames>();

  /// The default collection's name.
  late final ffi.Pointer<FLString> _kCBLDefaultCollectionName =
      _lookup<FLString>('kCBLDefaultCollectionName');

  FLString get kCBLDefaultCollectionName => _kCBLDefaultCollectionName.ref;

  /// Returns the names of all existing scopes in the database. The scope exists
  /// when there is at least one collection created under the scope. The default
  /// scope is exceptional in that it will always exists even there are no
  /// collections under it. @note You are responsible for releasing the returned
  /// array. @param db The database. @param outError On failure, the error will
  /// be written here. @return The names of all existing scopes in the database,
  /// or NULL if an error occurred.
  FLMutableArray CBLDatabase_ScopeNames(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_ScopeNames(
      db,
      outError,
    );
  }

  late final _CBLDatabase_ScopeNamesPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_ScopeNames>>(
          'CBLDatabase_ScopeNames');
  late final _CBLDatabase_ScopeNames =
      _CBLDatabase_ScopeNamesPtr.asFunction<DartCBLDatabase_ScopeNames>();

  /// Returns the names of all collections in the scope. @note You are
  /// responsible for releasing the returned array. @param db The database.
  /// @param scopeName The name of the scope. @param outError On failure, the
  /// error will be written here. @return The names of all collections in the
  /// scope, or NULL if an error occurred.
  FLMutableArray CBLDatabase_CollectionNames(
    ffi.Pointer<CBLDatabase> db,
    FLString scopeName,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_CollectionNames(
      db,
      scopeName,
      outError,
    );
  }

  late final _CBLDatabase_CollectionNamesPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_CollectionNames>>(
          'CBLDatabase_CollectionNames');
  late final _CBLDatabase_CollectionNames = _CBLDatabase_CollectionNamesPtr
      .asFunction<DartCBLDatabase_CollectionNames>();

  /// Returns an existing scope with the given name. The scope exists when there
  /// is at least one collection created under the scope. The default scope is
  /// exception in that it will always exists even there are no collections
  /// under it. @note You are responsible for releasing the returned scope.
  /// @param db The database. @param scopeName The name of the scope. @param
  /// outError On failure, the error will be written here. @return A \ref
  /// CBLScope instance, or NULL if the scope doesn't exist or an error
  /// occurred.
  ffi.Pointer<CBLScope> CBLDatabase_Scope(
    ffi.Pointer<CBLDatabase> db,
    FLString scopeName,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_Scope(
      db,
      scopeName,
      outError,
    );
  }

  late final _CBLDatabase_ScopePtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_Scope>>('CBLDatabase_Scope');
  late final _CBLDatabase_Scope =
      _CBLDatabase_ScopePtr.asFunction<DartCBLDatabase_Scope>();

  /// Returns the existing collection with the given name and scope. @note You
  /// are responsible for releasing the returned collection. @param db The
  /// database. @param collectionName The name of the collection. @param
  /// scopeName The name of the scope. @param outError On failure, the error
  /// will be written here. @return A \ref CBLCollection instance, or NULL if
  /// the collection doesn't exist or an error occurred.
  ffi.Pointer<CBLCollection> CBLDatabase_Collection(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_Collection(
      db,
      collectionName,
      scopeName,
      outError,
    );
  }

  late final _CBLDatabase_CollectionPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_Collection>>(
          'CBLDatabase_Collection');
  late final _CBLDatabase_Collection =
      _CBLDatabase_CollectionPtr.asFunction<DartCBLDatabase_Collection>();

  /// Create a new collection. The naming rules of the collections and scopes
  /// are as follows:
  ///
  /// - Must be between 1 and 251 characters in length.
  /// - Can only contain the characters A-Z, a-z, 0-9, and the symbols \_, -,
  ///   and %.
  /// - Cannot start with \_ or %.
  /// - Both scope and collection names are case sensitive. @note If the
  ///   collection already exists, the existing collection will be returned.
  ///   @note You are responsible for releasing the returned collection. @param
  ///   db The database. @param collectionName The name of the collection.
  ///   @param scopeName The name of the scope. @param outError On failure, the
  ///   error will be written here. @return A \ref CBLCollection instance, or
  ///   NULL if an error occurred.
  ffi.Pointer<CBLCollection> CBLDatabase_CreateCollection(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_CreateCollection(
      db,
      collectionName,
      scopeName,
      outError,
    );
  }

  late final _CBLDatabase_CreateCollectionPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_CreateCollection>>(
          'CBLDatabase_CreateCollection');
  late final _CBLDatabase_CreateCollection = _CBLDatabase_CreateCollectionPtr
      .asFunction<DartCBLDatabase_CreateCollection>();

  /// Delete an existing collection. @note The default collection cannot be
  /// deleted. @param db The database. @param collectionName The name of the
  /// collection. @param scopeName The name of the scope. @param outError On
  /// failure, the error will be written here. @return True if success, or False
  /// if an error occurred.
  bool CBLDatabase_DeleteCollection(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_DeleteCollection(
      db,
      collectionName,
      scopeName,
      outError,
    );
  }

  late final _CBLDatabase_DeleteCollectionPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_DeleteCollection>>(
          'CBLDatabase_DeleteCollection');
  late final _CBLDatabase_DeleteCollection = _CBLDatabase_DeleteCollectionPtr
      .asFunction<DartCBLDatabase_DeleteCollection>();

  /// Returns the default scope. @note The default scope always exist even there
  /// are no collections under it. @note You are responsible for releasing the
  /// returned scope. @param db The database. @param outError On failure, the
  /// error will be written here. @return A \ref CBLScope instance, or NULL if
  /// an error occurred.
  ffi.Pointer<CBLScope> CBLDatabase_DefaultScope(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_DefaultScope(
      db,
      outError,
    );
  }

  late final _CBLDatabase_DefaultScopePtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_DefaultScope>>(
          'CBLDatabase_DefaultScope');
  late final _CBLDatabase_DefaultScope =
      _CBLDatabase_DefaultScopePtr.asFunction<DartCBLDatabase_DefaultScope>();

  /// Returns the default collection. @note The default collection may not exist
  /// if it was deleted. Also, the default collection cannot be recreated after
  /// being deleted. @note You are responsible for releasing the returned
  /// collection. @param db The database. @param outError On failure, the error
  /// will be written here. @return A \ref CBLCollection instance, or NULL if
  /// the default collection doesn't exist or an error occurred.
  ffi.Pointer<CBLCollection> CBLDatabase_DefaultCollection(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_DefaultCollection(
      db,
      outError,
    );
  }

  late final _CBLDatabase_DefaultCollectionPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_DefaultCollection>>(
          'CBLDatabase_DefaultCollection');
  late final _CBLDatabase_DefaultCollection = _CBLDatabase_DefaultCollectionPtr
      .asFunction<DartCBLDatabase_DefaultCollection>();

  /// Returns the scope of the collection. @note You are responsible for
  /// releasing the returned scope. @param collection The collection. @return A
  /// \ref CBLScope instance.
  ffi.Pointer<CBLScope> CBLCollection_Scope(
    ffi.Pointer<CBLCollection> collection,
  ) {
    return _CBLCollection_Scope(
      collection,
    );
  }

  late final _CBLCollection_ScopePtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_Scope>>(
          'CBLCollection_Scope');
  late final _CBLCollection_Scope =
      _CBLCollection_ScopePtr.asFunction<DartCBLCollection_Scope>();

  /// Returns the collection name. @param collection The collection. @return The
  /// name of the collection.
  FLString CBLCollection_Name(
    ffi.Pointer<CBLCollection> collection,
  ) {
    return _CBLCollection_Name(
      collection,
    );
  }

  late final _CBLCollection_NamePtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_Name>>(
          'CBLCollection_Name');
  late final _CBLCollection_Name =
      _CBLCollection_NamePtr.asFunction<DartCBLCollection_Name>();

  /// Returns the number of documents in the collection. @param collection The
  /// collection. @return the number of documents in the collection.
  int CBLCollection_Count(
    ffi.Pointer<CBLCollection> collection,
  ) {
    return _CBLCollection_Count(
      collection,
    );
  }

  late final _CBLCollection_CountPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_Count>>(
          'CBLCollection_Count');
  late final _CBLCollection_Count =
      _CBLCollection_CountPtr.asFunction<DartCBLCollection_Count>();

  /// Reads a document from the collection, creating a new (immutable) \ref
  /// CBLDocument object. Each call to this function creates a new object (which
  /// must later be released.) @note If you are reading the document in order to
  /// make changes to it, call CBLCollection_GetMutableDocument instead. @param
  /// collection The collection. @param docID The ID of the document. @param
  /// outError On failure, the error will be written here. (A nonexistent
  /// document is not considered a failure; in that event the error code will be
  /// zero.) @return A new \ref CBLDocument instance, or NULL if the doc doesn't
  /// exist or an error occurred.
  ffi.Pointer<CBLDocument> CBLCollection_GetDocument(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_GetDocument(
      collection,
      docID,
      outError,
    );
  }

  late final _CBLCollection_GetDocumentPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_GetDocument>>(
          'CBLCollection_GetDocument');
  late final _CBLCollection_GetDocument =
      _CBLCollection_GetDocumentPtr.asFunction<DartCBLCollection_GetDocument>();

  /// Saves a (mutable) document to the collection. @warning If a newer revision
  /// has been saved since the doc was loaded, it will be overwritten by this
  /// one. This can lead to data loss! To avoid this, call \ref
  /// CBLCollection_SaveDocumentWithConcurrencyControl or \ref
  /// CBLCollection_SaveDocumentWithConflictHandler instead. @param collection
  /// The collection to save to. @param doc The mutable document to save. @param
  /// outError On failure, the error will be written here. @return True on
  /// success, false on failure.
  bool CBLCollection_SaveDocument(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_SaveDocument(
      collection,
      doc,
      outError,
    );
  }

  late final _CBLCollection_SaveDocumentPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_SaveDocument>>(
          'CBLCollection_SaveDocument');
  late final _CBLCollection_SaveDocument = _CBLCollection_SaveDocumentPtr
      .asFunction<DartCBLCollection_SaveDocument>();

  /// Saves a (mutable) document to the collection. If a conflicting revision
  /// has been saved since \p doc was loaded, the \p concurrency parameter
  /// specifies whether the save should fail, or the conflicting revision should
  /// be overwritten with the revision being saved. If you need finer-grained
  /// control, call \ref CBLCollection_SaveDocumentWithConflictHandler instead.
  /// @param collection The collection to save to. @param doc The mutable
  /// document to save. @param concurrency Conflict-handling strategy (fail or
  /// overwrite). @param outError On failure, the error will be written here.
  /// @return True on success, false on failure.
  bool CBLCollection_SaveDocumentWithConcurrencyControl(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    int concurrency,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_SaveDocumentWithConcurrencyControl(
      collection,
      doc,
      concurrency,
      outError,
    );
  }

  late final _CBLCollection_SaveDocumentWithConcurrencyControlPtr = _lookup<
          ffi.NativeFunction<
              NativeCBLCollection_SaveDocumentWithConcurrencyControl>>(
      'CBLCollection_SaveDocumentWithConcurrencyControl');
  late final _CBLCollection_SaveDocumentWithConcurrencyControl =
      _CBLCollection_SaveDocumentWithConcurrencyControlPtr.asFunction<
          DartCBLCollection_SaveDocumentWithConcurrencyControl>();

  /// Saves a (mutable) document to the collection, allowing for custom conflict
  /// handling in the event that the document has been updated since \p doc was
  /// loaded. @param collection The collection to save to. @param doc The
  /// mutable document to save. @param conflictHandler The callback to be
  /// invoked if there is a conflict. @param context An arbitrary value to be
  /// passed to the \p conflictHandler. @param outError On failure, the error
  /// will be written here. @return True on success, false on failure.
  bool CBLCollection_SaveDocumentWithConflictHandler(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    CBLConflictHandler conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_SaveDocumentWithConflictHandler(
      collection,
      doc,
      conflictHandler,
      context,
      outError,
    );
  }

  late final _CBLCollection_SaveDocumentWithConflictHandlerPtr = _lookup<
          ffi
          .NativeFunction<NativeCBLCollection_SaveDocumentWithConflictHandler>>(
      'CBLCollection_SaveDocumentWithConflictHandler');
  late final _CBLCollection_SaveDocumentWithConflictHandler =
      _CBLCollection_SaveDocumentWithConflictHandlerPtr.asFunction<
          DartCBLCollection_SaveDocumentWithConflictHandler>();

  /// Deletes a document from the collection. Deletions are replicated. @warning
  /// You are still responsible for releasing the CBLDocument. @param collection
  /// The collection containing the document. @param document The document to
  /// delete. @param outError On failure, the error will be written here.
  /// @return True if the document was deleted, false if an error occurred.
  bool CBLCollection_DeleteDocument(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_DeleteDocument(
      collection,
      document,
      outError,
    );
  }

  late final _CBLCollection_DeleteDocumentPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_DeleteDocument>>(
          'CBLCollection_DeleteDocument');
  late final _CBLCollection_DeleteDocument = _CBLCollection_DeleteDocumentPtr
      .asFunction<DartCBLCollection_DeleteDocument>();

  /// Deletes a document from the collection. Deletions are replicated. @warning
  /// You are still responsible for releasing the CBLDocument. @param collection
  /// The collection containing the document. @param document The document to
  /// delete. @param concurrency Conflict-handling strategy. @param outError On
  /// failure, the error will be written here. @return True if the document was
  /// deleted, false if an error occurred.
  bool CBLCollection_DeleteDocumentWithConcurrencyControl(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    int concurrency,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_DeleteDocumentWithConcurrencyControl(
      collection,
      document,
      concurrency,
      outError,
    );
  }

  late final _CBLCollection_DeleteDocumentWithConcurrencyControlPtr = _lookup<
          ffi.NativeFunction<
              NativeCBLCollection_DeleteDocumentWithConcurrencyControl>>(
      'CBLCollection_DeleteDocumentWithConcurrencyControl');
  late final _CBLCollection_DeleteDocumentWithConcurrencyControl =
      _CBLCollection_DeleteDocumentWithConcurrencyControlPtr.asFunction<
          DartCBLCollection_DeleteDocumentWithConcurrencyControl>();

  /// Purges a document. This removes all traces of the document from the
  /// collection. Purges are _not_ replicated. If the document is changed on a
  /// server, it will be re-created when pulled. @warning You are still
  /// responsible for releasing the \ref CBLDocument reference. @note If you
  /// don't have the document in memory already, \ref
  /// CBLCollection_PurgeDocumentByID is a simpler shortcut. @param collection
  /// The collection containing the document. @param document The document to
  /// delete. @param outError On failure, the error will be written here.
  /// @return True if the document was purged, false if it doesn't exist or the
  /// purge failed.
  bool CBLCollection_PurgeDocument(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_PurgeDocument(
      collection,
      document,
      outError,
    );
  }

  late final _CBLCollection_PurgeDocumentPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_PurgeDocument>>(
          'CBLCollection_PurgeDocument');
  late final _CBLCollection_PurgeDocument = _CBLCollection_PurgeDocumentPtr
      .asFunction<DartCBLCollection_PurgeDocument>();

  /// Purges a document, given only its ID. @note If no document with that ID
  /// exists, this function will return false but the error code will be zero.
  /// @param collection The collection. @param docID The document ID to purge.
  /// @param outError On failure, the error will be written here. @return True
  /// if the document was purged, false if it doesn't exist or the purge failed.
  bool CBLCollection_PurgeDocumentByID(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_PurgeDocumentByID(
      collection,
      docID,
      outError,
    );
  }

  late final _CBLCollection_PurgeDocumentByIDPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_PurgeDocumentByID>>(
          'CBLCollection_PurgeDocumentByID');
  late final _CBLCollection_PurgeDocumentByID =
      _CBLCollection_PurgeDocumentByIDPtr.asFunction<
          DartCBLCollection_PurgeDocumentByID>();

  /// Returns the time, if any, at which a given document will expire and be
  /// purged. Documents don't normally expire; you have to call \ref
  /// CBLCollection_SetDocumentExpiration to set a document's expiration time.
  /// @param collection The collection. @param docID The ID of the document.
  /// @param outError On failure, an error is written here. @return The
  /// expiration time as a CBLTimestamp (milliseconds since Unix epoch), or 0 if
  /// the document does not have an expiration, or -1 if the call failed.
  int CBLCollection_GetDocumentExpiration(
    ffi.Pointer<CBLCollection> collection,
    FLSlice docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_GetDocumentExpiration(
      collection,
      docID,
      outError,
    );
  }

  late final _CBLCollection_GetDocumentExpirationPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_GetDocumentExpiration>>(
          'CBLCollection_GetDocumentExpiration');
  late final _CBLCollection_GetDocumentExpiration =
      _CBLCollection_GetDocumentExpirationPtr.asFunction<
          DartCBLCollection_GetDocumentExpiration>();

  /// Sets or clears the expiration time of a document. @param collection The
  /// collection. @param docID The ID of the document. @param expiration The
  /// expiration time as a CBLTimestamp (milliseconds since Unix epoch), or 0 if
  /// the document should never expire. @param outError On failure, an error is
  /// written here. @return True on success, false on failure.
  bool CBLCollection_SetDocumentExpiration(
    ffi.Pointer<CBLCollection> collection,
    FLSlice docID,
    int expiration,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_SetDocumentExpiration(
      collection,
      docID,
      expiration,
      outError,
    );
  }

  late final _CBLCollection_SetDocumentExpirationPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_SetDocumentExpiration>>(
          'CBLCollection_SetDocumentExpiration');
  late final _CBLCollection_SetDocumentExpiration =
      _CBLCollection_SetDocumentExpirationPtr.asFunction<
          DartCBLCollection_SetDocumentExpiration>();

  /// Reads a document from the collection, in mutable form that can be updated
  /// and saved. (This function is otherwise identical to \ref
  /// CBLCollection_GetDocument.) @note You must release the document when
  /// you're done with it. @param collection The collection. @param docID The ID
  /// of the document. @param outError On failure, the error will be written
  /// here. (A nonexistent document is not considered a failure; in that event
  /// the error code will be zero.) @return A new \ref CBLDocument instance, or
  /// NULL if the doc doesn't exist or an error occurred.
  ffi.Pointer<CBLDocument> CBLCollection_GetMutableDocument(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_GetMutableDocument(
      collection,
      docID,
      outError,
    );
  }

  late final _CBLCollection_GetMutableDocumentPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_GetMutableDocument>>(
          'CBLCollection_GetMutableDocument');
  late final _CBLCollection_GetMutableDocument =
      _CBLCollection_GetMutableDocumentPtr.asFunction<
          DartCBLCollection_GetMutableDocument>();

  /// Creates a value index in the collection. If an identical index with that
  /// name already exists, nothing happens (and no error is returned.) If a
  /// non-identical index with that name already exists, it is deleted and
  /// re-created. @param collection The collection. @param name The name of the
  /// index. @param config The index configuration. @param outError On failure,
  /// an error is written here. @return True on success, false on failure.
  bool CBLCollection_CreateValueIndex(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_CreateValueIndex(
      collection,
      name,
      config,
      outError,
    );
  }

  late final _CBLCollection_CreateValueIndexPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_CreateValueIndex>>(
          'CBLCollection_CreateValueIndex');
  late final _CBLCollection_CreateValueIndex =
      _CBLCollection_CreateValueIndexPtr.asFunction<
          DartCBLCollection_CreateValueIndex>();

  /// Creates a full-text index in the collection. If an identical index with
  /// that name already exists, nothing happens (and no error is returned.) If a
  /// non-identical index with that name already exists, it is deleted and
  /// re-created. @param collection The collection. @param name The name of the
  /// index. @param config The index configuration. @param outError On failure,
  /// an error is written here. @return True on success, false on failure.
  bool CBLCollection_CreateFullTextIndex(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_CreateFullTextIndex(
      collection,
      name,
      config,
      outError,
    );
  }

  late final _CBLCollection_CreateFullTextIndexPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_CreateFullTextIndex>>(
          'CBLCollection_CreateFullTextIndex');
  late final _CBLCollection_CreateFullTextIndex =
      _CBLCollection_CreateFullTextIndexPtr.asFunction<
          DartCBLCollection_CreateFullTextIndex>();

  /// Deletes an index in the collection by name. @param collection The
  /// collection. @param name The name of the index. @param outError On failure,
  /// an error is written here. @return True on success, false on failure.
  bool CBLCollection_DeleteIndex(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_DeleteIndex(
      collection,
      name,
      outError,
    );
  }

  late final _CBLCollection_DeleteIndexPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_DeleteIndex>>(
          'CBLCollection_DeleteIndex');
  late final _CBLCollection_DeleteIndex =
      _CBLCollection_DeleteIndexPtr.asFunction<DartCBLCollection_DeleteIndex>();

  /// Returns the names of the indexes in the collection, as a Fleece array of
  /// strings. @note You are responsible for releasing the returned Fleece
  /// array. @param collection The collection. @param outError On failure, an
  /// error is written here. @return The index names in the collection, or NULL
  /// if an error occurred.
  FLMutableArray CBLCollection_GetIndexNames(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLCollection_GetIndexNames(
      collection,
      outError,
    );
  }

  late final _CBLCollection_GetIndexNamesPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_GetIndexNames>>(
          'CBLCollection_GetIndexNames');
  late final _CBLCollection_GetIndexNames = _CBLCollection_GetIndexNamesPtr
      .asFunction<DartCBLCollection_GetIndexNames>();

  /// Registers a collection change listener callback. It will be called after
  /// one or more documents are changed on disk. @param collection The
  /// collection to observe. @param listener The callback to be invoked. @param
  /// context An opaque value that will be passed to the callback. @return A
  /// token to be passed to \ref CBLListener_Remove when it's time to remove the
  /// listener.
  ffi.Pointer<CBLListenerToken> CBLCollection_AddChangeListener(
    ffi.Pointer<CBLCollection> collection,
    CBLCollectionChangeListener listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLCollection_AddChangeListener(
      collection,
      listener,
      context,
    );
  }

  late final _CBLCollection_AddChangeListenerPtr =
      _lookup<ffi.NativeFunction<NativeCBLCollection_AddChangeListener>>(
          'CBLCollection_AddChangeListener');
  late final _CBLCollection_AddChangeListener =
      _CBLCollection_AddChangeListenerPtr.asFunction<
          DartCBLCollection_AddChangeListener>();

  /// Registers a document change listener callback. It will be called after a
  /// specific document is changed on disk. @param collection The collection to
  /// observe. @param docID The ID of the document to observe. @param listener
  /// The callback to be invoked. @param context An opaque value that will be
  /// passed to the callback. @return A token to be passed to \ref
  /// CBLListener_Remove when it's time to remove the listener.
  ffi.Pointer<CBLListenerToken> CBLCollection_AddDocumentChangeListener(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    CBLCollectionDocumentChangeListener listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLCollection_AddDocumentChangeListener(
      collection,
      docID,
      listener,
      context,
    );
  }

  late final _CBLCollection_AddDocumentChangeListenerPtr = _lookup<
          ffi.NativeFunction<NativeCBLCollection_AddDocumentChangeListener>>(
      'CBLCollection_AddDocumentChangeListener');
  late final _CBLCollection_AddDocumentChangeListener =
      _CBLCollection_AddDocumentChangeListenerPtr.asFunction<
          DartCBLCollection_AddDocumentChangeListener>();

  /// Returns the default database configuration.
  CBLDatabaseConfiguration CBLDatabaseConfiguration_Default() {
    return _CBLDatabaseConfiguration_Default();
  }

  late final _CBLDatabaseConfiguration_DefaultPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabaseConfiguration_Default>>(
          'CBLDatabaseConfiguration_Default');
  late final _CBLDatabaseConfiguration_Default =
      _CBLDatabaseConfiguration_DefaultPtr.asFunction<
          DartCBLDatabaseConfiguration_Default>();

  /// Derives an encryption key from a password. If your UI uses passwords, call
  /// this function to create the key used to encrypt the database. It is
  /// designed for security, and deliberately runs slowly to make brute-force
  /// attacks impractical. @param key The derived AES key will be stored here.
  /// @param password The input password, which can be any data. @return True on
  /// success, false if there was a problem deriving the key.
  bool CBLEncryptionKey_FromPassword(
    ffi.Pointer<CBLEncryptionKey> key,
    FLString password,
  ) {
    return _CBLEncryptionKey_FromPassword(
      key,
      password,
    );
  }

  late final _CBLEncryptionKey_FromPasswordPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptionKey_FromPassword>>(
          'CBLEncryptionKey_FromPassword');
  late final _CBLEncryptionKey_FromPassword = _CBLEncryptionKey_FromPasswordPtr
      .asFunction<DartCBLEncryptionKey_FromPassword>();

  /// VOLATILE API: Derives an encryption key from a password in a way that is
  /// compatible with certain variants of Couchbase Lite in which a slightly
  /// different hashing algorithm is used. The same notes apply as in
  /// CBLEncryptionKey_FromPassword @param key The derived AES key will be
  /// stored here. @param password The input password, which can be any data.
  /// @return True on success, false if there was a problem deriving the key.
  bool CBLEncryptionKey_FromPasswordOld(
    ffi.Pointer<CBLEncryptionKey> key,
    FLString password,
  ) {
    return _CBLEncryptionKey_FromPasswordOld(
      key,
      password,
    );
  }

  late final _CBLEncryptionKey_FromPasswordOldPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptionKey_FromPasswordOld>>(
          'CBLEncryptionKey_FromPasswordOld');
  late final _CBLEncryptionKey_FromPasswordOld =
      _CBLEncryptionKey_FromPasswordOldPtr.asFunction<
          DartCBLEncryptionKey_FromPasswordOld>();

  /// Returns true if a database with the given name exists in the given
  /// directory. @param name The database name (without the ".cblite2"
  /// extension.) @param inDirectory The directory containing the database. If
  /// NULL, `name` must be an absolute or relative path to the database.
  bool CBL_DatabaseExists(
    FLString name,
    FLString inDirectory,
  ) {
    return _CBL_DatabaseExists(
      name,
      inDirectory,
    );
  }

  late final _CBL_DatabaseExistsPtr =
      _lookup<ffi.NativeFunction<NativeCBL_DatabaseExists>>(
          'CBL_DatabaseExists');
  late final _CBL_DatabaseExists =
      _CBL_DatabaseExistsPtr.asFunction<DartCBL_DatabaseExists>();

  /// Copies a database file to a new location, and assigns it a new internal
  /// UUID to distinguish it from the original database when replicating. @param
  /// fromPath The full filesystem path to the original database (including
  /// extension). @param toName The new database name (without the ".cblite2"
  /// extension.) @param config The database configuration (directory and
  /// encryption option.) @param outError On return, will be set to the error
  /// that occurred, if applicable. @note While a database is open, one or more
  /// of its files may be in use. Attempting to copy a file, while it is in use,
  /// will fail. We recommend that you close a database before attempting to
  /// copy it.
  bool CBL_CopyDatabase(
    FLString fromPath,
    FLString toName,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBL_CopyDatabase(
      fromPath,
      toName,
      config,
      outError,
    );
  }

  late final _CBL_CopyDatabasePtr =
      _lookup<ffi.NativeFunction<NativeCBL_CopyDatabase>>('CBL_CopyDatabase');
  late final _CBL_CopyDatabase =
      _CBL_CopyDatabasePtr.asFunction<DartCBL_CopyDatabase>();

  /// Deletes a database file. If the database file is open, an error is
  /// returned. @param name The database name (without the ".cblite2"
  /// extension.) @param inDirectory The directory containing the database. If
  /// NULL, `name` must be an absolute or relative path to the database. @param
  /// outError On return, will be set to the error that occurred, or a 0 code if
  /// no error. @return True if the database was deleted, false if it doesn't
  /// exist or deletion failed. (You can tell the last two cases apart by
  /// looking at \p outError.)
  bool CBL_DeleteDatabase(
    FLString name,
    FLString inDirectory,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBL_DeleteDatabase(
      name,
      inDirectory,
      outError,
    );
  }

  late final _CBL_DeleteDatabasePtr =
      _lookup<ffi.NativeFunction<NativeCBL_DeleteDatabase>>(
          'CBL_DeleteDatabase');
  late final _CBL_DeleteDatabase =
      _CBL_DeleteDatabasePtr.asFunction<DartCBL_DeleteDatabase>();

  /// Opens a database, or creates it if it doesn't exist yet, returning a new
  /// \ref CBLDatabase instance. It's OK to open the same database file multiple
  /// times. Each \ref CBLDatabase instance is independent of the others (and
  /// must be separately closed and released.) @param name The database name
  /// (without the ".cblite2" extension.) @param config The database
  /// configuration (directory and encryption option.) @param outError On
  /// failure, the error will be written here. @return The new database object,
  /// or NULL on failure.
  ffi.Pointer<CBLDatabase> CBLDatabase_Open(
    FLSlice name,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_Open(
      name,
      config,
      outError,
    );
  }

  late final _CBLDatabase_OpenPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_Open>>('CBLDatabase_Open');
  late final _CBLDatabase_Open =
      _CBLDatabase_OpenPtr.asFunction<DartCBLDatabase_Open>();

  /// Closes an open database.
  bool CBLDatabase_Close(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_Close(
      arg0,
      outError,
    );
  }

  late final _CBLDatabase_ClosePtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_Close>>('CBLDatabase_Close');
  late final _CBLDatabase_Close =
      _CBLDatabase_ClosePtr.asFunction<DartCBLDatabase_Close>();

  /// Closes and deletes a database. If there are any other connections to the
  /// database, an error is returned.
  bool CBLDatabase_Delete(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_Delete(
      arg0,
      outError,
    );
  }

  late final _CBLDatabase_DeletePtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_Delete>>(
          'CBLDatabase_Delete');
  late final _CBLDatabase_Delete =
      _CBLDatabase_DeletePtr.asFunction<DartCBLDatabase_Delete>();

  /// Begins a transaction. You **must** later call \ref
  /// CBLDatabase_EndTransaction to commit or abort the transaction. @note
  /// Multiple writes are much faster when grouped in a transaction. @note
  /// Changes will not be visible to other CBLDatabase instances on the same
  /// database until the transaction ends. @note Transactions can nest. Changes
  /// are not committed until the outer transaction ends.
  bool CBLDatabase_BeginTransaction(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_BeginTransaction(
      arg0,
      outError,
    );
  }

  late final _CBLDatabase_BeginTransactionPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_BeginTransaction>>(
          'CBLDatabase_BeginTransaction');
  late final _CBLDatabase_BeginTransaction = _CBLDatabase_BeginTransactionPtr
      .asFunction<DartCBLDatabase_BeginTransaction>();

  /// Ends a transaction, either committing or aborting.
  bool CBLDatabase_EndTransaction(
    ffi.Pointer<CBLDatabase> arg0,
    bool commit,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_EndTransaction(
      arg0,
      commit,
      outError,
    );
  }

  late final _CBLDatabase_EndTransactionPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_EndTransaction>>(
          'CBLDatabase_EndTransaction');
  late final _CBLDatabase_EndTransaction = _CBLDatabase_EndTransactionPtr
      .asFunction<DartCBLDatabase_EndTransaction>();

  /// Encrypts or decrypts a database, or changes its encryption key.
  ///
  /// If \p newKey is NULL, or its \p algorithm is \ref kCBLEncryptionNone, the
  /// database will be decrypted. Otherwise the database will be encrypted with
  /// that key; if it was already encrypted, it will be re-encrypted with the
  /// new key.
  bool CBLDatabase_ChangeEncryptionKey(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLEncryptionKey> newKey,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_ChangeEncryptionKey(
      arg0,
      newKey,
      outError,
    );
  }

  late final _CBLDatabase_ChangeEncryptionKeyPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_ChangeEncryptionKey>>(
          'CBLDatabase_ChangeEncryptionKey');
  late final _CBLDatabase_ChangeEncryptionKey =
      _CBLDatabase_ChangeEncryptionKeyPtr.asFunction<
          DartCBLDatabase_ChangeEncryptionKey>();

  /// Performs database maintenance.
  bool CBLDatabase_PerformMaintenance(
    ffi.Pointer<CBLDatabase> db,
    int type,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_PerformMaintenance(
      db,
      type,
      outError,
    );
  }

  late final _CBLDatabase_PerformMaintenancePtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_PerformMaintenance>>(
          'CBLDatabase_PerformMaintenance');
  late final _CBLDatabase_PerformMaintenance =
      _CBLDatabase_PerformMaintenancePtr.asFunction<
          DartCBLDatabase_PerformMaintenance>();

  /// Returns the database's name.
  FLString CBLDatabase_Name(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Name(
      arg0,
    );
  }

  late final _CBLDatabase_NamePtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_Name>>('CBLDatabase_Name');
  late final _CBLDatabase_Name =
      _CBLDatabase_NamePtr.asFunction<DartCBLDatabase_Name>();

  /// Returns the database's full filesystem path, or null slice if the database
  /// is closed or deleted.
  FLStringResult CBLDatabase_Path(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Path(
      arg0,
    );
  }

  late final _CBLDatabase_PathPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_Path>>('CBLDatabase_Path');
  late final _CBLDatabase_Path =
      _CBLDatabase_PathPtr.asFunction<DartCBLDatabase_Path>();

  /// Returns the number of documents in the database, or zero if the database
  /// is closed or deleted. @warning <b>Deprecated :</b> Use CBLCollection_Count
  /// on the default collection instead.
  int CBLDatabase_Count(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Count(
      arg0,
    );
  }

  late final _CBLDatabase_CountPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_Count>>('CBLDatabase_Count');
  late final _CBLDatabase_Count =
      _CBLDatabase_CountPtr.asFunction<DartCBLDatabase_Count>();

  /// Returns the database's configuration, as given when it was opened.
  CBLDatabaseConfiguration CBLDatabase_Config(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Config(
      arg0,
    );
  }

  late final _CBLDatabase_ConfigPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_Config>>(
          'CBLDatabase_Config');
  late final _CBLDatabase_Config =
      _CBLDatabase_ConfigPtr.asFunction<DartCBLDatabase_Config>();

  /// Registers a default collection change listener callback. It will be called
  /// after one or more documents are changed on disk. @warning <b>Deprecated
  /// :</b> Use CBLCollection_AddChangeListener on the default collection
  /// instead. @param db The database to observe. @param listener The callback
  /// to be invoked. @param context An opaque value that will be passed to the
  /// callback. @return A token to be passed to \ref CBLListener_Remove when
  /// it's time to remove the listener.
  ffi.Pointer<CBLListenerToken> CBLDatabase_AddChangeListener(
    ffi.Pointer<CBLDatabase> db,
    CBLDatabaseChangeListener listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLDatabase_AddChangeListener(
      db,
      listener,
      context,
    );
  }

  late final _CBLDatabase_AddChangeListenerPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_AddChangeListener>>(
          'CBLDatabase_AddChangeListener');
  late final _CBLDatabase_AddChangeListener = _CBLDatabase_AddChangeListenerPtr
      .asFunction<DartCBLDatabase_AddChangeListener>();

  /// Switches the database to buffered-notification mode. Notifications for
  /// objects belonging to this database (documents, queries, replicators, and
  /// of course the database) will not be called immediately; your \ref
  /// CBLNotificationsReadyCallback will be called instead. @param db The
  /// database whose notifications are to be buffered. @param callback The
  /// function to be called when a notification is available. @param context An
  /// arbitrary value that will be passed to the callback.
  void CBLDatabase_BufferNotifications(
    ffi.Pointer<CBLDatabase> db,
    CBLNotificationsReadyCallback callback,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLDatabase_BufferNotifications(
      db,
      callback,
      context,
    );
  }

  late final _CBLDatabase_BufferNotificationsPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_BufferNotifications>>(
          'CBLDatabase_BufferNotifications');
  late final _CBLDatabase_BufferNotifications =
      _CBLDatabase_BufferNotificationsPtr.asFunction<
          DartCBLDatabase_BufferNotifications>();

  /// Immediately issues all pending notifications for this database, by calling
  /// their listener callbacks.
  void CBLDatabase_SendNotifications(
    ffi.Pointer<CBLDatabase> db,
  ) {
    return _CBLDatabase_SendNotifications(
      db,
    );
  }

  late final _CBLDatabase_SendNotificationsPtr =
      _lookup<ffi.NativeFunction<NativeCBLDatabase_SendNotifications>>(
          'CBLDatabase_SendNotifications');
  late final _CBLDatabase_SendNotifications = _CBLDatabase_SendNotificationsPtr
      .asFunction<DartCBLDatabase_SendNotifications>();

  /// The name of the HTTP cookie used by Sync Gateway to store session keys.
  late final ffi.Pointer<FLString> _kCBLAuthDefaultCookieName =
      _lookup<FLString>('kCBLAuthDefaultCookieName');

  FLString get kCBLAuthDefaultCookieName => _kCBLAuthDefaultCookieName.ref;

  /// Creates a new endpoint representing a server-based database at the given
  /// URL. The URL's scheme must be `ws` or `wss`, it must of course have a
  /// valid hostname, and its path must be the name of the database on that
  /// server.
  ///
  /// The port can be omitted; it defaults to 80 for `ws` and 443 for `wss`. For
  /// example: `wss://example.org/dbname`.
  ///
  /// If an invalid endpoint URL is specified, an error will be returned.
  ffi.Pointer<CBLEndpoint> CBLEndpoint_CreateWithURL(
    FLString url,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLEndpoint_CreateWithURL(
      url,
      outError,
    );
  }

  late final _CBLEndpoint_CreateWithURLPtr =
      _lookup<ffi.NativeFunction<NativeCBLEndpoint_CreateWithURL>>(
          'CBLEndpoint_CreateWithURL');
  late final _CBLEndpoint_CreateWithURL =
      _CBLEndpoint_CreateWithURLPtr.asFunction<DartCBLEndpoint_CreateWithURL>();

  /// Creates a new endpoint representing another local database. (Enterprise
  /// Edition only.)
  ffi.Pointer<CBLEndpoint> CBLEndpoint_CreateWithLocalDB(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLEndpoint_CreateWithLocalDB(
      arg0,
    );
  }

  late final _CBLEndpoint_CreateWithLocalDBPtr =
      _lookup<ffi.NativeFunction<NativeCBLEndpoint_CreateWithLocalDB>>(
          'CBLEndpoint_CreateWithLocalDB');
  late final _CBLEndpoint_CreateWithLocalDB = _CBLEndpoint_CreateWithLocalDBPtr
      .asFunction<DartCBLEndpoint_CreateWithLocalDB>();

  /// Frees a CBLEndpoint object.
  void CBLEndpoint_Free(
    ffi.Pointer<CBLEndpoint> arg0,
  ) {
    return _CBLEndpoint_Free(
      arg0,
    );
  }

  late final _CBLEndpoint_FreePtr =
      _lookup<ffi.NativeFunction<NativeCBLEndpoint_Free>>('CBLEndpoint_Free');
  late final _CBLEndpoint_Free =
      _CBLEndpoint_FreePtr.asFunction<DartCBLEndpoint_Free>();

  /// Creates an authenticator for HTTP Basic (username/password) auth.
  ffi.Pointer<CBLAuthenticator> CBLAuth_CreatePassword(
    FLString username,
    FLString password,
  ) {
    return _CBLAuth_CreatePassword(
      username,
      password,
    );
  }

  late final _CBLAuth_CreatePasswordPtr =
      _lookup<ffi.NativeFunction<NativeCBLAuth_CreatePassword>>(
          'CBLAuth_CreatePassword');
  late final _CBLAuth_CreatePassword =
      _CBLAuth_CreatePasswordPtr.asFunction<DartCBLAuth_CreatePassword>();

  /// Creates an authenticator using a Couchbase Sync Gateway login session
  /// identifier, and optionally a cookie name (pass NULL for the default.)
  ffi.Pointer<CBLAuthenticator> CBLAuth_CreateSession(
    FLString sessionID,
    FLString cookieName,
  ) {
    return _CBLAuth_CreateSession(
      sessionID,
      cookieName,
    );
  }

  late final _CBLAuth_CreateSessionPtr =
      _lookup<ffi.NativeFunction<NativeCBLAuth_CreateSession>>(
          'CBLAuth_CreateSession');
  late final _CBLAuth_CreateSession =
      _CBLAuth_CreateSessionPtr.asFunction<DartCBLAuth_CreateSession>();

  /// Frees a CBLAuthenticator object.
  void CBLAuth_Free(
    ffi.Pointer<CBLAuthenticator> arg0,
  ) {
    return _CBLAuth_Free(
      arg0,
    );
  }

  late final _CBLAuth_FreePtr =
      _lookup<ffi.NativeFunction<NativeCBLAuth_Free>>('CBLAuth_Free');
  late final _CBLAuth_Free = _CBLAuth_FreePtr.asFunction<DartCBLAuth_Free>();

  /// Default conflict resolver. This always returns `localDocument`.
  late final ffi.Pointer<CBLConflictResolver> _CBLDefaultConflictResolver =
      _lookup<CBLConflictResolver>('CBLDefaultConflictResolver');

  CBLConflictResolver get CBLDefaultConflictResolver =>
      _CBLDefaultConflictResolver.value;

  set CBLDefaultConflictResolver(CBLConflictResolver value) =>
      _CBLDefaultConflictResolver.value = value;

  /// Creates a replicator with the given configuration.
  ffi.Pointer<CBLReplicator> CBLReplicator_Create(
    ffi.Pointer<CBLReplicatorConfiguration> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLReplicator_Create(
      arg0,
      outError,
    );
  }

  late final _CBLReplicator_CreatePtr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_Create>>(
          'CBLReplicator_Create');
  late final _CBLReplicator_Create =
      _CBLReplicator_CreatePtr.asFunction<DartCBLReplicator_Create>();

  /// Returns the configuration of an existing replicator.
  ffi.Pointer<CBLReplicatorConfiguration> CBLReplicator_Config(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_Config(
      arg0,
    );
  }

  late final _CBLReplicator_ConfigPtr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_Config>>(
          'CBLReplicator_Config');
  late final _CBLReplicator_Config =
      _CBLReplicator_ConfigPtr.asFunction<DartCBLReplicator_Config>();

  /// Starts a replicator, asynchronously. Does nothing if it's already started.
  /// @param replicator The replicator instance. @param resetCheckpoint If true,
  /// the persistent saved state ("checkpoint") for this replication will be
  /// discarded, causing it to re-scan all documents. This significantly
  /// increases time and bandwidth (redundant docs are not transferred, but
  /// their IDs are) but can resolve unexpected problems with missing documents
  /// if one side or the other has gotten out of sync.
  void CBLReplicator_Start(
    ffi.Pointer<CBLReplicator> replicator,
    bool resetCheckpoint,
  ) {
    return _CBLReplicator_Start(
      replicator,
      resetCheckpoint,
    );
  }

  late final _CBLReplicator_StartPtr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_Start>>(
          'CBLReplicator_Start');
  late final _CBLReplicator_Start =
      _CBLReplicator_StartPtr.asFunction<DartCBLReplicator_Start>();

  /// Stops a running replicator, asynchronously. Does nothing if it's not
  /// already started. The replicator will call your \ref
  /// CBLReplicatorChangeListener with an activity level of \ref
  /// kCBLReplicatorStopped after it stops. Until then, consider it still
  /// active.
  void CBLReplicator_Stop(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_Stop(
      arg0,
    );
  }

  late final _CBLReplicator_StopPtr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_Stop>>(
          'CBLReplicator_Stop');
  late final _CBLReplicator_Stop =
      _CBLReplicator_StopPtr.asFunction<DartCBLReplicator_Stop>();

  /// Informs the replicator whether it's considered possible to reach the
  /// remote host with the current network configuration. The default value is
  /// true. This only affects the replicator's behavior while it's in the
  /// Offline state: Setting it to false will cancel any pending retry and
  /// prevent future automatic retries. Setting it back to true will initiate an
  /// immediate retry.
  void CBLReplicator_SetHostReachable(
    ffi.Pointer<CBLReplicator> arg0,
    bool reachable,
  ) {
    return _CBLReplicator_SetHostReachable(
      arg0,
      reachable,
    );
  }

  late final _CBLReplicator_SetHostReachablePtr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_SetHostReachable>>(
          'CBLReplicator_SetHostReachable');
  late final _CBLReplicator_SetHostReachable =
      _CBLReplicator_SetHostReachablePtr.asFunction<
          DartCBLReplicator_SetHostReachable>();

  /// Puts the replicator in or out of "suspended" state. The default is false.
  /// Setting suspended=true causes the replicator to disconnect and enter
  /// Offline state; it will not attempt to reconnect while it's suspended.
  /// Setting suspended=false causes the replicator to attempt to reconnect,
  /// _if_ it was connected when suspended, and is still in Offline state.
  void CBLReplicator_SetSuspended(
    ffi.Pointer<CBLReplicator> repl,
    bool suspended,
  ) {
    return _CBLReplicator_SetSuspended(
      repl,
      suspended,
    );
  }

  late final _CBLReplicator_SetSuspendedPtr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_SetSuspended>>(
          'CBLReplicator_SetSuspended');
  late final _CBLReplicator_SetSuspended = _CBLReplicator_SetSuspendedPtr
      .asFunction<DartCBLReplicator_SetSuspended>();

  /// Returns the replicator's current status.
  CBLReplicatorStatus CBLReplicator_Status(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_Status(
      arg0,
    );
  }

  late final _CBLReplicator_StatusPtr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_Status>>(
          'CBLReplicator_Status');
  late final _CBLReplicator_Status =
      _CBLReplicator_StatusPtr.asFunction<DartCBLReplicator_Status>();

  /// Indicates which documents in the default collection have local changes
  /// that have not yet been pushed to the server by this replicator. This is of
  /// course a snapshot, that will go out of date as the replicator makes
  /// progress and/or documents are saved locally.
  ///
  /// The result is, effectively, a set of document IDs: a dictionary whose keys
  /// are the IDs and values are `true`. If there are no pending documents, the
  /// dictionary is empty. On error, NULL is returned.
  ///
  /// @note This function can be called on a stopped or un-started replicator.
  /// @note Documents that would never be pushed by this replicator, due to its
  /// configuration's `pushFilter` or `docIDs`, are ignored. @warning You are
  /// responsible for releasing the returned array via \ref FLValue_Release.
  /// @warning If the default collection is not part of the replication, a NULL
  /// with an error will be returned. @warning <b>Deprecated :</b> Use
  /// CBLReplicator_PendingDocumentIDs2 instead.
  FLDict CBLReplicator_PendingDocumentIDs(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLReplicator_PendingDocumentIDs(
      arg0,
      outError,
    );
  }

  late final _CBLReplicator_PendingDocumentIDsPtr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_PendingDocumentIDs>>(
          'CBLReplicator_PendingDocumentIDs');
  late final _CBLReplicator_PendingDocumentIDs =
      _CBLReplicator_PendingDocumentIDsPtr.asFunction<
          DartCBLReplicator_PendingDocumentIDs>();

  /// Indicates whether the document in the default collection with the given ID
  /// has local changes that have not yet been pushed to the server by this
  /// replicator.
  ///
  /// This is equivalent to, but faster than, calling \ref
  /// CBLReplicator*PendingDocumentIDs and checking whether the result contains
  /// \p docID. See that function's documentation for details. @note A `false`
  /// result means the document is not pending, \_or* there was an error. To
  /// tell the difference, compare the error code to zero. @warning If the
  /// default collection is not part of the replication, a NULL with an error
  /// will be returned. @warning <b>Deprecated :</b> Use
  /// CBLReplicator_IsDocumentPending2 instead.
  bool CBLReplicator_IsDocumentPending(
    ffi.Pointer<CBLReplicator> repl,
    FLString docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLReplicator_IsDocumentPending(
      repl,
      docID,
      outError,
    );
  }

  late final _CBLReplicator_IsDocumentPendingPtr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_IsDocumentPending>>(
          'CBLReplicator_IsDocumentPending');
  late final _CBLReplicator_IsDocumentPending =
      _CBLReplicator_IsDocumentPendingPtr.asFunction<
          DartCBLReplicator_IsDocumentPending>();

  /// Indicates which documents in the given collection have local changes that
  /// have not yet been pushed to the server by this replicator. This is of
  /// course a snapshot, that will go out of date as the replicator makes
  /// progress and/or documents are saved locally.
  ///
  /// The result is, effectively, a set of document IDs: a dictionary whose keys
  /// are the IDs and values are `true`. If there are no pending documents, the
  /// dictionary is empty. On error, NULL is returned. @warning If the given
  /// collection is not part of the replication, a NULL with an error will be
  /// returned.
  FLDict CBLReplicator_PendingDocumentIDs2(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLReplicator_PendingDocumentIDs2(
      arg0,
      collection,
      outError,
    );
  }

  late final _CBLReplicator_PendingDocumentIDs2Ptr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_PendingDocumentIDs2>>(
          'CBLReplicator_PendingDocumentIDs2');
  late final _CBLReplicator_PendingDocumentIDs2 =
      _CBLReplicator_PendingDocumentIDs2Ptr.asFunction<
          DartCBLReplicator_PendingDocumentIDs2>();

  /// Indicates whether the document with the given ID in the given collection
  /// has local changes that have not yet been pushed to the server by this
  /// replicator.
  ///
  /// This is equivalent to, but faster than, calling \ref
  /// CBLReplicator*PendingDocumentIDs2 and checking whether the result contains
  /// \p docID. See that function's documentation for details. @note A `false`
  /// result means the document is not pending, \_or* there was an error. To
  /// tell the difference, compare the error code to zero. @warning If the given
  /// collection is not part of the replication, a NULL with an error will be
  /// returned.
  bool CBLReplicator_IsDocumentPending2(
    ffi.Pointer<CBLReplicator> repl,
    FLString docID,
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLReplicator_IsDocumentPending2(
      repl,
      docID,
      collection,
      outError,
    );
  }

  late final _CBLReplicator_IsDocumentPending2Ptr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_IsDocumentPending2>>(
          'CBLReplicator_IsDocumentPending2');
  late final _CBLReplicator_IsDocumentPending2 =
      _CBLReplicator_IsDocumentPending2Ptr.asFunction<
          DartCBLReplicator_IsDocumentPending2>();

  /// Registers a listener that will be called when the replicator's status
  /// changes.
  ffi.Pointer<CBLListenerToken> CBLReplicator_AddChangeListener(
    ffi.Pointer<CBLReplicator> arg0,
    CBLReplicatorChangeListener arg1,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLReplicator_AddChangeListener(
      arg0,
      arg1,
      context,
    );
  }

  late final _CBLReplicator_AddChangeListenerPtr =
      _lookup<ffi.NativeFunction<NativeCBLReplicator_AddChangeListener>>(
          'CBLReplicator_AddChangeListener');
  late final _CBLReplicator_AddChangeListener =
      _CBLReplicator_AddChangeListenerPtr.asFunction<
          DartCBLReplicator_AddChangeListener>();

  /// Registers a listener that will be called when documents are replicated.
  ffi.Pointer<CBLListenerToken> CBLReplicator_AddDocumentReplicationListener(
    ffi.Pointer<CBLReplicator> arg0,
    CBLDocumentReplicationListener arg1,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLReplicator_AddDocumentReplicationListener(
      arg0,
      arg1,
      context,
    );
  }

  late final _CBLReplicator_AddDocumentReplicationListenerPtr = _lookup<
          ffi
          .NativeFunction<NativeCBLReplicator_AddDocumentReplicationListener>>(
      'CBLReplicator_AddDocumentReplicationListener');
  late final _CBLReplicator_AddDocumentReplicationListener =
      _CBLReplicator_AddDocumentReplicationListenerPtr.asFunction<
          DartCBLReplicator_AddDocumentReplicationListener>();

  /// [false] Plaintext is not used, and instead binary encoding is used in log
  /// files
  late final ffi.Pointer<ffi.Bool> _kCBLDefaultLogFileUsePlainText =
      _lookup<ffi.Bool>('kCBLDefaultLogFileUsePlainText');

  bool get kCBLDefaultLogFileUsePlainText =>
      _kCBLDefaultLogFileUsePlainText.value;

  /// [524288] 512 KiB for the size of a log file
  late final ffi.Pointer<ffi.Size> _kCBLDefaultLogFileMaxSize =
      _lookup<ffi.Size>('kCBLDefaultLogFileMaxSize');

  int get kCBLDefaultLogFileMaxSize => _kCBLDefaultLogFileMaxSize.value;

  /// [1] 1 rotated file present (2 total, including the currently active log
  /// file)
  late final ffi.Pointer<ffi.Uint32> _kCBLDefaultLogFileMaxRotateCount =
      _lookup<ffi.Uint32>('kCBLDefaultLogFileMaxRotateCount');

  int get kCBLDefaultLogFileMaxRotateCount =>
      _kCBLDefaultLogFileMaxRotateCount.value;

  /// [false] Accents and ligatures are not ignored when indexing via full text
  /// search
  late final ffi.Pointer<ffi.Bool> _kCBLDefaultFullTextIndexIgnoreAccents =
      _lookup<ffi.Bool>('kCBLDefaultFullTextIndexIgnoreAccents');

  bool get kCBLDefaultFullTextIndexIgnoreAccents =>
      _kCBLDefaultFullTextIndexIgnoreAccents.value;

  /// [kCBLReplicatorTypePushAndPull] Perform bidirectional replication
  late final ffi.Pointer<CBLReplicatorType> _kCBLDefaultReplicatorType =
      _lookup<CBLReplicatorType>('kCBLDefaultReplicatorType');

  DartCBLReplicatorType get kCBLDefaultReplicatorType =>
      _kCBLDefaultReplicatorType.value;

  /// [false] One-shot replication is used, and will stop once all initial
  /// changes are processed
  late final ffi.Pointer<ffi.Bool> _kCBLDefaultReplicatorContinuous =
      _lookup<ffi.Bool>('kCBLDefaultReplicatorContinuous');

  bool get kCBLDefaultReplicatorContinuous =>
      _kCBLDefaultReplicatorContinuous.value;

  /// [300] A heartbeat messages is sent every 300 seconds to keep the
  /// connection alive
  late final ffi.Pointer<ffi.UnsignedInt> _kCBLDefaultReplicatorHeartbeat =
      _lookup<ffi.UnsignedInt>('kCBLDefaultReplicatorHeartbeat');

  int get kCBLDefaultReplicatorHeartbeat =>
      _kCBLDefaultReplicatorHeartbeat.value;

  /// [10] When replicator is not continuous, after 10 failed attempts give up
  /// on the replication
  late final ffi.Pointer<ffi.UnsignedInt>
      _kCBLDefaultReplicatorMaxAttemptsSingleShot =
      _lookup<ffi.UnsignedInt>('kCBLDefaultReplicatorMaxAttemptsSingleShot');

  int get kCBLDefaultReplicatorMaxAttemptsSingleShot =>
      _kCBLDefaultReplicatorMaxAttemptsSingleShot.value;

  /// [UINT_MAX] When replicator is continuous, never give up unless explicitly
  /// stopped
  late final ffi.Pointer<ffi.UnsignedInt>
      _kCBLDefaultReplicatorMaxAttemptsContinuous =
      _lookup<ffi.UnsignedInt>('kCBLDefaultReplicatorMaxAttemptsContinuous');

  int get kCBLDefaultReplicatorMaxAttemptsContinuous =>
      _kCBLDefaultReplicatorMaxAttemptsContinuous.value;

  /// [300] Max wait time between retry attempts in seconds
  late final ffi.Pointer<ffi.UnsignedInt>
      _kCBLDefaultReplicatorMaxAttemptWaitTime =
      _lookup<ffi.UnsignedInt>('kCBLDefaultReplicatorMaxAttemptWaitTime');

  int get kCBLDefaultReplicatorMaxAttemptWaitTime =>
      _kCBLDefaultReplicatorMaxAttemptWaitTime.value;

  /// [false] Purge documents when a user loses access
  late final ffi.Pointer<ffi.Bool> _kCBLDefaultReplicatorDisableAutoPurge =
      _lookup<ffi.Bool>('kCBLDefaultReplicatorDisableAutoPurge');

  bool get kCBLDefaultReplicatorDisableAutoPurge =>
      _kCBLDefaultReplicatorDisableAutoPurge.value;

  /// [false] Whether or not a replicator only accepts cookies for the sender's
  /// parent domains
  late final ffi.Pointer<ffi.Bool> _kCBLDefaultReplicatorAcceptParentCookies =
      _lookup<ffi.Bool>('kCBLDefaultReplicatorAcceptParentCookies');

  bool get kCBLDefaultReplicatorAcceptParentCookies =>
      _kCBLDefaultReplicatorAcceptParentCookies.value;

  /// < `"encryptable"`
  late final ffi.Pointer<FLSlice> _kCBLEncryptableType =
      _lookup<FLSlice>('kCBLEncryptableType');

  FLSlice get kCBLEncryptableType => _kCBLEncryptableType.ref;

  /// < `"value"`
  late final ffi.Pointer<FLSlice> _kCBLEncryptableValueProperty =
      _lookup<FLSlice>('kCBLEncryptableValueProperty');

  FLSlice get kCBLEncryptableValueProperty => _kCBLEncryptableValueProperty.ref;

  /// Creates CBLEncryptable object with null value.
  ffi.Pointer<CBLEncryptable> CBLEncryptable_CreateWithNull() {
    return _CBLEncryptable_CreateWithNull();
  }

  late final _CBLEncryptable_CreateWithNullPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_CreateWithNull>>(
          'CBLEncryptable_CreateWithNull');
  late final _CBLEncryptable_CreateWithNull = _CBLEncryptable_CreateWithNullPtr
      .asFunction<DartCBLEncryptable_CreateWithNull>();

  /// Creates CBLEncryptable object with a boolean value.
  ffi.Pointer<CBLEncryptable> CBLEncryptable_CreateWithBool(
    bool value,
  ) {
    return _CBLEncryptable_CreateWithBool(
      value,
    );
  }

  late final _CBLEncryptable_CreateWithBoolPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_CreateWithBool>>(
          'CBLEncryptable_CreateWithBool');
  late final _CBLEncryptable_CreateWithBool = _CBLEncryptable_CreateWithBoolPtr
      .asFunction<DartCBLEncryptable_CreateWithBool>();

  /// Creates CBLEncryptable object with an int value.
  ffi.Pointer<CBLEncryptable> CBLEncryptable_CreateWithInt(
    int value,
  ) {
    return _CBLEncryptable_CreateWithInt(
      value,
    );
  }

  late final _CBLEncryptable_CreateWithIntPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_CreateWithInt>>(
          'CBLEncryptable_CreateWithInt');
  late final _CBLEncryptable_CreateWithInt = _CBLEncryptable_CreateWithIntPtr
      .asFunction<DartCBLEncryptable_CreateWithInt>();

  /// Creates CBLEncryptable object with an unsigned int value.
  ffi.Pointer<CBLEncryptable> CBLEncryptable_CreateWithUInt(
    int value,
  ) {
    return _CBLEncryptable_CreateWithUInt(
      value,
    );
  }

  late final _CBLEncryptable_CreateWithUIntPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_CreateWithUInt>>(
          'CBLEncryptable_CreateWithUInt');
  late final _CBLEncryptable_CreateWithUInt = _CBLEncryptable_CreateWithUIntPtr
      .asFunction<DartCBLEncryptable_CreateWithUInt>();

  /// Creates CBLEncryptable object with a float value.
  ffi.Pointer<CBLEncryptable> CBLEncryptable_CreateWithFloat(
    double value,
  ) {
    return _CBLEncryptable_CreateWithFloat(
      value,
    );
  }

  late final _CBLEncryptable_CreateWithFloatPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_CreateWithFloat>>(
          'CBLEncryptable_CreateWithFloat');
  late final _CBLEncryptable_CreateWithFloat =
      _CBLEncryptable_CreateWithFloatPtr.asFunction<
          DartCBLEncryptable_CreateWithFloat>();

  /// Creates CBLEncryptable object with a double value.
  ffi.Pointer<CBLEncryptable> CBLEncryptable_CreateWithDouble(
    double value,
  ) {
    return _CBLEncryptable_CreateWithDouble(
      value,
    );
  }

  late final _CBLEncryptable_CreateWithDoublePtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_CreateWithDouble>>(
          'CBLEncryptable_CreateWithDouble');
  late final _CBLEncryptable_CreateWithDouble =
      _CBLEncryptable_CreateWithDoublePtr.asFunction<
          DartCBLEncryptable_CreateWithDouble>();

  /// Creates CBLEncryptable object with a string value.
  ffi.Pointer<CBLEncryptable> CBLEncryptable_CreateWithString(
    FLString value,
  ) {
    return _CBLEncryptable_CreateWithString(
      value,
    );
  }

  late final _CBLEncryptable_CreateWithStringPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_CreateWithString>>(
          'CBLEncryptable_CreateWithString');
  late final _CBLEncryptable_CreateWithString =
      _CBLEncryptable_CreateWithStringPtr.asFunction<
          DartCBLEncryptable_CreateWithString>();

  /// Creates CBLEncryptable object with an FLValue value.
  ffi.Pointer<CBLEncryptable> CBLEncryptable_CreateWithValue(
    FLValue value,
  ) {
    return _CBLEncryptable_CreateWithValue(
      value,
    );
  }

  late final _CBLEncryptable_CreateWithValuePtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_CreateWithValue>>(
          'CBLEncryptable_CreateWithValue');
  late final _CBLEncryptable_CreateWithValue =
      _CBLEncryptable_CreateWithValuePtr.asFunction<
          DartCBLEncryptable_CreateWithValue>();

  /// Creates CBLEncryptable object with an FLArray value.
  ffi.Pointer<CBLEncryptable> CBLEncryptable_CreateWithArray(
    FLArray value,
  ) {
    return _CBLEncryptable_CreateWithArray(
      value,
    );
  }

  late final _CBLEncryptable_CreateWithArrayPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_CreateWithArray>>(
          'CBLEncryptable_CreateWithArray');
  late final _CBLEncryptable_CreateWithArray =
      _CBLEncryptable_CreateWithArrayPtr.asFunction<
          DartCBLEncryptable_CreateWithArray>();

  /// Creates CBLEncryptable object with an FLDict value.
  ffi.Pointer<CBLEncryptable> CBLEncryptable_CreateWithDict(
    FLDict value,
  ) {
    return _CBLEncryptable_CreateWithDict(
      value,
    );
  }

  late final _CBLEncryptable_CreateWithDictPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_CreateWithDict>>(
          'CBLEncryptable_CreateWithDict');
  late final _CBLEncryptable_CreateWithDict = _CBLEncryptable_CreateWithDictPtr
      .asFunction<DartCBLEncryptable_CreateWithDict>();

  /// Returns the value to be encrypted by the push replicator.
  FLValue CBLEncryptable_Value(
    ffi.Pointer<CBLEncryptable> encryptable,
  ) {
    return _CBLEncryptable_Value(
      encryptable,
    );
  }

  late final _CBLEncryptable_ValuePtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_Value>>(
          'CBLEncryptable_Value');
  late final _CBLEncryptable_Value =
      _CBLEncryptable_ValuePtr.asFunction<DartCBLEncryptable_Value>();

  /// Returns the dictionary format of the \ref CBLEncryptable object.
  FLDict CBLEncryptable_Properties(
    ffi.Pointer<CBLEncryptable> encryptable,
  ) {
    return _CBLEncryptable_Properties(
      encryptable,
    );
  }

  late final _CBLEncryptable_PropertiesPtr =
      _lookup<ffi.NativeFunction<NativeCBLEncryptable_Properties>>(
          'CBLEncryptable_Properties');
  late final _CBLEncryptable_Properties =
      _CBLEncryptable_PropertiesPtr.asFunction<DartCBLEncryptable_Properties>();

  /// Checks whether the given dictionary is a \ref CBLEncryptable or not.
  bool FLDict_IsEncryptableValue(
    FLDict arg0,
  ) {
    return _FLDict_IsEncryptableValue(
      arg0,
    );
  }

  late final _FLDict_IsEncryptableValuePtr =
      _lookup<ffi.NativeFunction<NativeFLDict_IsEncryptableValue>>(
          'FLDict_IsEncryptableValue');
  late final _FLDict_IsEncryptableValue =
      _FLDict_IsEncryptableValuePtr.asFunction<DartFLDict_IsEncryptableValue>();

  /// Returns a \ref CBLEncryptable object corresponding to the given
  /// encryptable dictionary in a document or NULL if the dictionary is not a
  /// \ref CBLEncryptable. \note The returned CBLEncryptable object will be
  /// released when its document is released.
  ffi.Pointer<CBLEncryptable> FLDict_GetEncryptableValue(
    FLDict encryptableDict,
  ) {
    return _FLDict_GetEncryptableValue(
      encryptableDict,
    );
  }

  late final _FLDict_GetEncryptableValuePtr =
      _lookup<ffi.NativeFunction<NativeFLDict_GetEncryptableValue>>(
          'FLDict_GetEncryptableValue');
  late final _FLDict_GetEncryptableValue = _FLDict_GetEncryptableValuePtr
      .asFunction<DartFLDict_GetEncryptableValue>();

  /// Set a \ref CBLEncryptable's dictionary into a mutable dictionary's slot.
  void FLSlot_SetEncryptableValue(
    FLSlot slot,
    ffi.Pointer<CBLEncryptable> encryptable,
  ) {
    return _FLSlot_SetEncryptableValue(
      slot,
      encryptable,
    );
  }

  late final _FLSlot_SetEncryptableValuePtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetEncryptableValue>>(
          'FLSlot_SetEncryptableValue');
  late final _FLSlot_SetEncryptableValue = _FLSlot_SetEncryptableValuePtr
      .asFunction<DartFLSlot_SetEncryptableValue>();

  /// Formats and writes a message to the log, in the given domain at the given
  /// level. \warning This function takes a `printf`-style format string, with
  /// extra parameters to match the format placeholders, and has the same
  /// security vulnerabilities as other `printf`-style functions.
  ///
  /// If you are logging a fixed string, call \ref CBL_LogMessage instead,
  /// otherwise any `%` characters in the `format` string will be misinterpreted
  /// as placeholders and the dreaded Undefined Behavior will result, possibly
  /// including crashes or overwriting the stack. @param domain The log domain
  /// to associate this message with. @param level The severity of the message.
  /// If this is lower than the current minimum level for the domain (as set by
  /// \ref CBLLog_SetConsoleLevel), nothing is logged. @param format A
  /// `printf`-style format string. `%` characters in this string introduce
  /// parameters, and corresponding arguments must follow.
  void CBL_Log(
    int domain,
    int level,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _CBL_Log(
      domain,
      level,
      format,
    );
  }

  late final _CBL_LogPtr =
      _lookup<ffi.NativeFunction<NativeCBL_Log>>('CBL_Log');
  late final _CBL_Log = _CBL_LogPtr.asFunction<DartCBL_Log>();

  /// Writes a pre-formatted message to the log, exactly as given. @param domain
  /// The log domain to associate this message with. @param level The severity
  /// of the message. If this is lower than the current minimum level for the
  /// domain (as set by \ref CBLLog_SetConsoleLevel), nothing is logged. @param
  /// message The exact message to write to the log.
  void CBL_LogMessage(
    int domain,
    int level,
    FLSlice message,
  ) {
    return _CBL_LogMessage(
      domain,
      level,
      message,
    );
  }

  late final _CBL_LogMessagePtr =
      _lookup<ffi.NativeFunction<NativeCBL_LogMessage>>('CBL_LogMessage');
  late final _CBL_LogMessage =
      _CBL_LogMessagePtr.asFunction<DartCBL_LogMessage>();

  /// Gets the current log level for debug console logging. Only messages at
  /// this level or higher will be logged to the console.
  int CBLLog_ConsoleLevel() {
    return _CBLLog_ConsoleLevel();
  }

  late final _CBLLog_ConsoleLevelPtr =
      _lookup<ffi.NativeFunction<NativeCBLLog_ConsoleLevel>>(
          'CBLLog_ConsoleLevel');
  late final _CBLLog_ConsoleLevel =
      _CBLLog_ConsoleLevelPtr.asFunction<DartCBLLog_ConsoleLevel>();

  /// Sets the detail level of logging. Only messages whose level is  the given
  /// level will be logged to the console.
  void CBLLog_SetConsoleLevel(
    int arg0,
  ) {
    return _CBLLog_SetConsoleLevel(
      arg0,
    );
  }

  late final _CBLLog_SetConsoleLevelPtr =
      _lookup<ffi.NativeFunction<NativeCBLLog_SetConsoleLevel>>(
          'CBLLog_SetConsoleLevel');
  late final _CBLLog_SetConsoleLevel =
      _CBLLog_SetConsoleLevelPtr.asFunction<DartCBLLog_SetConsoleLevel>();

  /// Gets the current log level for debug console logging. Only messages at
  /// this level or higher will be logged to the callback.
  int CBLLog_CallbackLevel() {
    return _CBLLog_CallbackLevel();
  }

  late final _CBLLog_CallbackLevelPtr =
      _lookup<ffi.NativeFunction<NativeCBLLog_CallbackLevel>>(
          'CBLLog_CallbackLevel');
  late final _CBLLog_CallbackLevel =
      _CBLLog_CallbackLevelPtr.asFunction<DartCBLLog_CallbackLevel>();

  /// Sets the detail level of logging. Only messages whose level is  the given
  /// level will be logged to the callback.
  void CBLLog_SetCallbackLevel(
    int arg0,
  ) {
    return _CBLLog_SetCallbackLevel(
      arg0,
    );
  }

  late final _CBLLog_SetCallbackLevelPtr =
      _lookup<ffi.NativeFunction<NativeCBLLog_SetCallbackLevel>>(
          'CBLLog_SetCallbackLevel');
  late final _CBLLog_SetCallbackLevel =
      _CBLLog_SetCallbackLevelPtr.asFunction<DartCBLLog_SetCallbackLevel>();

  /// Gets the current log callback.
  CBLLogCallback CBLLog_Callback() {
    return _CBLLog_Callback();
  }

  late final _CBLLog_CallbackPtr =
      _lookup<ffi.NativeFunction<NativeCBLLog_Callback>>('CBLLog_Callback');
  late final _CBLLog_Callback =
      _CBLLog_CallbackPtr.asFunction<DartCBLLog_Callback>();

  /// Sets the callback for receiving log messages. If set to NULL, no messages
  /// are logged to the console.
  void CBLLog_SetCallback(
    CBLLogCallback callback,
  ) {
    return _CBLLog_SetCallback(
      callback,
    );
  }

  late final _CBLLog_SetCallbackPtr =
      _lookup<ffi.NativeFunction<NativeCBLLog_SetCallback>>(
          'CBLLog_SetCallback');
  late final _CBLLog_SetCallback =
      _CBLLog_SetCallbackPtr.asFunction<DartCBLLog_SetCallback>();

  /// Gets the current file logging configuration, or NULL if none is
  /// configured.
  ffi.Pointer<CBLLogFileConfiguration> CBLLog_FileConfig() {
    return _CBLLog_FileConfig();
  }

  late final _CBLLog_FileConfigPtr =
      _lookup<ffi.NativeFunction<NativeCBLLog_FileConfig>>('CBLLog_FileConfig');
  late final _CBLLog_FileConfig =
      _CBLLog_FileConfigPtr.asFunction<DartCBLLog_FileConfig>();

  /// Sets the file logging configuration, and begins logging to files.
  bool CBLLog_SetFileConfig(
    CBLLogFileConfiguration arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLLog_SetFileConfig(
      arg0,
      outError,
    );
  }

  late final _CBLLog_SetFileConfigPtr =
      _lookup<ffi.NativeFunction<NativeCBLLog_SetFileConfig>>(
          'CBLLog_SetFileConfig');
  late final _CBLLog_SetFileConfig =
      _CBLLog_SetFileConfigPtr.asFunction<DartCBLLog_SetFileConfig>();

  /// The default scope's name.
  late final ffi.Pointer<FLString> _kCBLDefaultScopeName =
      _lookup<FLString>('kCBLDefaultScopeName');

  FLString get kCBLDefaultScopeName => _kCBLDefaultScopeName.ref;

  /// Returns the name of the scope. @param scope The scope. @return The name of
  /// the scope.
  FLString CBLScope_Name(
    ffi.Pointer<CBLScope> scope,
  ) {
    return _CBLScope_Name(
      scope,
    );
  }

  late final _CBLScope_NamePtr =
      _lookup<ffi.NativeFunction<NativeCBLScope_Name>>('CBLScope_Name');
  late final _CBLScope_Name = _CBLScope_NamePtr.asFunction<DartCBLScope_Name>();

  /// Returns the names of all collections in the scope. @note You are
  /// responsible for releasing the returned array. @param scope The scope.
  /// @param outError On failure, the error will be written here. @return The
  /// names of all collections in the scope, or NULL if an error occurred.
  FLMutableArray CBLScope_CollectionNames(
    ffi.Pointer<CBLScope> scope,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLScope_CollectionNames(
      scope,
      outError,
    );
  }

  late final _CBLScope_CollectionNamesPtr =
      _lookup<ffi.NativeFunction<NativeCBLScope_CollectionNames>>(
          'CBLScope_CollectionNames');
  late final _CBLScope_CollectionNames =
      _CBLScope_CollectionNamesPtr.asFunction<DartCBLScope_CollectionNames>();

  /// Returns an existing collection in the scope with the given name. @note You
  /// are responsible for releasing the returned collection. @param scope The
  /// scope. @param collectionName The name of the collection. @param outError
  /// On failure, the error will be written here. @return A \ref CBLCollection
  /// instance, or NULL if the collection doesn't exist or an error occurred.
  ffi.Pointer<CBLCollection> CBLScope_Collection(
    ffi.Pointer<CBLScope> scope,
    FLString collectionName,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLScope_Collection(
      scope,
      collectionName,
      outError,
    );
  }

  late final _CBLScope_CollectionPtr =
      _lookup<ffi.NativeFunction<NativeCBLScope_Collection>>(
          'CBLScope_Collection');
  late final _CBLScope_Collection =
      _CBLScope_CollectionPtr.asFunction<DartCBLScope_Collection>();

  /// Equality test of two slices.
  bool FLSlice_Equal(
    FLSlice a,
    FLSlice b,
  ) {
    return _FLSlice_Equal(
      a,
      b,
    );
  }

  late final _FLSlice_EqualPtr =
      _lookup<ffi.NativeFunction<NativeFLSlice_Equal>>('FLSlice_Equal');
  late final _FLSlice_Equal = _FLSlice_EqualPtr.asFunction<DartFLSlice_Equal>();

  /// Lexicographic comparison of two slices; basically like memcmp(), but
  /// taking into account differences in length.
  int FLSlice_Compare(
    FLSlice arg0,
    FLSlice arg1,
  ) {
    return _FLSlice_Compare(
      arg0,
      arg1,
    );
  }

  late final _FLSlice_ComparePtr =
      _lookup<ffi.NativeFunction<NativeFLSlice_Compare>>('FLSlice_Compare');
  late final _FLSlice_Compare =
      _FLSlice_ComparePtr.asFunction<DartFLSlice_Compare>();

  /// Computes a 32-bit hash of a slice's data, suitable for use in hash tables.
  int FLSlice_Hash(
    FLSlice s,
  ) {
    return _FLSlice_Hash(
      s,
    );
  }

  late final _FLSlice_HashPtr =
      _lookup<ffi.NativeFunction<NativeFLSlice_Hash>>('FLSlice_Hash');
  late final _FLSlice_Hash = _FLSlice_HashPtr.asFunction<DartFLSlice_Hash>();

  /// Copies a slice to a buffer, adding a trailing zero byte to make it a valid
  /// C string. If there is not enough capacity the slice will be truncated, but
  /// the trailing zero byte is always written. @param s The FLSlice to copy.
  /// @param buffer Where to copy the bytes. At least `capacity` bytes must be
  /// available. @param capacity The maximum number of bytes to copy (including
  /// the trailing 0.) @return True if the entire slice was copied, false if it
  /// was truncated.
  bool FLSlice_ToCString(
    FLSlice s,
    ffi.Pointer<ffi.Char> buffer,
    int capacity,
  ) {
    return _FLSlice_ToCString(
      s,
      buffer,
      capacity,
    );
  }

  late final _FLSlice_ToCStringPtr =
      _lookup<ffi.NativeFunction<NativeFLSlice_ToCString>>('FLSlice_ToCString');
  late final _FLSlice_ToCString =
      _FLSlice_ToCStringPtr.asFunction<DartFLSlice_ToCString>();

  /// Allocates an FLSliceResult of the given size, without initializing the
  /// buffer.
  FLSliceResult FLSliceResult_New(
    int arg0,
  ) {
    return _FLSliceResult_New(
      arg0,
    );
  }

  late final _FLSliceResult_NewPtr =
      _lookup<ffi.NativeFunction<NativeFLSliceResult_New>>('FLSliceResult_New');
  late final _FLSliceResult_New =
      _FLSliceResult_NewPtr.asFunction<DartFLSliceResult_New>();

  /// Allocates an FLSliceResult, copying the given slice.
  FLSliceResult FLSlice_Copy(
    FLSlice arg0,
  ) {
    return _FLSlice_Copy(
      arg0,
    );
  }

  late final _FLSlice_CopyPtr =
      _lookup<ffi.NativeFunction<NativeFLSlice_Copy>>('FLSlice_Copy');
  late final _FLSlice_Copy = _FLSlice_CopyPtr.asFunction<DartFLSlice_Copy>();

  void FLBuf_Retain(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _FLBuf_Retain(
      arg0,
    );
  }

  late final _FLBuf_RetainPtr =
      _lookup<ffi.NativeFunction<NativeFLBuf_Retain>>('_FLBuf_Retain');
  late final _FLBuf_Retain = _FLBuf_RetainPtr.asFunction<DartFLBuf_Retain>();

  void FLBuf_Release(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _FLBuf_Release(
      arg0,
    );
  }

  late final _FLBuf_ReleasePtr =
      _lookup<ffi.NativeFunction<NativeFLBuf_Release>>('_FLBuf_Release');
  late final _FLBuf_Release = _FLBuf_ReleasePtr.asFunction<DartFLBuf_Release>();

  /// Writes zeroes to `size` bytes of memory starting at `dst`. Unlike a call
  /// to `memset`, these writes cannot be optimized away by the compiler. This
  /// is useful for securely removing traces of passwords or encryption keys.
  void FL_WipeMemory(
    ffi.Pointer<ffi.Void> dst,
    int size,
  ) {
    return _FL_WipeMemory(
      dst,
      size,
    );
  }

  late final _FL_WipeMemoryPtr =
      _lookup<ffi.NativeFunction<NativeFL_WipeMemory>>('FL_WipeMemory');
  late final _FL_WipeMemory = _FL_WipeMemoryPtr.asFunction<DartFL_WipeMemory>();

  /// Returns an FLTimestamp corresponding to the current time.
  int FLTimestamp_Now() {
    return _FLTimestamp_Now();
  }

  late final _FLTimestamp_NowPtr =
      _lookup<ffi.NativeFunction<NativeFLTimestamp_Now>>('FLTimestamp_Now');
  late final _FLTimestamp_Now =
      _FLTimestamp_NowPtr.asFunction<DartFLTimestamp_Now>();

  /// Formats a timestamp as a date-time string in ISO-8601 format. @note See
  /// also \ref FLEncoder_WriteDateString, which writes a timestamp to an
  /// `FLEncoder`. @param timestamp A time, given as milliseconds since the Unix
  /// epoch (1/1/1970 00:00 UTC.) @param asUTC If true, the timestamp will be
  /// given in universal time; if false, in the local timezone. @return A
  /// heap-allocated string, which you are responsible for releasing.
  FLStringResult FLTimestamp_ToString(
    int timestamp,
    bool asUTC,
  ) {
    return _FLTimestamp_ToString(
      timestamp,
      asUTC,
    );
  }

  late final _FLTimestamp_ToStringPtr =
      _lookup<ffi.NativeFunction<NativeFLTimestamp_ToString>>(
          'FLTimestamp_ToString');
  late final _FLTimestamp_ToString =
      _FLTimestamp_ToStringPtr.asFunction<DartFLTimestamp_ToString>();

  /// Parses an ISO-8601 date-time string to a timestamp. On failure returns
  /// `FLTimestampNone`. @note See also \ref FLValue_AsTimestamp, which takes an
  /// `FLValue` and interprets numeric representations as well as strings.
  int FLTimestamp_FromString(
    FLString str,
  ) {
    return _FLTimestamp_FromString(
      str,
    );
  }

  late final _FLTimestamp_FromStringPtr =
      _lookup<ffi.NativeFunction<NativeFLTimestamp_FromString>>(
          'FLTimestamp_FromString');
  late final _FLTimestamp_FromString =
      _FLTimestamp_FromStringPtr.asFunction<DartFLTimestamp_FromString>();

  /// A constant empty array value.
  late final ffi.Pointer<FLArray> _kFLEmptyArray =
      _lookup<FLArray>('kFLEmptyArray');

  FLArray get kFLEmptyArray => _kFLEmptyArray.value;

  set kFLEmptyArray(FLArray value) => _kFLEmptyArray.value = value;

  /// Returns the number of items in an array, or 0 if the pointer is NULL.
  int FLArray_Count(
    FLArray arg0,
  ) {
    return _FLArray_Count(
      arg0,
    );
  }

  late final _FLArray_CountPtr =
      _lookup<ffi.NativeFunction<NativeFLArray_Count>>('FLArray_Count');
  late final _FLArray_Count = _FLArray_CountPtr.asFunction<DartFLArray_Count>();

  /// Returns true if an array is empty (or NULL). Depending on the array's
  /// representation, this can be faster than `FLArray_Count(a) == 0`
  bool FLArray_IsEmpty(
    FLArray arg0,
  ) {
    return _FLArray_IsEmpty(
      arg0,
    );
  }

  late final _FLArray_IsEmptyPtr =
      _lookup<ffi.NativeFunction<NativeFLArray_IsEmpty>>('FLArray_IsEmpty');
  late final _FLArray_IsEmpty =
      _FLArray_IsEmptyPtr.asFunction<DartFLArray_IsEmpty>();

  /// If the array is mutable, returns it cast to FLMutableArray, else NULL.
  FLMutableArray FLArray_AsMutable(
    FLArray arg0,
  ) {
    return _FLArray_AsMutable(
      arg0,
    );
  }

  late final _FLArray_AsMutablePtr =
      _lookup<ffi.NativeFunction<NativeFLArray_AsMutable>>('FLArray_AsMutable');
  late final _FLArray_AsMutable =
      _FLArray_AsMutablePtr.asFunction<DartFLArray_AsMutable>();

  /// Returns an value at an array index, or NULL if the index is out of range.
  FLValue FLArray_Get(
    FLArray arg0,
    int index,
  ) {
    return _FLArray_Get(
      arg0,
      index,
    );
  }

  late final _FLArray_GetPtr =
      _lookup<ffi.NativeFunction<NativeFLArray_Get>>('FLArray_Get');
  late final _FLArray_Get = _FLArray_GetPtr.asFunction<DartFLArray_Get>();

  /// Initializes a FLArrayIterator struct to iterate over an array. Call
  /// FLArrayIteratorGetValue to get the first item, then FLArrayIteratorNext.
  void FLArrayIterator_Begin(
    FLArray arg0,
    ffi.Pointer<FLArrayIterator> arg1,
  ) {
    return _FLArrayIterator_Begin(
      arg0,
      arg1,
    );
  }

  late final _FLArrayIterator_BeginPtr =
      _lookup<ffi.NativeFunction<NativeFLArrayIterator_Begin>>(
          'FLArrayIterator_Begin');
  late final _FLArrayIterator_Begin =
      _FLArrayIterator_BeginPtr.asFunction<DartFLArrayIterator_Begin>();

  /// Returns the current value being iterated over.
  FLValue FLArrayIterator_GetValue(
    ffi.Pointer<FLArrayIterator> arg0,
  ) {
    return _FLArrayIterator_GetValue(
      arg0,
    );
  }

  late final _FLArrayIterator_GetValuePtr =
      _lookup<ffi.NativeFunction<NativeFLArrayIterator_GetValue>>(
          'FLArrayIterator_GetValue');
  late final _FLArrayIterator_GetValue =
      _FLArrayIterator_GetValuePtr.asFunction<DartFLArrayIterator_GetValue>();

  /// Returns a value in the array at the given offset from the current value.
  FLValue FLArrayIterator_GetValueAt(
    ffi.Pointer<FLArrayIterator> arg0,
    int offset,
  ) {
    return _FLArrayIterator_GetValueAt(
      arg0,
      offset,
    );
  }

  late final _FLArrayIterator_GetValueAtPtr =
      _lookup<ffi.NativeFunction<NativeFLArrayIterator_GetValueAt>>(
          'FLArrayIterator_GetValueAt');
  late final _FLArrayIterator_GetValueAt = _FLArrayIterator_GetValueAtPtr
      .asFunction<DartFLArrayIterator_GetValueAt>();

  /// Returns the number of items remaining to be iterated, including the
  /// current one.
  int FLArrayIterator_GetCount(
    ffi.Pointer<FLArrayIterator> arg0,
  ) {
    return _FLArrayIterator_GetCount(
      arg0,
    );
  }

  late final _FLArrayIterator_GetCountPtr =
      _lookup<ffi.NativeFunction<NativeFLArrayIterator_GetCount>>(
          'FLArrayIterator_GetCount');
  late final _FLArrayIterator_GetCount =
      _FLArrayIterator_GetCountPtr.asFunction<DartFLArrayIterator_GetCount>();

  /// Advances the iterator to the next value, or returns false if at the end.
  bool FLArrayIterator_Next(
    ffi.Pointer<FLArrayIterator> arg0,
  ) {
    return _FLArrayIterator_Next(
      arg0,
    );
  }

  late final _FLArrayIterator_NextPtr =
      _lookup<ffi.NativeFunction<NativeFLArrayIterator_Next>>(
          'FLArrayIterator_Next');
  late final _FLArrayIterator_Next =
      _FLArrayIterator_NextPtr.asFunction<DartFLArrayIterator_Next>();

  /// A constant empty array value.
  late final ffi.Pointer<FLDict> _kFLEmptyDict =
      _lookup<FLDict>('kFLEmptyDict');

  FLDict get kFLEmptyDict => _kFLEmptyDict.value;

  set kFLEmptyDict(FLDict value) => _kFLEmptyDict.value = value;

  /// Returns the number of items in a dictionary, or 0 if the pointer is NULL.
  int FLDict_Count(
    FLDict arg0,
  ) {
    return _FLDict_Count(
      arg0,
    );
  }

  late final _FLDict_CountPtr =
      _lookup<ffi.NativeFunction<NativeFLDict_Count>>('FLDict_Count');
  late final _FLDict_Count = _FLDict_CountPtr.asFunction<DartFLDict_Count>();

  /// Returns true if a dictionary is empty (or NULL). Depending on the
  /// dictionary's representation, this can be faster than
  /// `FLDict_Count(a) == 0`
  bool FLDict_IsEmpty(
    FLDict arg0,
  ) {
    return _FLDict_IsEmpty(
      arg0,
    );
  }

  late final _FLDict_IsEmptyPtr =
      _lookup<ffi.NativeFunction<NativeFLDict_IsEmpty>>('FLDict_IsEmpty');
  late final _FLDict_IsEmpty =
      _FLDict_IsEmptyPtr.asFunction<DartFLDict_IsEmpty>();

  /// If the dictionary is mutable, returns it cast to FLMutableDict, else NULL.
  FLMutableDict FLDict_AsMutable(
    FLDict arg0,
  ) {
    return _FLDict_AsMutable(
      arg0,
    );
  }

  late final _FLDict_AsMutablePtr =
      _lookup<ffi.NativeFunction<NativeFLDict_AsMutable>>('FLDict_AsMutable');
  late final _FLDict_AsMutable =
      _FLDict_AsMutablePtr.asFunction<DartFLDict_AsMutable>();

  /// Looks up a key in a dictionary, returning its value. Returns NULL if the
  /// value is not found or if the dictionary is NULL.
  FLValue FLDict_Get(
    FLDict arg0,
    FLSlice keyString,
  ) {
    return _FLDict_Get(
      arg0,
      keyString,
    );
  }

  late final _FLDict_GetPtr =
      _lookup<ffi.NativeFunction<NativeFLDict_Get>>('FLDict_Get');
  late final _FLDict_Get = _FLDict_GetPtr.asFunction<DartFLDict_Get>();

  /// Initializes a FLDictIterator struct to iterate over a dictionary. Call
  /// FLDictIterator_GetKey and FLDictIterator_GetValue to get the first item,
  /// then FLDictIterator_Next.
  void FLDictIterator_Begin(
    FLDict arg0,
    ffi.Pointer<FLDictIterator> arg1,
  ) {
    return _FLDictIterator_Begin(
      arg0,
      arg1,
    );
  }

  late final _FLDictIterator_BeginPtr =
      _lookup<ffi.NativeFunction<NativeFLDictIterator_Begin>>(
          'FLDictIterator_Begin');
  late final _FLDictIterator_Begin =
      _FLDictIterator_BeginPtr.asFunction<DartFLDictIterator_Begin>();

  /// Returns the current key being iterated over. This Value will be a string
  /// or an integer.
  FLValue FLDictIterator_GetKey(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetKey(
      arg0,
    );
  }

  late final _FLDictIterator_GetKeyPtr =
      _lookup<ffi.NativeFunction<NativeFLDictIterator_GetKey>>(
          'FLDictIterator_GetKey');
  late final _FLDictIterator_GetKey =
      _FLDictIterator_GetKeyPtr.asFunction<DartFLDictIterator_GetKey>();

  /// Returns the current key's string value.
  FLString FLDictIterator_GetKeyString(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetKeyString(
      arg0,
    );
  }

  late final _FLDictIterator_GetKeyStringPtr =
      _lookup<ffi.NativeFunction<NativeFLDictIterator_GetKeyString>>(
          'FLDictIterator_GetKeyString');
  late final _FLDictIterator_GetKeyString = _FLDictIterator_GetKeyStringPtr
      .asFunction<DartFLDictIterator_GetKeyString>();

  /// Returns the current value being iterated over.
  FLValue FLDictIterator_GetValue(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetValue(
      arg0,
    );
  }

  late final _FLDictIterator_GetValuePtr =
      _lookup<ffi.NativeFunction<NativeFLDictIterator_GetValue>>(
          'FLDictIterator_GetValue');
  late final _FLDictIterator_GetValue =
      _FLDictIterator_GetValuePtr.asFunction<DartFLDictIterator_GetValue>();

  /// Returns the number of items remaining to be iterated, including the
  /// current one.
  int FLDictIterator_GetCount(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetCount(
      arg0,
    );
  }

  late final _FLDictIterator_GetCountPtr =
      _lookup<ffi.NativeFunction<NativeFLDictIterator_GetCount>>(
          'FLDictIterator_GetCount');
  late final _FLDictIterator_GetCount =
      _FLDictIterator_GetCountPtr.asFunction<DartFLDictIterator_GetCount>();

  /// Advances the iterator to the next value, or returns false if at the end.
  bool FLDictIterator_Next(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_Next(
      arg0,
    );
  }

  late final _FLDictIterator_NextPtr =
      _lookup<ffi.NativeFunction<NativeFLDictIterator_Next>>(
          'FLDictIterator_Next');
  late final _FLDictIterator_Next =
      _FLDictIterator_NextPtr.asFunction<DartFLDictIterator_Next>();

  /// Cleans up after an iterator. Only needed if (a) the dictionary is a delta,
  /// and (b) you stop iterating before the end (i.e. before FLDictIterator_Next
  /// returns false.)
  void FLDictIterator_End(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_End(
      arg0,
    );
  }

  late final _FLDictIterator_EndPtr =
      _lookup<ffi.NativeFunction<NativeFLDictIterator_End>>(
          'FLDictIterator_End');
  late final _FLDictIterator_End =
      _FLDictIterator_EndPtr.asFunction<DartFLDictIterator_End>();

  /// Initializes an FLDictKey struct with a key string. @warning The input
  /// string's memory MUST remain valid for as long as the FLDictKey is in use!
  /// (The FLDictKey stores a pointer to the string, but does not copy it.)
  /// @param string The key string (UTF-8). @return An initialized FLDictKey
  /// struct.
  FLDictKey FLDictKey_Init(
    FLSlice string,
  ) {
    return _FLDictKey_Init(
      string,
    );
  }

  late final _FLDictKey_InitPtr =
      _lookup<ffi.NativeFunction<NativeFLDictKey_Init>>('FLDictKey_Init');
  late final _FLDictKey_Init =
      _FLDictKey_InitPtr.asFunction<DartFLDictKey_Init>();

  /// Returns the string value of the key (which it was initialized with.)
  FLString FLDictKey_GetString(
    ffi.Pointer<FLDictKey> arg0,
  ) {
    return _FLDictKey_GetString(
      arg0,
    );
  }

  late final _FLDictKey_GetStringPtr =
      _lookup<ffi.NativeFunction<NativeFLDictKey_GetString>>(
          'FLDictKey_GetString');
  late final _FLDictKey_GetString =
      _FLDictKey_GetStringPtr.asFunction<DartFLDictKey_GetString>();

  /// Looks up a key in a dictionary using an FLDictKey. If the key is found,
  /// "hint" data will be stored inside the FLDictKey that will speed up
  /// subsequent lookups.
  FLValue FLDict_GetWithKey(
    FLDict arg0,
    ffi.Pointer<FLDictKey> arg1,
  ) {
    return _FLDict_GetWithKey(
      arg0,
      arg1,
    );
  }

  late final _FLDict_GetWithKeyPtr =
      _lookup<ffi.NativeFunction<NativeFLDict_GetWithKey>>('FLDict_GetWithKey');
  late final _FLDict_GetWithKey =
      _FLDict_GetWithKeyPtr.asFunction<DartFLDict_GetWithKey>();

  /// Creates a FLDeepIterator to iterate over a dictionary. Call
  /// FLDeepIterator_GetKey and FLDeepIterator_GetValue to get the first item,
  /// then FLDeepIterator_Next.
  FLDeepIterator FLDeepIterator_New(
    FLValue arg0,
  ) {
    return _FLDeepIterator_New(
      arg0,
    );
  }

  late final _FLDeepIterator_NewPtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_New>>(
          'FLDeepIterator_New');
  late final _FLDeepIterator_New =
      _FLDeepIterator_NewPtr.asFunction<DartFLDeepIterator_New>();

  void FLDeepIterator_Free(
    FLDeepIterator arg0,
  ) {
    return _FLDeepIterator_Free(
      arg0,
    );
  }

  late final _FLDeepIterator_FreePtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_Free>>(
          'FLDeepIterator_Free');
  late final _FLDeepIterator_Free =
      _FLDeepIterator_FreePtr.asFunction<DartFLDeepIterator_Free>();

  /// Returns the current value being iterated over. or NULL at the end of
  /// iteration.
  FLValue FLDeepIterator_GetValue(
    FLDeepIterator arg0,
  ) {
    return _FLDeepIterator_GetValue(
      arg0,
    );
  }

  late final _FLDeepIterator_GetValuePtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_GetValue>>(
          'FLDeepIterator_GetValue');
  late final _FLDeepIterator_GetValue =
      _FLDeepIterator_GetValuePtr.asFunction<DartFLDeepIterator_GetValue>();

  /// Returns the parent/container of the current value, or NULL at the end of
  /// iteration.
  FLValue FLDeepIterator_GetParent(
    FLDeepIterator arg0,
  ) {
    return _FLDeepIterator_GetParent(
      arg0,
    );
  }

  late final _FLDeepIterator_GetParentPtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_GetParent>>(
          'FLDeepIterator_GetParent');
  late final _FLDeepIterator_GetParent =
      _FLDeepIterator_GetParentPtr.asFunction<DartFLDeepIterator_GetParent>();

  /// Returns the key of the current value in its parent, or an empty slice if
  /// not in a dictionary.
  FLSlice FLDeepIterator_GetKey(
    FLDeepIterator arg0,
  ) {
    return _FLDeepIterator_GetKey(
      arg0,
    );
  }

  late final _FLDeepIterator_GetKeyPtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_GetKey>>(
          'FLDeepIterator_GetKey');
  late final _FLDeepIterator_GetKey =
      _FLDeepIterator_GetKeyPtr.asFunction<DartFLDeepIterator_GetKey>();

  /// Returns the array index of the current value in its parent, or 0 if not in
  /// an array.
  int FLDeepIterator_GetIndex(
    FLDeepIterator arg0,
  ) {
    return _FLDeepIterator_GetIndex(
      arg0,
    );
  }

  late final _FLDeepIterator_GetIndexPtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_GetIndex>>(
          'FLDeepIterator_GetIndex');
  late final _FLDeepIterator_GetIndex =
      _FLDeepIterator_GetIndexPtr.asFunction<DartFLDeepIterator_GetIndex>();

  /// Returns the current depth in the hierarchy, starting at 1 for the
  /// top-level children.
  int FLDeepIterator_GetDepth(
    FLDeepIterator arg0,
  ) {
    return _FLDeepIterator_GetDepth(
      arg0,
    );
  }

  late final _FLDeepIterator_GetDepthPtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_GetDepth>>(
          'FLDeepIterator_GetDepth');
  late final _FLDeepIterator_GetDepth =
      _FLDeepIterator_GetDepthPtr.asFunction<DartFLDeepIterator_GetDepth>();

  /// Tells the iterator to skip the children of the current value.
  void FLDeepIterator_SkipChildren(
    FLDeepIterator arg0,
  ) {
    return _FLDeepIterator_SkipChildren(
      arg0,
    );
  }

  late final _FLDeepIterator_SkipChildrenPtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_SkipChildren>>(
          'FLDeepIterator_SkipChildren');
  late final _FLDeepIterator_SkipChildren = _FLDeepIterator_SkipChildrenPtr
      .asFunction<DartFLDeepIterator_SkipChildren>();

  /// Advances the iterator to the next value, or returns false if at the end.
  bool FLDeepIterator_Next(
    FLDeepIterator arg0,
  ) {
    return _FLDeepIterator_Next(
      arg0,
    );
  }

  late final _FLDeepIterator_NextPtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_Next>>(
          'FLDeepIterator_Next');
  late final _FLDeepIterator_Next =
      _FLDeepIterator_NextPtr.asFunction<DartFLDeepIterator_Next>();

  /// Returns the path as an array of FLPathComponents.
  void FLDeepIterator_GetPath(
    FLDeepIterator arg0,
    ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
    ffi.Pointer<ffi.Size> outDepth,
  ) {
    return _FLDeepIterator_GetPath(
      arg0,
      outPath,
      outDepth,
    );
  }

  late final _FLDeepIterator_GetPathPtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_GetPath>>(
          'FLDeepIterator_GetPath');
  late final _FLDeepIterator_GetPath =
      _FLDeepIterator_GetPathPtr.asFunction<DartFLDeepIterator_GetPath>();

  /// Returns the current path in JavaScript format.
  FLSliceResult FLDeepIterator_GetPathString(
    FLDeepIterator arg0,
  ) {
    return _FLDeepIterator_GetPathString(
      arg0,
    );
  }

  late final _FLDeepIterator_GetPathStringPtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_GetPathString>>(
          'FLDeepIterator_GetPathString');
  late final _FLDeepIterator_GetPathString = _FLDeepIterator_GetPathStringPtr
      .asFunction<DartFLDeepIterator_GetPathString>();

  /// Returns the current path in JSONPointer format (RFC 6901).
  FLSliceResult FLDeepIterator_GetJSONPointer(
    FLDeepIterator arg0,
  ) {
    return _FLDeepIterator_GetJSONPointer(
      arg0,
    );
  }

  late final _FLDeepIterator_GetJSONPointerPtr =
      _lookup<ffi.NativeFunction<NativeFLDeepIterator_GetJSONPointer>>(
          'FLDeepIterator_GetJSONPointer');
  late final _FLDeepIterator_GetJSONPointer = _FLDeepIterator_GetJSONPointerPtr
      .asFunction<DartFLDeepIterator_GetJSONPointer>();

  /// Creates an FLDoc from Fleece-encoded data that's been returned as a result
  /// from FLSlice_Copy or other API. The resulting document retains the data,
  /// so you don't need to worry about it remaining valid.
  FLDoc FLDoc_FromResultData(
    FLSliceResult data,
    FLTrust arg1,
    FLSharedKeys arg2,
    FLSlice externData,
  ) {
    return _FLDoc_FromResultData(
      data,
      arg1.value,
      arg2,
      externData,
    );
  }

  late final _FLDoc_FromResultDataPtr =
      _lookup<ffi.NativeFunction<NativeFLDoc_FromResultData>>(
          'FLDoc_FromResultData');
  late final _FLDoc_FromResultData =
      _FLDoc_FromResultDataPtr.asFunction<DartFLDoc_FromResultData>();

  /// Releases a reference to an FLDoc. This must be called once to free an
  /// FLDoc you created.
  void FLDoc_Release(
    FLDoc arg0,
  ) {
    return _FLDoc_Release(
      arg0,
    );
  }

  late final _FLDoc_ReleasePtr =
      _lookup<ffi.NativeFunction<NativeFLDoc_Release>>('FLDoc_Release');
  late final _FLDoc_Release = _FLDoc_ReleasePtr.asFunction<DartFLDoc_Release>();

  /// Adds a reference to an FLDoc. This extends its lifespan until at least
  /// such time as you call FLRelease to remove the reference.
  FLDoc FLDoc_Retain(
    FLDoc arg0,
  ) {
    return _FLDoc_Retain(
      arg0,
    );
  }

  late final _FLDoc_RetainPtr =
      _lookup<ffi.NativeFunction<NativeFLDoc_Retain>>('FLDoc_Retain');
  late final _FLDoc_Retain = _FLDoc_RetainPtr.asFunction<DartFLDoc_Retain>();

  /// Returns the encoded Fleece data backing the document.
  FLSlice FLDoc_GetData(
    FLDoc arg0,
  ) {
    return _FLDoc_GetData(
      arg0,
    );
  }

  late final _FLDoc_GetDataPtr =
      _lookup<ffi.NativeFunction<NativeFLDoc_GetData>>('FLDoc_GetData');
  late final _FLDoc_GetData = _FLDoc_GetDataPtr.asFunction<DartFLDoc_GetData>();

  /// Returns the FLSliceResult data owned by the document, if any, else a null
  /// slice.
  FLSliceResult FLDoc_GetAllocedData(
    FLDoc arg0,
  ) {
    return _FLDoc_GetAllocedData(
      arg0,
    );
  }

  late final _FLDoc_GetAllocedDataPtr =
      _lookup<ffi.NativeFunction<NativeFLDoc_GetAllocedData>>(
          'FLDoc_GetAllocedData');
  late final _FLDoc_GetAllocedData =
      _FLDoc_GetAllocedDataPtr.asFunction<DartFLDoc_GetAllocedData>();

  /// Returns the root value in the FLDoc, usually an FLDict.
  FLValue FLDoc_GetRoot(
    FLDoc arg0,
  ) {
    return _FLDoc_GetRoot(
      arg0,
    );
  }

  late final _FLDoc_GetRootPtr =
      _lookup<ffi.NativeFunction<NativeFLDoc_GetRoot>>('FLDoc_GetRoot');
  late final _FLDoc_GetRoot = _FLDoc_GetRootPtr.asFunction<DartFLDoc_GetRoot>();

  /// Returns the FLSharedKeys used by this FLDoc, as specified when it was
  /// created.
  FLSharedKeys FLDoc_GetSharedKeys(
    FLDoc arg0,
  ) {
    return _FLDoc_GetSharedKeys(
      arg0,
    );
  }

  late final _FLDoc_GetSharedKeysPtr =
      _lookup<ffi.NativeFunction<NativeFLDoc_GetSharedKeys>>(
          'FLDoc_GetSharedKeys');
  late final _FLDoc_GetSharedKeys =
      _FLDoc_GetSharedKeysPtr.asFunction<DartFLDoc_GetSharedKeys>();

  /// Looks up the Doc containing the Value, or NULL if there is none. @note
  /// Caller must release the FLDoc reference!!
  FLDoc FLValue_FindDoc(
    FLValue arg0,
  ) {
    return _FLValue_FindDoc(
      arg0,
    );
  }

  late final _FLValue_FindDocPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_FindDoc>>('FLValue_FindDoc');
  late final _FLValue_FindDoc =
      _FLValue_FindDocPtr.asFunction<DartFLValue_FindDoc>();

  /// Associates an arbitrary pointer value with a document, and thus its
  /// contained values. Allows client code to associate its own pointer with
  /// this FLDoc and its Values, which can later be retrieved with \ref
  /// FLDoc_GetAssociated. For example, this could be a pointer to an
  /// `app::Document` object, of which this Doc's root FLDict is its properties.
  /// You would store it by calling
  /// `FLDoc_SetAssociated(doc, myDoc, "app::Document");`. @param doc The FLDoc
  /// to store a pointer in. @param pointer The pointer to store in the FLDoc.
  /// @param type A C string literal identifying the type. This is used to avoid
  /// collisions with unrelated code that might try to store a different type of
  /// value. @return True if the pointer was stored, false if a pointer of a
  /// different type is already stored. @warning Be sure to clear this before
  /// the associated object is freed/invalidated! @warning This function is not
  /// thread-safe. Do not concurrently get & set objects.
  bool FLDoc_SetAssociated(
    FLDoc doc,
    ffi.Pointer<ffi.Void> pointer,
    ffi.Pointer<ffi.Char> type,
  ) {
    return _FLDoc_SetAssociated(
      doc,
      pointer,
      type,
    );
  }

  late final _FLDoc_SetAssociatedPtr =
      _lookup<ffi.NativeFunction<NativeFLDoc_SetAssociated>>(
          'FLDoc_SetAssociated');
  late final _FLDoc_SetAssociated =
      _FLDoc_SetAssociatedPtr.asFunction<DartFLDoc_SetAssociated>();

  /// Returns the pointer associated with the document. You can use this
  /// together with \ref FLValue_FindDoc to associate your own object with
  /// Fleece values, for instance to find your object that "owns" a value:
  /// `myDoc = (app::Document*)FLDoc_GetAssociated(FLValue_FindDoc(val), "app::Document");`.
  /// @param doc The FLDoc to get a pointer from. @param type The type of object
  /// expected, i.e. the same string literal passed to \ref FLDoc_SetAssociated.
  /// @return The associated pointer of that type, if any.
  ffi.Pointer<ffi.Void> FLDoc_GetAssociated(
    FLDoc doc,
    ffi.Pointer<ffi.Char> type,
  ) {
    return _FLDoc_GetAssociated(
      doc,
      type,
    );
  }

  late final _FLDoc_GetAssociatedPtr =
      _lookup<ffi.NativeFunction<NativeFLDoc_GetAssociated>>(
          'FLDoc_GetAssociated');
  late final _FLDoc_GetAssociated =
      _FLDoc_GetAssociatedPtr.asFunction<DartFLDoc_GetAssociated>();

  /// Creates a new encoder, for generating Fleece data. Call FLEncoder_Free
  /// when done.
  FLEncoder FLEncoder_New() {
    return _FLEncoder_New();
  }

  late final _FLEncoder_NewPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_New>>('FLEncoder_New');
  late final _FLEncoder_New = _FLEncoder_NewPtr.asFunction<DartFLEncoder_New>();

  /// Creates a new encoder, allowing some options to be customized. @param
  /// format The output format to generate (Fleece, JSON, or JSON5.) @param
  /// reserveSize The number of bytes to preallocate for the output. (Default
  /// is 256) @param uniqueStrings (Fleece only) If true, string values that
  /// appear multiple times will be written as a single shared value. This saves
  /// space but makes encoding slightly slower. You should only turn this off if
  /// you know you're going to be writing large numbers of non-repeated strings.
  /// (Default is true)
  FLEncoder FLEncoder_NewWithOptions(
    FLEncoderFormat format,
    int reserveSize,
    bool uniqueStrings,
  ) {
    return _FLEncoder_NewWithOptions(
      format.value,
      reserveSize,
      uniqueStrings,
    );
  }

  late final _FLEncoder_NewWithOptionsPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_NewWithOptions>>(
          'FLEncoder_NewWithOptions');
  late final _FLEncoder_NewWithOptions =
      _FLEncoder_NewWithOptionsPtr.asFunction<DartFLEncoder_NewWithOptions>();

  /// Creates a new Fleece encoder that writes to a file, not to memory.
  FLEncoder FLEncoder_NewWritingToFile(
    ffi.Pointer<FILE> arg0,
    bool uniqueStrings,
  ) {
    return _FLEncoder_NewWritingToFile(
      arg0,
      uniqueStrings,
    );
  }

  late final _FLEncoder_NewWritingToFilePtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_NewWritingToFile>>(
          'FLEncoder_NewWritingToFile');
  late final _FLEncoder_NewWritingToFile = _FLEncoder_NewWritingToFilePtr
      .asFunction<DartFLEncoder_NewWritingToFile>();

  /// Frees the space used by an encoder.
  void FLEncoder_Free(
    FLEncoder arg0,
  ) {
    return _FLEncoder_Free(
      arg0,
    );
  }

  late final _FLEncoder_FreePtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_Free>>('FLEncoder_Free');
  late final _FLEncoder_Free =
      _FLEncoder_FreePtr.asFunction<DartFLEncoder_Free>();

  /// Tells the encoder to use a shared-keys mapping when encoding dictionary
  /// keys.
  void FLEncoder_SetSharedKeys(
    FLEncoder arg0,
    FLSharedKeys arg1,
  ) {
    return _FLEncoder_SetSharedKeys(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_SetSharedKeysPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_SetSharedKeys>>(
          'FLEncoder_SetSharedKeys');
  late final _FLEncoder_SetSharedKeys =
      _FLEncoder_SetSharedKeysPtr.asFunction<DartFLEncoder_SetSharedKeys>();

  /// Associates an arbitrary user-defined value with the encoder.
  void FLEncoder_SetExtraInfo(
    FLEncoder arg0,
    ffi.Pointer<ffi.Void> info,
  ) {
    return _FLEncoder_SetExtraInfo(
      arg0,
      info,
    );
  }

  late final _FLEncoder_SetExtraInfoPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_SetExtraInfo>>(
          'FLEncoder_SetExtraInfo');
  late final _FLEncoder_SetExtraInfo =
      _FLEncoder_SetExtraInfoPtr.asFunction<DartFLEncoder_SetExtraInfo>();

  /// Returns the user-defined value associated with the encoder; NULL by
  /// default.
  ffi.Pointer<ffi.Void> FLEncoder_GetExtraInfo(
    FLEncoder arg0,
  ) {
    return _FLEncoder_GetExtraInfo(
      arg0,
    );
  }

  late final _FLEncoder_GetExtraInfoPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_GetExtraInfo>>(
          'FLEncoder_GetExtraInfo');
  late final _FLEncoder_GetExtraInfo =
      _FLEncoder_GetExtraInfoPtr.asFunction<DartFLEncoder_GetExtraInfo>();

  /// Resets the state of an encoder without freeing it. It can then be reused
  /// to encode another value.
  void FLEncoder_Reset(
    FLEncoder arg0,
  ) {
    return _FLEncoder_Reset(
      arg0,
    );
  }

  late final _FLEncoder_ResetPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_Reset>>('FLEncoder_Reset');
  late final _FLEncoder_Reset =
      _FLEncoder_ResetPtr.asFunction<DartFLEncoder_Reset>();

  /// Returns the number of bytes encoded so far.
  int FLEncoder_BytesWritten(
    FLEncoder arg0,
  ) {
    return _FLEncoder_BytesWritten(
      arg0,
    );
  }

  late final _FLEncoder_BytesWrittenPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_BytesWritten>>(
          'FLEncoder_BytesWritten');
  late final _FLEncoder_BytesWritten =
      _FLEncoder_BytesWrittenPtr.asFunction<DartFLEncoder_BytesWritten>();

  /// Writes a `null` value to an encoder. (This is an explicitly-stored null,
  /// like the JSON `null`, not the "undefined" value represented by a NULL
  /// FLValue pointer.)
  bool FLEncoder_WriteNull(
    FLEncoder arg0,
  ) {
    return _FLEncoder_WriteNull(
      arg0,
    );
  }

  late final _FLEncoder_WriteNullPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteNull>>(
          'FLEncoder_WriteNull');
  late final _FLEncoder_WriteNull =
      _FLEncoder_WriteNullPtr.asFunction<DartFLEncoder_WriteNull>();

  /// Writes an `undefined` value to an encoder. (Its value when read will not
  /// be a `NULL` pointer, but it can be recognized by `FLValue_GetType`
  /// returning `kFLUndefined`.) @note The only real use for writing undefined
  /// values is to represent "holes" in an array. An undefined dictionary value
  /// should be written simply by skipping the key and value.
  bool FLEncoder_WriteUndefined(
    FLEncoder arg0,
  ) {
    return _FLEncoder_WriteUndefined(
      arg0,
    );
  }

  late final _FLEncoder_WriteUndefinedPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteUndefined>>(
          'FLEncoder_WriteUndefined');
  late final _FLEncoder_WriteUndefined =
      _FLEncoder_WriteUndefinedPtr.asFunction<DartFLEncoder_WriteUndefined>();

  /// Writes a boolean value (true or false) to an encoder.
  bool FLEncoder_WriteBool(
    FLEncoder arg0,
    bool arg1,
  ) {
    return _FLEncoder_WriteBool(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteBoolPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteBool>>(
          'FLEncoder_WriteBool');
  late final _FLEncoder_WriteBool =
      _FLEncoder_WriteBoolPtr.asFunction<DartFLEncoder_WriteBool>();

  /// Writes an integer to an encoder. The parameter is typed as `int64_t` but
  /// you can pass any integral type (signed or unsigned) except for huge
  /// `uint64_t`s. The number will be written in a compact form that uses only
  /// as many bytes as necessary.
  bool FLEncoder_WriteInt(
    FLEncoder arg0,
    int arg1,
  ) {
    return _FLEncoder_WriteInt(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteIntPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteInt>>(
          'FLEncoder_WriteInt');
  late final _FLEncoder_WriteInt =
      _FLEncoder_WriteIntPtr.asFunction<DartFLEncoder_WriteInt>();

  /// Writes an unsigned integer to an encoder. @note This function is only
  /// really necessary for huge 64-bit integers greater than or equal to 2^63,
  /// which can't be represented as int64_t.
  bool FLEncoder_WriteUInt(
    FLEncoder arg0,
    int arg1,
  ) {
    return _FLEncoder_WriteUInt(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteUIntPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteUInt>>(
          'FLEncoder_WriteUInt');
  late final _FLEncoder_WriteUInt =
      _FLEncoder_WriteUIntPtr.asFunction<DartFLEncoder_WriteUInt>();

  /// Writes a 32-bit floating point number to an encoder. @note As an
  /// implementation detail, if the number has no fractional part and can be
  /// represented exactly as an integer, it'll be encoded as an integer to save
  /// space. This is transparent to the reader, since if it requests the value
  /// as a float it'll be returned as floating-point.
  bool FLEncoder_WriteFloat(
    FLEncoder arg0,
    double arg1,
  ) {
    return _FLEncoder_WriteFloat(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteFloatPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteFloat>>(
          'FLEncoder_WriteFloat');
  late final _FLEncoder_WriteFloat =
      _FLEncoder_WriteFloatPtr.asFunction<DartFLEncoder_WriteFloat>();

  /// Writes a 64-bit floating point number to an encoder. @note As an
  /// implementation detail, the number may be encoded as a 32-bit float or even
  /// as an integer, if this can be done without losing precision. For example,
  /// 123.0 will be written as an integer, and 123.75 as a float.)
  bool FLEncoder_WriteDouble(
    FLEncoder arg0,
    double arg1,
  ) {
    return _FLEncoder_WriteDouble(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteDoublePtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteDouble>>(
          'FLEncoder_WriteDouble');
  late final _FLEncoder_WriteDouble =
      _FLEncoder_WriteDoublePtr.asFunction<DartFLEncoder_WriteDouble>();

  /// Writes a string to an encoder. The string must be UTF-8-encoded and must
  /// not contain any zero bytes. @warning Do _not_ use this to write a
  /// dictionary key; use FLEncoder_WriteKey instead.
  bool FLEncoder_WriteString(
    FLEncoder arg0,
    FLString arg1,
  ) {
    return _FLEncoder_WriteString(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteStringPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteString>>(
          'FLEncoder_WriteString');
  late final _FLEncoder_WriteString =
      _FLEncoder_WriteStringPtr.asFunction<DartFLEncoder_WriteString>();

  /// Writes a timestamp to an encoder, as an ISO-8601 date string. @note Since
  /// neither Fleece nor JSON have a 'Date' type, the encoded string has no
  /// metadata that distinguishes it as a date. It's just a string.) @param
  /// encoder The encoder to write to. @param ts The timestamp (milliseconds
  /// since Unix epoch 1-1-1970). @param asUTC If true, date is written in UTC
  /// (GMT); if false, with the local timezone. @return True on success, false
  /// on error.
  bool FLEncoder_WriteDateString(
    FLEncoder encoder,
    int ts,
    bool asUTC,
  ) {
    return _FLEncoder_WriteDateString(
      encoder,
      ts,
      asUTC,
    );
  }

  late final _FLEncoder_WriteDateStringPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteDateString>>(
          'FLEncoder_WriteDateString');
  late final _FLEncoder_WriteDateString =
      _FLEncoder_WriteDateStringPtr.asFunction<DartFLEncoder_WriteDateString>();

  /// Writes a binary data value (a blob) to an encoder. This can contain
  /// absolutely anything including null bytes. If the encoder is generating
  /// JSON, the blob will be written as a base64-encoded string.
  bool FLEncoder_WriteData(
    FLEncoder arg0,
    FLSlice arg1,
  ) {
    return _FLEncoder_WriteData(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteDataPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteData>>(
          'FLEncoder_WriteData');
  late final _FLEncoder_WriteData =
      _FLEncoder_WriteDataPtr.asFunction<DartFLEncoder_WriteData>();

  /// Writes a Fleece Value to an Encoder.
  bool FLEncoder_WriteValue(
    FLEncoder arg0,
    FLValue arg1,
  ) {
    return _FLEncoder_WriteValue(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteValuePtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteValue>>(
          'FLEncoder_WriteValue');
  late final _FLEncoder_WriteValue =
      _FLEncoder_WriteValuePtr.asFunction<DartFLEncoder_WriteValue>();

  /// Begins writing an array value to an encoder. This pushes a new state where
  /// each subsequent value written becomes an array item, until
  /// FLEncoder_EndArray is called. @param reserveCount Number of array elements
  /// to reserve space for. If you know the size of the array, providing it here
  /// speeds up encoding slightly. If you don't know, just use zero.
  bool FLEncoder_BeginArray(
    FLEncoder arg0,
    int reserveCount,
  ) {
    return _FLEncoder_BeginArray(
      arg0,
      reserveCount,
    );
  }

  late final _FLEncoder_BeginArrayPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_BeginArray>>(
          'FLEncoder_BeginArray');
  late final _FLEncoder_BeginArray =
      _FLEncoder_BeginArrayPtr.asFunction<DartFLEncoder_BeginArray>();

  /// Ends writing an array value; pops back the previous encoding state.
  bool FLEncoder_EndArray(
    FLEncoder arg0,
  ) {
    return _FLEncoder_EndArray(
      arg0,
    );
  }

  late final _FLEncoder_EndArrayPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_EndArray>>(
          'FLEncoder_EndArray');
  late final _FLEncoder_EndArray =
      _FLEncoder_EndArrayPtr.asFunction<DartFLEncoder_EndArray>();

  /// Begins writing a dictionary value to an encoder. This pushes a new state
  /// where each subsequent key and value written are added to the dictionary,
  /// until FLEncoder*EndDict is called. Before adding each value, you must call
  /// FLEncoder_WriteKey (\_not* FLEncoder_WriteString!), to write the
  /// dictionary key. @param reserveCount Number of dictionary items to reserve
  /// space for. If you know the size of the dictionary, providing it here
  /// speeds up encoding slightly. If you don't know, just use zero.
  bool FLEncoder_BeginDict(
    FLEncoder arg0,
    int reserveCount,
  ) {
    return _FLEncoder_BeginDict(
      arg0,
      reserveCount,
    );
  }

  late final _FLEncoder_BeginDictPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_BeginDict>>(
          'FLEncoder_BeginDict');
  late final _FLEncoder_BeginDict =
      _FLEncoder_BeginDictPtr.asFunction<DartFLEncoder_BeginDict>();

  /// Specifies the key for the next value to be written to the current
  /// dictionary.
  bool FLEncoder_WriteKey(
    FLEncoder arg0,
    FLString arg1,
  ) {
    return _FLEncoder_WriteKey(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteKeyPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteKey>>(
          'FLEncoder_WriteKey');
  late final _FLEncoder_WriteKey =
      _FLEncoder_WriteKeyPtr.asFunction<DartFLEncoder_WriteKey>();

  /// Specifies the key for the next value to be written to the current
  /// dictionary. The key is given as a Value, which must be a string or
  /// integer.
  bool FLEncoder_WriteKeyValue(
    FLEncoder arg0,
    FLValue arg1,
  ) {
    return _FLEncoder_WriteKeyValue(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteKeyValuePtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteKeyValue>>(
          'FLEncoder_WriteKeyValue');
  late final _FLEncoder_WriteKeyValue =
      _FLEncoder_WriteKeyValuePtr.asFunction<DartFLEncoder_WriteKeyValue>();

  /// Ends writing a dictionary value; pops back the previous encoding state.
  bool FLEncoder_EndDict(
    FLEncoder arg0,
  ) {
    return _FLEncoder_EndDict(
      arg0,
    );
  }

  late final _FLEncoder_EndDictPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_EndDict>>('FLEncoder_EndDict');
  late final _FLEncoder_EndDict =
      _FLEncoder_EndDictPtr.asFunction<DartFLEncoder_EndDict>();

  /// Writes raw data directly to the encoded output. (This is not the same as
  /// \ref FLEncoder_WriteData, which safely encodes a blob.) @warning **Do not
  /// call this** unless you really know what you're doing ... it's quite
  /// unsafe, and only used for certain advanced purposes.
  bool FLEncoder_WriteRaw(
    FLEncoder arg0,
    FLSlice arg1,
  ) {
    return _FLEncoder_WriteRaw(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_WriteRawPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteRaw>>(
          'FLEncoder_WriteRaw');
  late final _FLEncoder_WriteRaw =
      _FLEncoder_WriteRawPtr.asFunction<DartFLEncoder_WriteRaw>();

  /// Ends encoding; if there has been no error, it returns the encoded Fleece
  /// data packaged in an FLDoc. (This function does not support JSON encoding.)
  /// This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset)
  /// next.
  FLDoc FLEncoder_FinishDoc(
    FLEncoder arg0,
    ffi.Pointer<ffi.UnsignedInt> outError,
  ) {
    return _FLEncoder_FinishDoc(
      arg0,
      outError,
    );
  }

  late final _FLEncoder_FinishDocPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_FinishDoc>>(
          'FLEncoder_FinishDoc');
  late final _FLEncoder_FinishDoc =
      _FLEncoder_FinishDocPtr.asFunction<DartFLEncoder_FinishDoc>();

  /// Ends encoding; if there has been no error, it returns the encoded data,
  /// else null. This does not free the FLEncoder; call FLEncoder_Free (or
  /// FLEncoder_Reset) next.
  FLSliceResult FLEncoder_Finish(
    FLEncoder arg0,
    ffi.Pointer<ffi.UnsignedInt> outError,
  ) {
    return _FLEncoder_Finish(
      arg0,
      outError,
    );
  }

  late final _FLEncoder_FinishPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_Finish>>('FLEncoder_Finish');
  late final _FLEncoder_Finish =
      _FLEncoder_FinishPtr.asFunction<DartFLEncoder_Finish>();

  /// Returns the error code of an encoder, or NoError (0) if there's no error.
  FLError FLEncoder_GetError(
    FLEncoder arg0,
  ) {
    return FLError.fromValue(_FLEncoder_GetError(
      arg0,
    ));
  }

  late final _FLEncoder_GetErrorPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_GetError>>(
          'FLEncoder_GetError');
  late final _FLEncoder_GetError =
      _FLEncoder_GetErrorPtr.asFunction<DartFLEncoder_GetError>();

  /// Returns the error message of an encoder, or NULL if there's no error.
  ffi.Pointer<ffi.Char> FLEncoder_GetErrorMessage(
    FLEncoder arg0,
  ) {
    return _FLEncoder_GetErrorMessage(
      arg0,
    );
  }

  late final _FLEncoder_GetErrorMessagePtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_GetErrorMessage>>(
          'FLEncoder_GetErrorMessage');
  late final _FLEncoder_GetErrorMessage =
      _FLEncoder_GetErrorMessagePtr.asFunction<DartFLEncoder_GetErrorMessage>();

  /// Encodes a Fleece value as JSON (or a JSON fragment.) @note Any Data values
  /// will be encoded as base64-encoded strings.
  FLStringResult FLValue_ToJSON(
    FLValue arg0,
  ) {
    return _FLValue_ToJSON(
      arg0,
    );
  }

  late final _FLValue_ToJSONPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_ToJSON>>('FLValue_ToJSON');
  late final _FLValue_ToJSON =
      _FLValue_ToJSONPtr.asFunction<DartFLValue_ToJSON>();

  /// Encodes a Fleece value as JSON5, a more lenient variant of JSON that
  /// allows dictionary keys to be unquoted if they're alphanumeric. This tends
  /// to be more readable. @note Any Data values will be encoded as
  /// base64-encoded strings.
  FLStringResult FLValue_ToJSON5(
    FLValue arg0,
  ) {
    return _FLValue_ToJSON5(
      arg0,
    );
  }

  late final _FLValue_ToJSON5Ptr =
      _lookup<ffi.NativeFunction<NativeFLValue_ToJSON5>>('FLValue_ToJSON5');
  late final _FLValue_ToJSON5 =
      _FLValue_ToJSON5Ptr.asFunction<DartFLValue_ToJSON5>();

  /// Most general Fleece to JSON converter. @param v The Fleece value to encode
  /// @param json5 If true, outputs JSON5, like \ref FLValue_ToJSON5 @param
  /// canonicalForm If true, outputs the JSON in a consistent "canonical" form.
  /// All equivalent values should produce byte-for-byte identical canonical
  /// JSON. This is useful for creating digital signatures, for example.
  FLStringResult FLValue_ToJSONX(
    FLValue v,
    bool json5,
    bool canonicalForm,
  ) {
    return _FLValue_ToJSONX(
      v,
      json5,
      canonicalForm,
    );
  }

  late final _FLValue_ToJSONXPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_ToJSONX>>('FLValue_ToJSONX');
  late final _FLValue_ToJSONX =
      _FLValue_ToJSONXPtr.asFunction<DartFLValue_ToJSONX>();

  /// Creates an FLDoc from JSON-encoded data. The data is first encoded into
  /// Fleece, and the Fleece data is kept by the doc; the input JSON data is no
  /// longer needed after this function returns.
  FLDoc FLDoc_FromJSON(
    FLSlice json,
    ffi.Pointer<ffi.UnsignedInt> outError,
  ) {
    return _FLDoc_FromJSON(
      json,
      outError,
    );
  }

  late final _FLDoc_FromJSONPtr =
      _lookup<ffi.NativeFunction<NativeFLDoc_FromJSON>>('FLDoc_FromJSON');
  late final _FLDoc_FromJSON =
      _FLDoc_FromJSONPtr.asFunction<DartFLDoc_FromJSON>();

  /// Creates a new mutable Array from JSON. It is an error if the JSON is not
  /// an array. Its initial ref-count is 1, so a call to FLMutableArray_Release
  /// will free it.
  FLMutableArray FLMutableArray_NewFromJSON(
    FLString json,
    ffi.Pointer<ffi.UnsignedInt> outError,
  ) {
    return _FLMutableArray_NewFromJSON(
      json,
      outError,
    );
  }

  late final _FLMutableArray_NewFromJSONPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_NewFromJSON>>(
          'FLMutableArray_NewFromJSON');
  late final _FLMutableArray_NewFromJSON = _FLMutableArray_NewFromJSONPtr
      .asFunction<DartFLMutableArray_NewFromJSON>();

  /// Creates a new mutable Dict from json. It is an error if the JSON is not a
  /// dictionary/object. Its initial ref-count is 1, so a call to
  /// FLMutableDict_Release will free it.
  FLMutableDict FLMutableDict_NewFromJSON(
    FLString json,
    ffi.Pointer<ffi.UnsignedInt> outError,
  ) {
    return _FLMutableDict_NewFromJSON(
      json,
      outError,
    );
  }

  late final _FLMutableDict_NewFromJSONPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableDict_NewFromJSON>>(
          'FLMutableDict_NewFromJSON');
  late final _FLMutableDict_NewFromJSON =
      _FLMutableDict_NewFromJSONPtr.asFunction<DartFLMutableDict_NewFromJSON>();

  /// Parses JSON data and writes the value(s) to the encoder as their Fleece
  /// equivalents. (This acts as a single write, like WriteInt; it's just that
  /// the value written is likely to be an entire dictionary or array.)
  bool FLEncoder_ConvertJSON(
    FLEncoder arg0,
    FLSlice json,
  ) {
    return _FLEncoder_ConvertJSON(
      arg0,
      json,
    );
  }

  late final _FLEncoder_ConvertJSONPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_ConvertJSON>>(
          'FLEncoder_ConvertJSON');
  late final _FLEncoder_ConvertJSON =
      _FLEncoder_ConvertJSONPtr.asFunction<DartFLEncoder_ConvertJSON>();

  /// Creates a new FLKeyPath object by compiling a path specifier string.
  FLKeyPath FLKeyPath_New(
    FLSlice specifier,
    ffi.Pointer<ffi.UnsignedInt> outError,
  ) {
    return _FLKeyPath_New(
      specifier,
      outError,
    );
  }

  late final _FLKeyPath_NewPtr =
      _lookup<ffi.NativeFunction<NativeFLKeyPath_New>>('FLKeyPath_New');
  late final _FLKeyPath_New = _FLKeyPath_NewPtr.asFunction<DartFLKeyPath_New>();

  /// Frees a compiled FLKeyPath object. (It's ok to pass NULL.)
  void FLKeyPath_Free(
    FLKeyPath arg0,
  ) {
    return _FLKeyPath_Free(
      arg0,
    );
  }

  late final _FLKeyPath_FreePtr =
      _lookup<ffi.NativeFunction<NativeFLKeyPath_Free>>('FLKeyPath_Free');
  late final _FLKeyPath_Free =
      _FLKeyPath_FreePtr.asFunction<DartFLKeyPath_Free>();

  /// Evaluates a compiled key-path for a given Fleece root object.
  FLValue FLKeyPath_Eval(
    FLKeyPath arg0,
    FLValue root,
  ) {
    return _FLKeyPath_Eval(
      arg0,
      root,
    );
  }

  late final _FLKeyPath_EvalPtr =
      _lookup<ffi.NativeFunction<NativeFLKeyPath_Eval>>('FLKeyPath_Eval');
  late final _FLKeyPath_Eval =
      _FLKeyPath_EvalPtr.asFunction<DartFLKeyPath_Eval>();

  /// Evaluates a key-path from a specifier string, for a given Fleece root
  /// object. If you only need to evaluate the path once, this is a bit faster
  /// than creating an FLKeyPath object, evaluating, then freeing it.
  FLValue FLKeyPath_EvalOnce(
    FLSlice specifier,
    FLValue root,
    ffi.Pointer<ffi.UnsignedInt> outError,
  ) {
    return _FLKeyPath_EvalOnce(
      specifier,
      root,
      outError,
    );
  }

  late final _FLKeyPath_EvalOncePtr =
      _lookup<ffi.NativeFunction<NativeFLKeyPath_EvalOnce>>(
          'FLKeyPath_EvalOnce');
  late final _FLKeyPath_EvalOnce =
      _FLKeyPath_EvalOncePtr.asFunction<DartFLKeyPath_EvalOnce>();

  /// Returns a path in string form.
  FLStringResult FLKeyPath_ToString(
    FLKeyPath path,
  ) {
    return _FLKeyPath_ToString(
      path,
    );
  }

  late final _FLKeyPath_ToStringPtr =
      _lookup<ffi.NativeFunction<NativeFLKeyPath_ToString>>(
          'FLKeyPath_ToString');
  late final _FLKeyPath_ToString =
      _FLKeyPath_ToStringPtr.asFunction<DartFLKeyPath_ToString>();

  /// Equality test.
  bool FLKeyPath_Equals(
    FLKeyPath path1,
    FLKeyPath path2,
  ) {
    return _FLKeyPath_Equals(
      path1,
      path2,
    );
  }

  late final _FLKeyPath_EqualsPtr =
      _lookup<ffi.NativeFunction<NativeFLKeyPath_Equals>>('FLKeyPath_Equals');
  late final _FLKeyPath_Equals =
      _FLKeyPath_EqualsPtr.asFunction<DartFLKeyPath_Equals>();

  /// Returns an element of a path, either a key or an array index.
  bool FLKeyPath_GetElement(
    FLKeyPath arg0,
    int i,
    ffi.Pointer<FLSlice> outDictKey,
    ffi.Pointer<ffi.Int32> outArrayIndex,
  ) {
    return _FLKeyPath_GetElement(
      arg0,
      i,
      outDictKey,
      outArrayIndex,
    );
  }

  late final _FLKeyPath_GetElementPtr =
      _lookup<ffi.NativeFunction<NativeFLKeyPath_GetElement>>(
          'FLKeyPath_GetElement');
  late final _FLKeyPath_GetElement =
      _FLKeyPath_GetElementPtr.asFunction<DartFLKeyPath_GetElement>();

  /// A constant null value (like a JSON `null`, not a NULL pointer!)
  late final ffi.Pointer<FLValue> _kFLNullValue =
      _lookup<FLValue>('kFLNullValue');

  FLValue get kFLNullValue => _kFLNullValue.value;

  set kFLNullValue(FLValue value) => _kFLNullValue.value = value;

  /// A constant undefined value. This is not a NULL pointer, but its type is
  /// \ref kFLUndefined. It can be stored in an \ref FLMutableArray or \ref
  /// FLMutableDict if you really, really need to store an undefined/empty
  /// value, not just a JSON `null`.
  late final ffi.Pointer<FLValue> _kFLUndefinedValue =
      _lookup<FLValue>('kFLUndefinedValue');

  FLValue get kFLUndefinedValue => _kFLUndefinedValue.value;

  set kFLUndefinedValue(FLValue value) => _kFLUndefinedValue.value = value;

  /// Returns the data type of an arbitrary value. If the parameter is a NULL
  /// pointer, returns `kFLUndefined`.
  FLValueType FLValue_GetType(
    FLValue arg0,
  ) {
    return FLValueType.fromValue(_FLValue_GetType(
      arg0,
    ));
  }

  late final _FLValue_GetTypePtr =
      _lookup<ffi.NativeFunction<NativeFLValue_GetType>>('FLValue_GetType');
  late final _FLValue_GetType =
      _FLValue_GetTypePtr.asFunction<DartFLValue_GetType>();

  /// Returns true if the value is non-NULL and represents an integer.
  bool FLValue_IsInteger(
    FLValue arg0,
  ) {
    return _FLValue_IsInteger(
      arg0,
    );
  }

  late final _FLValue_IsIntegerPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_IsInteger>>('FLValue_IsInteger');
  late final _FLValue_IsInteger =
      _FLValue_IsIntegerPtr.asFunction<DartFLValue_IsInteger>();

  /// Returns true if the value is non-NULL and represents an integer >= 2^63.
  /// Such a value can't be represented in C as an `int64_t`, only a `uint64_t`,
  /// so you should access it by calling `FLValueAsUnsigned`, _not_
  /// FLValueAsInt, which would return an incorrect (negative) value.
  bool FLValue_IsUnsigned(
    FLValue arg0,
  ) {
    return _FLValue_IsUnsigned(
      arg0,
    );
  }

  late final _FLValue_IsUnsignedPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_IsUnsigned>>(
          'FLValue_IsUnsigned');
  late final _FLValue_IsUnsigned =
      _FLValue_IsUnsignedPtr.asFunction<DartFLValue_IsUnsigned>();

  /// Returns true if the value is non-NULL and represents a 64-bit
  /// floating-point number.
  bool FLValue_IsDouble(
    FLValue arg0,
  ) {
    return _FLValue_IsDouble(
      arg0,
    );
  }

  late final _FLValue_IsDoublePtr =
      _lookup<ffi.NativeFunction<NativeFLValue_IsDouble>>('FLValue_IsDouble');
  late final _FLValue_IsDouble =
      _FLValue_IsDoublePtr.asFunction<DartFLValue_IsDouble>();

  /// Returns a value coerced to boolean. This will be true unless the value is
  /// NULL (undefined), null, false, or zero.
  bool FLValue_AsBool(
    FLValue arg0,
  ) {
    return _FLValue_AsBool(
      arg0,
    );
  }

  late final _FLValue_AsBoolPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_AsBool>>('FLValue_AsBool');
  late final _FLValue_AsBool =
      _FLValue_AsBoolPtr.asFunction<DartFLValue_AsBool>();

  /// Returns a value coerced to an integer. True and false are returned as 1
  /// and 0, and floating-point numbers are rounded. All other types are
  /// returned as 0. @warning Large 64-bit unsigned integers (2^63 and above)
  /// will come out wrong. You can check for these by calling
  /// `FLValueIsUnsigned`.
  int FLValue_AsInt(
    FLValue arg0,
  ) {
    return _FLValue_AsInt(
      arg0,
    );
  }

  late final _FLValue_AsIntPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_AsInt>>('FLValue_AsInt');
  late final _FLValue_AsInt = _FLValue_AsIntPtr.asFunction<DartFLValue_AsInt>();

  /// Returns a value coerced to an unsigned integer. This is the same as
  /// `FLValueAsInt` except that it _can't_ handle negative numbers, but does
  /// correctly return large `uint64_t` values of 2^63 and up.
  int FLValue_AsUnsigned(
    FLValue arg0,
  ) {
    return _FLValue_AsUnsigned(
      arg0,
    );
  }

  late final _FLValue_AsUnsignedPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_AsUnsigned>>(
          'FLValue_AsUnsigned');
  late final _FLValue_AsUnsigned =
      _FLValue_AsUnsignedPtr.asFunction<DartFLValue_AsUnsigned>();

  /// Returns a value coerced to a 32-bit floating point number. True and false
  /// are returned as 1.0 and 0.0, and integers are converted to float. All
  /// other types are returned as 0.0. @warning Large integers (outside
  /// approximately +/- 2^23) will lose precision due to the limitations of IEEE
  /// 32-bit float format.
  double FLValue_AsFloat(
    FLValue arg0,
  ) {
    return _FLValue_AsFloat(
      arg0,
    );
  }

  late final _FLValue_AsFloatPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_AsFloat>>('FLValue_AsFloat');
  late final _FLValue_AsFloat =
      _FLValue_AsFloatPtr.asFunction<DartFLValue_AsFloat>();

  /// Returns a value coerced to a 32-bit floating point number. True and false
  /// are returned as 1.0 and 0.0, and integers are converted to float. All
  /// other types are returned as 0.0. @warning Very large integers (outside
  /// approximately +/- 2^50) will lose precision due to the limitations of IEEE
  /// 32-bit float format.
  double FLValue_AsDouble(
    FLValue arg0,
  ) {
    return _FLValue_AsDouble(
      arg0,
    );
  }

  late final _FLValue_AsDoublePtr =
      _lookup<ffi.NativeFunction<NativeFLValue_AsDouble>>('FLValue_AsDouble');
  late final _FLValue_AsDouble =
      _FLValue_AsDoublePtr.asFunction<DartFLValue_AsDouble>();

  /// Returns the exact contents of a string value, or null for all other types.
  FLString FLValue_AsString(
    FLValue arg0,
  ) {
    return _FLValue_AsString(
      arg0,
    );
  }

  late final _FLValue_AsStringPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_AsString>>('FLValue_AsString');
  late final _FLValue_AsString =
      _FLValue_AsStringPtr.asFunction<DartFLValue_AsString>();

  /// Converts a value to a timestamp, in milliseconds since Unix epoch, or
  /// INT64_MIN on failure.
  ///
  /// - A string is parsed as ISO-8601 (standard JSON date format).
  /// - A number is interpreted as a timestamp and returned as-is.
  int FLValue_AsTimestamp(
    FLValue arg0,
  ) {
    return _FLValue_AsTimestamp(
      arg0,
    );
  }

  late final _FLValue_AsTimestampPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_AsTimestamp>>(
          'FLValue_AsTimestamp');
  late final _FLValue_AsTimestamp =
      _FLValue_AsTimestampPtr.asFunction<DartFLValue_AsTimestamp>();

  /// Returns the exact contents of a data value, or null for all other types.
  FLSlice FLValue_AsData(
    FLValue arg0,
  ) {
    return _FLValue_AsData(
      arg0,
    );
  }

  late final _FLValue_AsDataPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_AsData>>('FLValue_AsData');
  late final _FLValue_AsData =
      _FLValue_AsDataPtr.asFunction<DartFLValue_AsData>();

  /// If a FLValue represents an array, returns it cast to FLArray, else NULL.
  FLArray FLValue_AsArray(
    FLValue arg0,
  ) {
    return _FLValue_AsArray(
      arg0,
    );
  }

  late final _FLValue_AsArrayPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_AsArray>>('FLValue_AsArray');
  late final _FLValue_AsArray =
      _FLValue_AsArrayPtr.asFunction<DartFLValue_AsArray>();

  /// If a FLValue represents a dictionary, returns it as an FLDict, else NULL.
  FLDict FLValue_AsDict(
    FLValue arg0,
  ) {
    return _FLValue_AsDict(
      arg0,
    );
  }

  late final _FLValue_AsDictPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_AsDict>>('FLValue_AsDict');
  late final _FLValue_AsDict =
      _FLValue_AsDictPtr.asFunction<DartFLValue_AsDict>();

  /// Returns a string representation of any scalar value. Data values are
  /// returned in raw form. Arrays and dictionaries don't have a representation
  /// and will return NULL.
  FLStringResult FLValue_ToString(
    FLValue arg0,
  ) {
    return _FLValue_ToString(
      arg0,
    );
  }

  late final _FLValue_ToStringPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_ToString>>('FLValue_ToString');
  late final _FLValue_ToString =
      _FLValue_ToStringPtr.asFunction<DartFLValue_ToString>();

  /// Compares two values for equality. This is a deep recursive comparison.
  bool FLValue_IsEqual(
    FLValue v1,
    FLValue v2,
  ) {
    return _FLValue_IsEqual(
      v1,
      v2,
    );
  }

  late final _FLValue_IsEqualPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_IsEqual>>('FLValue_IsEqual');
  late final _FLValue_IsEqual =
      _FLValue_IsEqualPtr.asFunction<DartFLValue_IsEqual>();

  /// Returns true if the value is mutable.
  bool FLValue_IsMutable(
    FLValue arg0,
  ) {
    return _FLValue_IsMutable(
      arg0,
    );
  }

  late final _FLValue_IsMutablePtr =
      _lookup<ffi.NativeFunction<NativeFLValue_IsMutable>>('FLValue_IsMutable');
  late final _FLValue_IsMutable =
      _FLValue_IsMutablePtr.asFunction<DartFLValue_IsMutable>();

  /// Increments the ref-count of a mutable value, or of an immutable value's
  /// \ref FLDoc. @warning It is illegal to call this on a value obtained from
  /// \ref FLValue_FromData.
  FLValue FLValue_Retain(
    FLValue arg0,
  ) {
    return _FLValue_Retain(
      arg0,
    );
  }

  late final _FLValue_RetainPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_Retain>>('FLValue_Retain');
  late final _FLValue_Retain =
      _FLValue_RetainPtr.asFunction<DartFLValue_Retain>();

  /// Decrements the ref-count of a mutable value, or of an immutable value's
  /// \ref FLDoc. If the ref-count reaches zero the corresponding object is
  /// freed. @warning It is illegal to call this on a value obtained from \ref
  /// FLValue_FromData.
  void FLValue_Release(
    FLValue arg0,
  ) {
    return _FLValue_Release(
      arg0,
    );
  }

  late final _FLValue_ReleasePtr =
      _lookup<ffi.NativeFunction<NativeFLValue_Release>>('FLValue_Release');
  late final _FLValue_Release =
      _FLValue_ReleasePtr.asFunction<DartFLValue_Release>();

  /// Creates a new mutable Array that's a copy of the source Array. Its initial
  /// ref-count is 1, so a call to \ref FLMutableArray_Release will free it.
  ///
  /// Copying an immutable Array is very cheap (only one small allocation)
  /// unless the flag \ref kFLCopyImmutables is set.
  ///
  /// Copying a mutable Array is cheap if it's a shallow copy; but if \ref
  /// kFLDeepCopy is set, nested mutable Arrays and Dicts are also copied,
  /// recursively; if \ref kFLCopyImmutables is also set, immutable values are
  /// also copied, recursively.
  ///
  /// If the source Array is NULL, then NULL is returned.
  FLMutableArray FLArray_MutableCopy(
    FLArray arg0,
    FLCopyFlags arg1,
  ) {
    return _FLArray_MutableCopy(
      arg0,
      arg1.value,
    );
  }

  late final _FLArray_MutableCopyPtr =
      _lookup<ffi.NativeFunction<NativeFLArray_MutableCopy>>(
          'FLArray_MutableCopy');
  late final _FLArray_MutableCopy =
      _FLArray_MutableCopyPtr.asFunction<DartFLArray_MutableCopy>();

  /// Creates a new empty mutable Array. Its initial ref-count is 1, so a call
  /// to FLMutableArray_Release will free it.
  FLMutableArray FLMutableArray_New() {
    return _FLMutableArray_New();
  }

  late final _FLMutableArray_NewPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_New>>(
          'FLMutableArray_New');
  late final _FLMutableArray_New =
      _FLMutableArray_NewPtr.asFunction<DartFLMutableArray_New>();

  /// If the Array was created by FLArray_MutableCopy, returns the original
  /// source Array.
  FLArray FLMutableArray_GetSource(
    FLMutableArray arg0,
  ) {
    return _FLMutableArray_GetSource(
      arg0,
    );
  }

  late final _FLMutableArray_GetSourcePtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_GetSource>>(
          'FLMutableArray_GetSource');
  late final _FLMutableArray_GetSource =
      _FLMutableArray_GetSourcePtr.asFunction<DartFLMutableArray_GetSource>();

  /// Returns true if the Array has been changed from the source it was copied
  /// from.
  bool FLMutableArray_IsChanged(
    FLMutableArray arg0,
  ) {
    return _FLMutableArray_IsChanged(
      arg0,
    );
  }

  late final _FLMutableArray_IsChangedPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_IsChanged>>(
          'FLMutableArray_IsChanged');
  late final _FLMutableArray_IsChanged =
      _FLMutableArray_IsChangedPtr.asFunction<DartFLMutableArray_IsChanged>();

  /// Sets or clears the mutable Array's "changed" flag.
  void FLMutableArray_SetChanged(
    FLMutableArray arg0,
    bool changed,
  ) {
    return _FLMutableArray_SetChanged(
      arg0,
      changed,
    );
  }

  late final _FLMutableArray_SetChangedPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_SetChanged>>(
          'FLMutableArray_SetChanged');
  late final _FLMutableArray_SetChanged =
      _FLMutableArray_SetChangedPtr.asFunction<DartFLMutableArray_SetChanged>();

  /// Inserts a contiguous range of JSON `null` values into the array. @param
  /// array The array to operate on. @param firstIndex The zero-based index of
  /// the first value to be inserted. @param count The number of items to
  /// insert.
  void FLMutableArray_Insert(
    FLMutableArray array,
    int firstIndex,
    int count,
  ) {
    return _FLMutableArray_Insert(
      array,
      firstIndex,
      count,
    );
  }

  late final _FLMutableArray_InsertPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_Insert>>(
          'FLMutableArray_Insert');
  late final _FLMutableArray_Insert =
      _FLMutableArray_InsertPtr.asFunction<DartFLMutableArray_Insert>();

  /// Removes contiguous items from the array. @param array The array to operate
  /// on. @param firstIndex The zero-based index of the first item to remove.
  /// @param count The number of items to remove.
  void FLMutableArray_Remove(
    FLMutableArray array,
    int firstIndex,
    int count,
  ) {
    return _FLMutableArray_Remove(
      array,
      firstIndex,
      count,
    );
  }

  late final _FLMutableArray_RemovePtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_Remove>>(
          'FLMutableArray_Remove');
  late final _FLMutableArray_Remove =
      _FLMutableArray_RemovePtr.asFunction<DartFLMutableArray_Remove>();

  /// Changes the size of an array. If the new size is larger, the array is
  /// padded with JSON `null` values. If it's smaller, values are removed from
  /// the end.
  void FLMutableArray_Resize(
    FLMutableArray array,
    int size,
  ) {
    return _FLMutableArray_Resize(
      array,
      size,
    );
  }

  late final _FLMutableArray_ResizePtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_Resize>>(
          'FLMutableArray_Resize');
  late final _FLMutableArray_Resize =
      _FLMutableArray_ResizePtr.asFunction<DartFLMutableArray_Resize>();

  /// Convenience function for getting an array-valued property in mutable form.
  ///
  /// - If the value for the key is not an array, returns NULL.
  /// - If the value is a mutable array, returns it.
  /// - If the value is an immutable array, this function makes a mutable copy,
  ///   assigns the copy as the property value, and returns the copy.
  FLMutableArray FLMutableArray_GetMutableArray(
    FLMutableArray arg0,
    int index,
  ) {
    return _FLMutableArray_GetMutableArray(
      arg0,
      index,
    );
  }

  late final _FLMutableArray_GetMutableArrayPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_GetMutableArray>>(
          'FLMutableArray_GetMutableArray');
  late final _FLMutableArray_GetMutableArray =
      _FLMutableArray_GetMutableArrayPtr.asFunction<
          DartFLMutableArray_GetMutableArray>();

  /// Convenience function for getting an array-valued property in mutable form.
  ///
  /// - If the value for the key is not an array, returns NULL.
  /// - If the value is a mutable array, returns it.
  /// - If the value is an immutable array, this function makes a mutable copy,
  ///   assigns the copy as the property value, and returns the copy.
  FLMutableDict FLMutableArray_GetMutableDict(
    FLMutableArray arg0,
    int index,
  ) {
    return _FLMutableArray_GetMutableDict(
      arg0,
      index,
    );
  }

  late final _FLMutableArray_GetMutableDictPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_GetMutableDict>>(
          'FLMutableArray_GetMutableDict');
  late final _FLMutableArray_GetMutableDict = _FLMutableArray_GetMutableDictPtr
      .asFunction<DartFLMutableArray_GetMutableDict>();

  /// Creates a new mutable Dict that's a copy of the source Dict. Its initial
  /// ref-count is 1, so a call to FLMutableDict_Release will free it.
  ///
  /// Copying an immutable Dict is very cheap (only one small allocation.) The
  /// `deepCopy` flag is ignored.
  ///
  /// Copying a mutable Dict is cheap if it's a shallow copy, but if `deepCopy`
  /// is true, nested mutable Dicts and Arrays are also copied, recursively.
  ///
  /// If the source dict is NULL, then NULL is returned.
  FLMutableDict FLDict_MutableCopy(
    FLDict source,
    FLCopyFlags arg1,
  ) {
    return _FLDict_MutableCopy(
      source,
      arg1.value,
    );
  }

  late final _FLDict_MutableCopyPtr =
      _lookup<ffi.NativeFunction<NativeFLDict_MutableCopy>>(
          'FLDict_MutableCopy');
  late final _FLDict_MutableCopy =
      _FLDict_MutableCopyPtr.asFunction<DartFLDict_MutableCopy>();

  /// Creates a new empty mutable Dict. Its initial ref-count is 1, so a call to
  /// FLMutableDict_Release will free it.
  FLMutableDict FLMutableDict_New() {
    return _FLMutableDict_New();
  }

  late final _FLMutableDict_NewPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableDict_New>>('FLMutableDict_New');
  late final _FLMutableDict_New =
      _FLMutableDict_NewPtr.asFunction<DartFLMutableDict_New>();

  /// If the Dict was created by FLDict_MutableCopy, returns the original source
  /// Dict.
  FLDict FLMutableDict_GetSource(
    FLMutableDict arg0,
  ) {
    return _FLMutableDict_GetSource(
      arg0,
    );
  }

  late final _FLMutableDict_GetSourcePtr =
      _lookup<ffi.NativeFunction<NativeFLMutableDict_GetSource>>(
          'FLMutableDict_GetSource');
  late final _FLMutableDict_GetSource =
      _FLMutableDict_GetSourcePtr.asFunction<DartFLMutableDict_GetSource>();

  /// Returns true if the Dict has been changed from the source it was copied
  /// from.
  bool FLMutableDict_IsChanged(
    FLMutableDict arg0,
  ) {
    return _FLMutableDict_IsChanged(
      arg0,
    );
  }

  late final _FLMutableDict_IsChangedPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableDict_IsChanged>>(
          'FLMutableDict_IsChanged');
  late final _FLMutableDict_IsChanged =
      _FLMutableDict_IsChangedPtr.asFunction<DartFLMutableDict_IsChanged>();

  /// Sets or clears the mutable Dict's "changed" flag.
  void FLMutableDict_SetChanged(
    FLMutableDict arg0,
    bool arg1,
  ) {
    return _FLMutableDict_SetChanged(
      arg0,
      arg1,
    );
  }

  late final _FLMutableDict_SetChangedPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableDict_SetChanged>>(
          'FLMutableDict_SetChanged');
  late final _FLMutableDict_SetChanged =
      _FLMutableDict_SetChangedPtr.asFunction<DartFLMutableDict_SetChanged>();

  /// Removes the value for a key.
  void FLMutableDict_Remove(
    FLMutableDict arg0,
    FLString key,
  ) {
    return _FLMutableDict_Remove(
      arg0,
      key,
    );
  }

  late final _FLMutableDict_RemovePtr =
      _lookup<ffi.NativeFunction<NativeFLMutableDict_Remove>>(
          'FLMutableDict_Remove');
  late final _FLMutableDict_Remove =
      _FLMutableDict_RemovePtr.asFunction<DartFLMutableDict_Remove>();

  /// Removes all keys and values.
  void FLMutableDict_RemoveAll(
    FLMutableDict arg0,
  ) {
    return _FLMutableDict_RemoveAll(
      arg0,
    );
  }

  late final _FLMutableDict_RemoveAllPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableDict_RemoveAll>>(
          'FLMutableDict_RemoveAll');
  late final _FLMutableDict_RemoveAll =
      _FLMutableDict_RemoveAllPtr.asFunction<DartFLMutableDict_RemoveAll>();

  /// Convenience function for getting an array-valued property in mutable form.
  ///
  /// - If the value for the key is not an array, returns NULL.
  /// - If the value is a mutable array, returns it.
  /// - If the value is an immutable array, this function makes a mutable copy,
  ///   assigns the copy as the property value, and returns the copy.
  FLMutableArray FLMutableDict_GetMutableArray(
    FLMutableDict arg0,
    FLString key,
  ) {
    return _FLMutableDict_GetMutableArray(
      arg0,
      key,
    );
  }

  late final _FLMutableDict_GetMutableArrayPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableDict_GetMutableArray>>(
          'FLMutableDict_GetMutableArray');
  late final _FLMutableDict_GetMutableArray = _FLMutableDict_GetMutableArrayPtr
      .asFunction<DartFLMutableDict_GetMutableArray>();

  /// Convenience function for getting a dict-valued property in mutable form.
  ///
  /// - If the value for the key is not a dict, returns NULL.
  /// - If the value is a mutable dict, returns it.
  /// - If the value is an immutable dict, this function makes a mutable copy,
  ///   assigns the copy as the property value, and returns the copy.
  FLMutableDict FLMutableDict_GetMutableDict(
    FLMutableDict arg0,
    FLString key,
  ) {
    return _FLMutableDict_GetMutableDict(
      arg0,
      key,
    );
  }

  late final _FLMutableDict_GetMutableDictPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableDict_GetMutableDict>>(
          'FLMutableDict_GetMutableDict');
  late final _FLMutableDict_GetMutableDict = _FLMutableDict_GetMutableDictPtr
      .asFunction<DartFLMutableDict_GetMutableDict>();

  /// Allocates a string value on the heap. This is rarely needed -- usually
  /// you'd just add a string to a mutable Array or Dict directly using one of
  /// their "...SetString" or "...AppendString" methods.
  FLValue FLValue_NewString(
    FLString arg0,
  ) {
    return _FLValue_NewString(
      arg0,
    );
  }

  late final _FLValue_NewStringPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_NewString>>('FLValue_NewString');
  late final _FLValue_NewString =
      _FLValue_NewStringPtr.asFunction<DartFLValue_NewString>();

  /// Allocates a data/blob value on the heap. This is rarely needed -- usually
  /// you'd just add data to a mutable Array or Dict directly using one of their
  /// "...SetData or "...AppendData" methods.
  FLValue FLValue_NewData(
    FLSlice arg0,
  ) {
    return _FLValue_NewData(
      arg0,
    );
  }

  late final _FLValue_NewDataPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_NewData>>('FLValue_NewData');
  late final _FLValue_NewData =
      _FLValue_NewDataPtr.asFunction<DartFLValue_NewData>();

  /// Returns an \ref FLSlot that refers to the given index of the given array.
  /// You store a value to it by calling one of the nine `FLSlot_Set...`
  /// functions. \warning You should immediately store a value into the
  /// `FLSlot`. Do not keep it around; any changes to the array invalidate it.
  FLSlot FLMutableArray_Set(
    FLMutableArray arg0,
    int index,
  ) {
    return _FLMutableArray_Set(
      arg0,
      index,
    );
  }

  late final _FLMutableArray_SetPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_Set>>(
          'FLMutableArray_Set');
  late final _FLMutableArray_Set =
      _FLMutableArray_SetPtr.asFunction<DartFLMutableArray_Set>();

  /// Appends a null value to the array and returns an \ref FLSlot that refers
  /// to that position. You store a value to it by calling one of the nine
  /// `FLSlot_Set...` functions. \warning You should immediately store a value
  /// into the `FLSlot`. Do not keep it around; any changes to the array
  /// invalidate it.
  FLSlot FLMutableArray_Append(
    FLMutableArray arg0,
  ) {
    return _FLMutableArray_Append(
      arg0,
    );
  }

  late final _FLMutableArray_AppendPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableArray_Append>>(
          'FLMutableArray_Append');
  late final _FLMutableArray_Append =
      _FLMutableArray_AppendPtr.asFunction<DartFLMutableArray_Append>();

  /// Returns an \ref FLSlot that refers to the given key/value pair of the
  /// given dictionary. You store a value to it by calling one of the nine
  /// `FLSlot_Set...` functions. \warning You should immediately store a value
  /// into the `FLSlot`. Do not keep it around; any changes to the dictionary
  /// invalidate it.
  FLSlot FLMutableDict_Set(
    FLMutableDict arg0,
    FLString key,
  ) {
    return _FLMutableDict_Set(
      arg0,
      key,
    );
  }

  late final _FLMutableDict_SetPtr =
      _lookup<ffi.NativeFunction<NativeFLMutableDict_Set>>('FLMutableDict_Set');
  late final _FLMutableDict_Set =
      _FLMutableDict_SetPtr.asFunction<DartFLMutableDict_Set>();

  void FLSlot_SetNull(
    FLSlot arg0,
  ) {
    return _FLSlot_SetNull(
      arg0,
    );
  }

  late final _FLSlot_SetNullPtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetNull>>('FLSlot_SetNull');
  late final _FLSlot_SetNull =
      _FLSlot_SetNullPtr.asFunction<DartFLSlot_SetNull>();

  void FLSlot_SetBool(
    FLSlot arg0,
    bool arg1,
  ) {
    return _FLSlot_SetBool(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetBoolPtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetBool>>('FLSlot_SetBool');
  late final _FLSlot_SetBool =
      _FLSlot_SetBoolPtr.asFunction<DartFLSlot_SetBool>();

  void FLSlot_SetInt(
    FLSlot arg0,
    int arg1,
  ) {
    return _FLSlot_SetInt(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetIntPtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetInt>>('FLSlot_SetInt');
  late final _FLSlot_SetInt = _FLSlot_SetIntPtr.asFunction<DartFLSlot_SetInt>();

  void FLSlot_SetUInt(
    FLSlot arg0,
    int arg1,
  ) {
    return _FLSlot_SetUInt(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetUIntPtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetUInt>>('FLSlot_SetUInt');
  late final _FLSlot_SetUInt =
      _FLSlot_SetUIntPtr.asFunction<DartFLSlot_SetUInt>();

  void FLSlot_SetFloat(
    FLSlot arg0,
    double arg1,
  ) {
    return _FLSlot_SetFloat(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetFloatPtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetFloat>>('FLSlot_SetFloat');
  late final _FLSlot_SetFloat =
      _FLSlot_SetFloatPtr.asFunction<DartFLSlot_SetFloat>();

  void FLSlot_SetDouble(
    FLSlot arg0,
    double arg1,
  ) {
    return _FLSlot_SetDouble(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetDoublePtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetDouble>>('FLSlot_SetDouble');
  late final _FLSlot_SetDouble =
      _FLSlot_SetDoublePtr.asFunction<DartFLSlot_SetDouble>();

  void FLSlot_SetString(
    FLSlot arg0,
    FLString arg1,
  ) {
    return _FLSlot_SetString(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetStringPtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetString>>('FLSlot_SetString');
  late final _FLSlot_SetString =
      _FLSlot_SetStringPtr.asFunction<DartFLSlot_SetString>();

  void FLSlot_SetData(
    FLSlot arg0,
    FLSlice arg1,
  ) {
    return _FLSlot_SetData(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetDataPtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetData>>('FLSlot_SetData');
  late final _FLSlot_SetData =
      _FLSlot_SetDataPtr.asFunction<DartFLSlot_SetData>();

  void FLSlot_SetValue(
    FLSlot arg0,
    FLValue arg1,
  ) {
    return _FLSlot_SetValue(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetValuePtr =
      _lookup<ffi.NativeFunction<NativeFLSlot_SetValue>>('FLSlot_SetValue');
  late final _FLSlot_SetValue =
      _FLSlot_SetValuePtr.asFunction<DartFLSlot_SetValue>();

  /// Returns JSON that encodes the changes to turn the value `old` into `nuu`.
  /// (The format is documented in Fleece.md, but you should treat it as a black
  /// box.) @param old A value that's typically the old/original state of some
  /// data. @param nuu A value that's typically the new/changed state of the
  /// `old` data. @return JSON data representing the changes from `old` to
  /// `nuu`, or NULL on (extremely unlikely) failure.
  FLSliceResult FLCreateJSONDelta(
    FLValue old,
    FLValue nuu,
  ) {
    return _FLCreateJSONDelta(
      old,
      nuu,
    );
  }

  late final _FLCreateJSONDeltaPtr =
      _lookup<ffi.NativeFunction<NativeFLCreateJSONDelta>>('FLCreateJSONDelta');
  late final _FLCreateJSONDelta =
      _FLCreateJSONDeltaPtr.asFunction<DartFLCreateJSONDelta>();

  /// Writes JSON that describes the changes to turn the value `old` into `nuu`.
  /// (The format is documented in Fleece.md, but you should treat it as a black
  /// box.) @param old A value that's typically the old/original state of some
  /// data. @param nuu A value that's typically the new/changed state of the
  /// `old` data. @param jsonEncoder An encoder to write the JSON to. Must have
  /// been created using `FLEncoder_NewWithOptions`, with JSON or JSON5 format.
  /// @return True on success, false on (extremely unlikely) failure.
  bool FLEncodeJSONDelta(
    FLValue old,
    FLValue nuu,
    FLEncoder jsonEncoder,
  ) {
    return _FLEncodeJSONDelta(
      old,
      nuu,
      jsonEncoder,
    );
  }

  late final _FLEncodeJSONDeltaPtr =
      _lookup<ffi.NativeFunction<NativeFLEncodeJSONDelta>>('FLEncodeJSONDelta');
  late final _FLEncodeJSONDelta =
      _FLEncodeJSONDeltaPtr.asFunction<DartFLEncodeJSONDelta>();

  /// Applies the JSON data created by `CreateJSONDelta` to the value `old`,
  /// which must be equal to the `old` value originally passed to
  /// `FLCreateJSONDelta`, and returns a Fleece document equal to the original
  /// `nuu` value. @param old A value that's typically the old/original state of
  /// some data. This must be equal to the `old` value used when creating the
  /// `jsonDelta`. @param jsonDelta A JSON-encoded delta created by
  /// `FLCreateJSONDelta` or `FLEncodeJSONDelta`. @param outError On failure,
  /// error information will be stored where this points, if non-null. @return
  /// The corresponding `nuu` value, encoded as Fleece, or null if an error
  /// occurred.
  FLSliceResult FLApplyJSONDelta(
    FLValue old,
    FLSlice jsonDelta,
    ffi.Pointer<ffi.UnsignedInt> outError,
  ) {
    return _FLApplyJSONDelta(
      old,
      jsonDelta,
      outError,
    );
  }

  late final _FLApplyJSONDeltaPtr =
      _lookup<ffi.NativeFunction<NativeFLApplyJSONDelta>>('FLApplyJSONDelta');
  late final _FLApplyJSONDelta =
      _FLApplyJSONDeltaPtr.asFunction<DartFLApplyJSONDelta>();

  /// Applies the (parsed) JSON data created by `CreateJSONDelta` to the value
  /// `old`, which must be equal to the `old` value originally passed to
  /// `FLCreateJSONDelta`, and writes the corresponding `nuu` value to the
  /// encoder. @param old A value that's typically the old/original state of
  /// some data. This must be equal to the `old` value used when creating the
  /// `jsonDelta`. @param jsonDelta A JSON-encoded delta created by
  /// `FLCreateJSONDelta` or `FLEncodeJSONDelta`. @param encoder A Fleece
  /// encoder to write the decoded `nuu` value to. (JSON encoding is not
  /// supported.) @return True on success, false on error; call
  /// `FLEncoder_GetError` for details.
  bool FLEncodeApplyingJSONDelta(
    FLValue old,
    FLSlice jsonDelta,
    FLEncoder encoder,
  ) {
    return _FLEncodeApplyingJSONDelta(
      old,
      jsonDelta,
      encoder,
    );
  }

  late final _FLEncodeApplyingJSONDeltaPtr =
      _lookup<ffi.NativeFunction<NativeFLEncodeApplyingJSONDelta>>(
          'FLEncodeApplyingJSONDelta');
  late final _FLEncodeApplyingJSONDelta =
      _FLEncodeApplyingJSONDeltaPtr.asFunction<DartFLEncodeApplyingJSONDelta>();

  /// Creates a new empty FLSharedKeys object, which must eventually be
  /// released.
  FLSharedKeys FLSharedKeys_New() {
    return _FLSharedKeys_New();
  }

  late final _FLSharedKeys_NewPtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_New>>('FLSharedKeys_New');
  late final _FLSharedKeys_New =
      _FLSharedKeys_NewPtr.asFunction<DartFLSharedKeys_New>();

  FLSharedKeys FLSharedKeys_NewWithRead(
    FLSharedKeysReadCallback arg0,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _FLSharedKeys_NewWithRead(
      arg0,
      context,
    );
  }

  late final _FLSharedKeys_NewWithReadPtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_NewWithRead>>(
          'FLSharedKeys_NewWithRead');
  late final _FLSharedKeys_NewWithRead =
      _FLSharedKeys_NewWithReadPtr.asFunction<DartFLSharedKeys_NewWithRead>();

  /// Returns a data blob containing the current state (all the keys and their
  /// integers.)
  FLSliceResult FLSharedKeys_GetStateData(
    FLSharedKeys arg0,
  ) {
    return _FLSharedKeys_GetStateData(
      arg0,
    );
  }

  late final _FLSharedKeys_GetStateDataPtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_GetStateData>>(
          'FLSharedKeys_GetStateData');
  late final _FLSharedKeys_GetStateData =
      _FLSharedKeys_GetStateDataPtr.asFunction<DartFLSharedKeys_GetStateData>();

  /// Updates an FLSharedKeys with saved state data created by \ref
  /// FLSharedKeys_GetStateData.
  bool FLSharedKeys_LoadStateData(
    FLSharedKeys arg0,
    FLSlice arg1,
  ) {
    return _FLSharedKeys_LoadStateData(
      arg0,
      arg1,
    );
  }

  late final _FLSharedKeys_LoadStateDataPtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_LoadStateData>>(
          'FLSharedKeys_LoadStateData');
  late final _FLSharedKeys_LoadStateData = _FLSharedKeys_LoadStateDataPtr
      .asFunction<DartFLSharedKeys_LoadStateData>();

  /// Writes the current state to a Fleece encoder as a single value, which can
  /// later be decoded and passed to \ref FLSharedKeys_LoadState.
  void FLSharedKeys_WriteState(
    FLSharedKeys arg0,
    FLEncoder arg1,
  ) {
    return _FLSharedKeys_WriteState(
      arg0,
      arg1,
    );
  }

  late final _FLSharedKeys_WriteStatePtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_WriteState>>(
          'FLSharedKeys_WriteState');
  late final _FLSharedKeys_WriteState =
      _FLSharedKeys_WriteStatePtr.asFunction<DartFLSharedKeys_WriteState>();

  /// Updates an FLSharedKeys object with saved state, a Fleece value previously
  /// written by \ref FLSharedKeys_WriteState.
  bool FLSharedKeys_LoadState(
    FLSharedKeys arg0,
    FLValue arg1,
  ) {
    return _FLSharedKeys_LoadState(
      arg0,
      arg1,
    );
  }

  late final _FLSharedKeys_LoadStatePtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_LoadState>>(
          'FLSharedKeys_LoadState');
  late final _FLSharedKeys_LoadState =
      _FLSharedKeys_LoadStatePtr.asFunction<DartFLSharedKeys_LoadState>();

  /// Maps a key string to a number in the range [0...2047], or returns -1 if it
  /// isn't mapped. If the key doesn't already have a mapping, and the `add`
  /// flag is true, a new mapping is assigned and returned. However, the `add`
  /// flag has no effect if the key is unmappable (is longer than 16 bytes or
  /// contains non-identifier characters), or if all available integers have
  /// been assigned.
  int FLSharedKeys_Encode(
    FLSharedKeys arg0,
    FLString arg1,
    bool add,
  ) {
    return _FLSharedKeys_Encode(
      arg0,
      arg1,
      add,
    );
  }

  late final _FLSharedKeys_EncodePtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_Encode>>(
          'FLSharedKeys_Encode');
  late final _FLSharedKeys_Encode =
      _FLSharedKeys_EncodePtr.asFunction<DartFLSharedKeys_Encode>();

  /// Returns the key string that maps to the given integer `key`, else NULL.
  FLString FLSharedKeys_Decode(
    FLSharedKeys arg0,
    int key,
  ) {
    return _FLSharedKeys_Decode(
      arg0,
      key,
    );
  }

  late final _FLSharedKeys_DecodePtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_Decode>>(
          'FLSharedKeys_Decode');
  late final _FLSharedKeys_Decode =
      _FLSharedKeys_DecodePtr.asFunction<DartFLSharedKeys_Decode>();

  /// Returns the number of keys in the mapping. This number increases whenever
  /// the mapping is changed, and never decreases.
  int FLSharedKeys_Count(
    FLSharedKeys arg0,
  ) {
    return _FLSharedKeys_Count(
      arg0,
    );
  }

  late final _FLSharedKeys_CountPtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_Count>>(
          'FLSharedKeys_Count');
  late final _FLSharedKeys_Count =
      _FLSharedKeys_CountPtr.asFunction<DartFLSharedKeys_Count>();

  /// Reverts an FLSharedKeys by "forgetting" any keys added since it had the
  /// count `oldCount`.
  void FLSharedKeys_RevertToCount(
    FLSharedKeys arg0,
    int oldCount,
  ) {
    return _FLSharedKeys_RevertToCount(
      arg0,
      oldCount,
    );
  }

  late final _FLSharedKeys_RevertToCountPtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_RevertToCount>>(
          'FLSharedKeys_RevertToCount');
  late final _FLSharedKeys_RevertToCount = _FLSharedKeys_RevertToCountPtr
      .asFunction<DartFLSharedKeys_RevertToCount>();

  /// Increments the reference count of an FLSharedKeys.
  FLSharedKeys FLSharedKeys_Retain(
    FLSharedKeys arg0,
  ) {
    return _FLSharedKeys_Retain(
      arg0,
    );
  }

  late final _FLSharedKeys_RetainPtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_Retain>>(
          'FLSharedKeys_Retain');
  late final _FLSharedKeys_Retain =
      _FLSharedKeys_RetainPtr.asFunction<DartFLSharedKeys_Retain>();

  /// Decrements the reference count of an FLSharedKeys, freeing it when it
  /// reaches zero.
  void FLSharedKeys_Release(
    FLSharedKeys arg0,
  ) {
    return _FLSharedKeys_Release(
      arg0,
    );
  }

  late final _FLSharedKeys_ReleasePtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeys_Release>>(
          'FLSharedKeys_Release');
  late final _FLSharedKeys_Release =
      _FLSharedKeys_ReleasePtr.asFunction<DartFLSharedKeys_Release>();

  /// Registers a range of memory containing Fleece data that uses the given
  /// shared keys. This allows Dict accessors to look up the values of shared
  /// keys.
  FLSharedKeyScope FLSharedKeyScope_WithRange(
    FLSlice range,
    FLSharedKeys arg1,
  ) {
    return _FLSharedKeyScope_WithRange(
      range,
      arg1,
    );
  }

  late final _FLSharedKeyScope_WithRangePtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeyScope_WithRange>>(
          'FLSharedKeyScope_WithRange');
  late final _FLSharedKeyScope_WithRange = _FLSharedKeyScope_WithRangePtr
      .asFunction<DartFLSharedKeyScope_WithRange>();

  /// Unregisters a scope created by \ref FLSharedKeyScope_WithRange.
  void FLSharedKeyScope_Free(
    FLSharedKeyScope arg0,
  ) {
    return _FLSharedKeyScope_Free(
      arg0,
    );
  }

  late final _FLSharedKeyScope_FreePtr =
      _lookup<ffi.NativeFunction<NativeFLSharedKeyScope_Free>>(
          'FLSharedKeyScope_Free');
  late final _FLSharedKeyScope_Free =
      _FLSharedKeyScope_FreePtr.asFunction<DartFLSharedKeyScope_Free>();

  /// Returns a pointer to the root value in the encoded data, or NULL if
  /// validation failed. You should generally use an \ref FLDoc instead; it's
  /// safer. Here's why:
  ///
  /// On the plus side, \ref FLValue*FromData is \_extremely* fast: it allocates
  /// no memory, only scans enough of the data to ensure it's valid (and if
  /// `trust` is set to `kFLTrusted`, it doesn't even do that.)
  ///
  /// But it's potentially _very_ dangerous: the FLValue, and all values found
  /// through it, are only valid as long as the input `data` remains intact and
  /// unchanged. If you violate that, the values will be pointing to garbage and
  /// Bad Things will happen when you access them...
  FLValue FLValue_FromData(
    FLSlice data,
    FLTrust trust,
  ) {
    return _FLValue_FromData(
      data,
      trust.value,
    );
  }

  late final _FLValue_FromDataPtr =
      _lookup<ffi.NativeFunction<NativeFLValue_FromData>>('FLValue_FromData');
  late final _FLValue_FromData =
      _FLValue_FromDataPtr.asFunction<DartFLValue_FromData>();

  /// Converts valid JSON5 <https://json5.org> to JSON. Among other things, it
  /// converts single quotes to double, adds missing quotes around dictionary
  /// keys, removes trailing commas, and removes comments. @note If given
  /// invalid JSON5, it will _usually_ return an error, but may just ouput
  /// comparably invalid JSON, in which case the caller's subsequent JSON
  /// parsing will detect the error. The types of errors it overlooks tend to be
  /// subtleties of string or number encoding. @param json5 The JSON5 to parse
  /// @param outErrorMessage On failure, the error message will be stored here
  /// (if not NULL.) As this is a \ref FLStringResult, you will be responsible
  /// for freeing it. @param outErrorPos On a parse error, the byte offset in
  /// the input where the error occurred will be stored here (if it's not NULL.)
  /// @param outError On failure, the error code will be stored here (if it's
  /// not NULL.) @return The converted JSON.
  FLStringResult FLJSON5_ToJSON(
    FLString json5,
    ffi.Pointer<FLStringResult> outErrorMessage,
    ffi.Pointer<ffi.Size> outErrorPos,
    ffi.Pointer<ffi.UnsignedInt> outError,
  ) {
    return _FLJSON5_ToJSON(
      json5,
      outErrorMessage,
      outErrorPos,
      outError,
    );
  }

  late final _FLJSON5_ToJSONPtr =
      _lookup<ffi.NativeFunction<NativeFLJSON5_ToJSON>>('FLJSON5_ToJSON');
  late final _FLJSON5_ToJSON =
      _FLJSON5_ToJSONPtr.asFunction<DartFLJSON5_ToJSON>();

  /// Directly converts JSON data to Fleece-encoded data. Not commonly needed.
  /// Prefer \ref FLDoc_FromJSON instead.
  FLSliceResult FLData_ConvertJSON(
    FLSlice json,
    ffi.Pointer<ffi.UnsignedInt> outError,
  ) {
    return _FLData_ConvertJSON(
      json,
      outError,
    );
  }

  late final _FLData_ConvertJSONPtr =
      _lookup<ffi.NativeFunction<NativeFLData_ConvertJSON>>(
          'FLData_ConvertJSON');
  late final _FLData_ConvertJSON =
      _FLData_ConvertJSONPtr.asFunction<DartFLData_ConvertJSON>();

  /// Tells the encoder to logically append to the given Fleece document, rather
  /// than making a standalone document. Any calls to FLEncoder*WriteValue()
  /// where the value points inside the base data will write a pointer back to
  /// the original value. The resulting data returned by FLEncoder_FinishDoc()
  /// will \_NOT* be standalone; it can only be used by first appending it to
  /// the base data. @param e The FLEncoder affected. @param base The base
  /// document to create an amendment of. @param reuseStrings If true, then
  /// writing a string that already exists in the base will just create a
  /// pointer back to the original. But the encoder has to scan the base for
  /// strings first. @param externPointers If true, pointers into the base will
  /// be marked with the `extern` flag. This allows them to be resolved using
  /// the `FLResolver_Begin` function, so that when the delta is used the base
  /// document can be anywhere in memory, not just immediately preceding the
  /// delta document.
  void FLEncoder_Amend(
    FLEncoder e,
    FLSlice base,
    bool reuseStrings,
    bool externPointers,
  ) {
    return _FLEncoder_Amend(
      e,
      base,
      reuseStrings,
      externPointers,
    );
  }

  late final _FLEncoder_AmendPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_Amend>>('FLEncoder_Amend');
  late final _FLEncoder_Amend =
      _FLEncoder_AmendPtr.asFunction<DartFLEncoder_Amend>();

  /// Returns the `base` value passed to FLEncoder_Amend.
  FLSlice FLEncoder_GetBase(
    FLEncoder arg0,
  ) {
    return _FLEncoder_GetBase(
      arg0,
    );
  }

  late final _FLEncoder_GetBasePtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_GetBase>>('FLEncoder_GetBase');
  late final _FLEncoder_GetBase =
      _FLEncoder_GetBasePtr.asFunction<DartFLEncoder_GetBase>();

  /// Tells the encoder not to write the two-byte Fleece trailer at the end of
  /// the data. This is only useful for certain special purposes.
  void FLEncoder_SuppressTrailer(
    FLEncoder arg0,
  ) {
    return _FLEncoder_SuppressTrailer(
      arg0,
    );
  }

  late final _FLEncoder_SuppressTrailerPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_SuppressTrailer>>(
          'FLEncoder_SuppressTrailer');
  late final _FLEncoder_SuppressTrailer =
      _FLEncoder_SuppressTrailerPtr.asFunction<DartFLEncoder_SuppressTrailer>();

  /// Returns the byte offset in the encoded data where the next value will be
  /// written. (Due to internal buffering, this is not the same as
  /// FLEncoder_BytesWritten.)
  int FLEncoder_GetNextWritePos(
    FLEncoder arg0,
  ) {
    return _FLEncoder_GetNextWritePos(
      arg0,
    );
  }

  late final _FLEncoder_GetNextWritePosPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_GetNextWritePos>>(
          'FLEncoder_GetNextWritePos');
  late final _FLEncoder_GetNextWritePos =
      _FLEncoder_GetNextWritePosPtr.asFunction<DartFLEncoder_GetNextWritePos>();

  /// Returns an opaque reference to the last complete value written to the
  /// encoder, if possible. Fails (returning 0) if nothing has been written, or
  /// if the value is inline and can't be referenced this way -- that only
  /// happens with small scalars or empty collections.
  int FLEncoder_LastValueWritten(
    FLEncoder arg0,
  ) {
    return _FLEncoder_LastValueWritten(
      arg0,
    );
  }

  late final _FLEncoder_LastValueWrittenPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_LastValueWritten>>(
          'FLEncoder_LastValueWritten');
  late final _FLEncoder_LastValueWritten = _FLEncoder_LastValueWrittenPtr
      .asFunction<DartFLEncoder_LastValueWritten>();

  /// Writes another reference (a "pointer") to an already-written value, given
  /// a reference previously returned from \ref FLEncoder_LastValueWritten. The
  /// effect is exactly the same as if you wrote the entire value again, except
  /// that the size of the encoded data only grows by 4 bytes.
  void FLEncoder_WriteValueAgain(
    FLEncoder arg0,
    int preWrittenValue,
  ) {
    return _FLEncoder_WriteValueAgain(
      arg0,
      preWrittenValue,
    );
  }

  late final _FLEncoder_WriteValueAgainPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_WriteValueAgain>>(
          'FLEncoder_WriteValueAgain');
  late final _FLEncoder_WriteValueAgain =
      _FLEncoder_WriteValueAgainPtr.asFunction<DartFLEncoder_WriteValueAgain>();

  /// Returns the data written so far as a standalone Fleece document, whose
  /// root is the last value written. You can continue writing, and the final
  /// output returned by \ref FLEncoder_Finish will consist of everything after
  /// this point. That second part can be used in the future by loading it as an
  /// `FLDoc` with the first part as its `extern` reference.
  FLSliceResult FLEncoder_Snip(
    FLEncoder arg0,
  ) {
    return _FLEncoder_Snip(
      arg0,
    );
  }

  late final _FLEncoder_SnipPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_Snip>>('FLEncoder_Snip');
  late final _FLEncoder_Snip =
      _FLEncoder_SnipPtr.asFunction<DartFLEncoder_Snip>();

  /// Finishes encoding the current item, and returns its offset in the output
  /// data.
  int FLEncoder_FinishItem(
    FLEncoder arg0,
  ) {
    return _FLEncoder_FinishItem(
      arg0,
    );
  }

  late final _FLEncoder_FinishItemPtr =
      _lookup<ffi.NativeFunction<NativeFLEncoder_FinishItem>>(
          'FLEncoder_FinishItem');
  late final _FLEncoder_FinishItem =
      _FLEncoder_FinishItemPtr.asFunction<DartFLEncoder_FinishItem>();

  /// In a JSON encoder, adds a newline ('\n') and prepares to start encoding
  /// another top-level object. The encoder MUST be not be within an array or
  /// dict. Has no effect in a Fleece encoder.
  void FLJSONEncoder_NextDocument(
    FLEncoder arg0,
  ) {
    return _FLJSONEncoder_NextDocument(
      arg0,
    );
  }

  late final _FLJSONEncoder_NextDocumentPtr =
      _lookup<ffi.NativeFunction<NativeFLJSONEncoder_NextDocument>>(
          'FLJSONEncoder_NextDocument');
  late final _FLJSONEncoder_NextDocument = _FLJSONEncoder_NextDocumentPtr
      .asFunction<DartFLJSONEncoder_NextDocument>();

  /// Debugging function that returns a C string of JSON. Does not free the
  /// string's memory!
  ffi.Pointer<ffi.Char> FLDump(
    FLValue arg0,
  ) {
    return _FLDump(
      arg0,
    );
  }

  late final _FLDumpPtr = _lookup<ffi.NativeFunction<NativeFLDump>>('FLDump');
  late final _FLDump = _FLDumpPtr.asFunction<DartFLDump>();

  /// Debugging function that parses Fleece data and returns a C string of JSON.
  /// Does not free the string's memory!
  ffi.Pointer<ffi.Char> FLDumpData(
    FLSlice data,
  ) {
    return _FLDumpData(
      data,
    );
  }

  late final _FLDumpDataPtr =
      _lookup<ffi.NativeFunction<NativeFLDumpData>>('FLDumpData');
  late final _FLDumpData = _FLDumpDataPtr.asFunction<DartFLDumpData>();

  /// Produces a human-readable dump of Fleece-encoded data. This is only useful
  /// if you already know, or want to learn, the encoding format.
  FLStringResult FLData_Dump(
    FLSlice data,
  ) {
    return _FLData_Dump(
      data,
    );
  }

  late final _FLData_DumpPtr =
      _lookup<ffi.NativeFunction<NativeFLData_Dump>>('FLData_Dump');
  late final _FLData_Dump = _FLData_DumpPtr.asFunction<DartFLData_Dump>();

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final cblite _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<NativeCBL_Release>> get CBL_Release =>
      _library._CBL_ReleasePtr;
  ffi.Pointer<ffi.NativeFunction<NativeCBLBlobReader_Close>>
      get CBLBlobReader_Close => _library._CBLBlobReader_ClosePtr;
  ffi.Pointer<ffi.NativeFunction<NativeFLDoc_Release>> get FLDoc_Release =>
      _library._FLDoc_ReleasePtr;
  ffi.Pointer<ffi.NativeFunction<NativeFLEncoder_Free>> get FLEncoder_Free =>
      _library._FLEncoder_FreePtr;
  ffi.Pointer<ffi.NativeFunction<NativeFLValue_Release>> get FLValue_Release =>
      _library._FLValue_ReleasePtr;
  ffi.Pointer<ffi.NativeFunction<NativeFLSharedKeys_Release>>
      get FLSharedKeys_Release => _library._FLSharedKeys_ReleasePtr;
}

/// Error domains, serving as namespaces for numeric error codes.
typedef CBLErrorDomain = ffi.Uint8;
typedef DartCBLErrorDomain = int;

/// Couchbase Lite error codes, in the CBLDomain.
typedef CBLErrorCode = ffi.Int32;
typedef DartCBLErrorCode = int;

/// Network error codes, in the CBLNetworkDomain.
typedef CBLNetworkErrorCode = ffi.Int32;
typedef DartCBLNetworkErrorCode = int;

/// A struct holding information about an error. It's declared on the stack by a
/// caller, and its address is passed to an API function. If the function's
/// return value indicates that there was an error (usually by returning NULL or
/// false), then the CBLError will have been filled in with the details.
final class CBLError extends ffi.Struct {
  /// < Domain of errors; a namespace for the `code`.
  @CBLErrorDomain()
  external int domain;

  /// < Error code, specific to the domain. 0 always means no error.
  @ffi.Int()
  external int code;

  @ffi.UnsignedInt()
  external int internal_info;
}

/// A heap-allocated block of memory returned from an API call. The caller takes
/// ownership, and must call \ref FLSliceResult_Release when done with it.
/// \warning The contents of the block must not be modified, since others may be
/// using it. \note This is equivalent to the C++ class `alloc_slice`. In C++
/// the easiest way to deal with a `FLSliceResult` return value is to construct
/// an `alloc_slice` from it, which will adopt the reference, and release it in
/// its destructor. For example: `alloc_slice foo( CopyFoo() );`
final class FLSliceResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> buf;

  @ffi.Size()
  external int size;
}

typedef NativeCBLError_Message = FLSliceResult Function(
    ffi.Pointer<CBLError> outError);
typedef DartCBLError_Message = FLSliceResult Function(
    ffi.Pointer<CBLError> outError);

/// A date/time representation used for document expiration (and in date/time
/// queries.) Measured in milliseconds since the Unix epoch (1/1/1970, midnight
/// UTC.)
typedef CBLTimestamp = ffi.Int64;
typedef DartCBLTimestamp = int;
typedef NativeCBL_Now = CBLTimestamp Function();
typedef DartCBL_Now = int Function();

final class CBLRefCounted extends ffi.Opaque {}

typedef NativeCBL_Retain = ffi.Pointer<CBLRefCounted> Function(
    ffi.Pointer<CBLRefCounted> arg0);
typedef DartCBL_Retain = ffi.Pointer<CBLRefCounted> Function(
    ffi.Pointer<CBLRefCounted> arg0);
typedef NativeCBL_Release = ffi.Void Function(ffi.Pointer<CBLRefCounted> arg0);
typedef DartCBL_Release = void Function(ffi.Pointer<CBLRefCounted> arg0);
typedef NativeCBL_InstanceCount = ffi.UnsignedInt Function();
typedef DartCBL_InstanceCount = int Function();
typedef NativeCBL_DumpInstances = ffi.Void Function();
typedef DartCBL_DumpInstances = void Function();

final class CBLDatabase extends ffi.Opaque {}

final class CBLScope extends ffi.Opaque {}

final class CBLCollection extends ffi.Opaque {}

final class CBLDocument extends ffi.Opaque {}

final class CBLBlob extends ffi.Opaque {}

final class CBLQuery extends ffi.Opaque {}

final class CBLResultSet extends ffi.Opaque {}

final class CBLReplicator extends ffi.Opaque {}

final class CBLEncryptable extends ffi.Opaque {}

final class CBLListenerToken extends ffi.Opaque {}

typedef NativeCBLListener_Remove = ffi.Void Function(
    ffi.Pointer<CBLListenerToken> arg0);
typedef DartCBLListener_Remove = void Function(
    ffi.Pointer<CBLListenerToken> arg0);

/// A simple reference to a block of memory. Does not imply ownership. (This is
/// equivalent to the C++ class `slice`.)
final class FLSlice extends ffi.Struct {
  external ffi.Pointer<ffi.Void> buf;

  @ffi.Size()
  external int size;
}

final class _FLDict extends ffi.Opaque {}

typedef FLDict = ffi.Pointer<_FLDict>;
typedef NativeFLDict_IsBlob = ffi.Bool Function(FLDict arg0);
typedef DartFLDict_IsBlob = bool Function(FLDict arg0);
typedef NativeFLDict_GetBlob = ffi.Pointer<CBLBlob> Function(FLDict blobDict);
typedef DartFLDict_GetBlob = ffi.Pointer<CBLBlob> Function(FLDict blobDict);
typedef NativeCBLBlob_Length = ffi.Uint64 Function(ffi.Pointer<CBLBlob> arg0);
typedef DartCBLBlob_Length = int Function(ffi.Pointer<CBLBlob> arg0);
typedef FLString = FLSlice;
typedef NativeCBLBlob_ContentType = FLString Function(
    ffi.Pointer<CBLBlob> arg0);
typedef DartCBLBlob_ContentType = FLString Function(ffi.Pointer<CBLBlob> arg0);
typedef NativeCBLBlob_Digest = FLString Function(ffi.Pointer<CBLBlob> arg0);
typedef DartCBLBlob_Digest = FLString Function(ffi.Pointer<CBLBlob> arg0);
typedef NativeCBLBlob_Properties = FLDict Function(ffi.Pointer<CBLBlob> arg0);
typedef DartCBLBlob_Properties = FLDict Function(ffi.Pointer<CBLBlob> arg0);
typedef FLStringResult = FLSliceResult;
typedef NativeCBLBlob_CreateJSON = FLStringResult Function(
    ffi.Pointer<CBLBlob> blob);
typedef DartCBLBlob_CreateJSON = FLStringResult Function(
    ffi.Pointer<CBLBlob> blob);
typedef NativeCBLBlob_Content = FLSliceResult Function(
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLError> outError);
typedef DartCBLBlob_Content = FLSliceResult Function(
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLError> outError);

final class CBLBlobReadStream extends ffi.Opaque {}

typedef NativeCBLBlob_OpenContentStream = ffi.Pointer<CBLBlobReadStream>
    Function(ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLError> arg1);
typedef DartCBLBlob_OpenContentStream = ffi.Pointer<CBLBlobReadStream> Function(
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLError> arg1);
typedef NativeCBLBlobReader_Read = ffi.Int Function(
    ffi.Pointer<CBLBlobReadStream> stream,
    ffi.Pointer<ffi.Void> dst,
    ffi.Size maxLength,
    ffi.Pointer<CBLError> outError);
typedef DartCBLBlobReader_Read = int Function(
    ffi.Pointer<CBLBlobReadStream> stream,
    ffi.Pointer<ffi.Void> dst,
    int maxLength,
    ffi.Pointer<CBLError> outError);

/// Defines the interpretation of `offset` in \ref CBLBlobReader_Seek.
typedef CBLSeekBase = ffi.Uint8;
typedef DartCBLSeekBase = int;
typedef NativeCBLBlobReader_Seek = ffi.Int64 Function(
    ffi.Pointer<CBLBlobReadStream> stream,
    ffi.Int64 offset,
    CBLSeekBase base,
    ffi.Pointer<CBLError> outError);
typedef DartCBLBlobReader_Seek = int Function(
    ffi.Pointer<CBLBlobReadStream> stream,
    int offset,
    int base,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLBlobReader_Position = ffi.Uint64 Function(
    ffi.Pointer<CBLBlobReadStream> stream);
typedef DartCBLBlobReader_Position = int Function(
    ffi.Pointer<CBLBlobReadStream> stream);
typedef NativeCBLBlobReader_Close = ffi.Void Function(
    ffi.Pointer<CBLBlobReadStream> arg0);
typedef DartCBLBlobReader_Close = void Function(
    ffi.Pointer<CBLBlobReadStream> arg0);
typedef NativeCBLBlob_Equals = ffi.Bool Function(
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLBlob> anotherBlob);
typedef DartCBLBlob_Equals = bool Function(
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLBlob> anotherBlob);
typedef NativeCBLBlob_CreateWithData = ffi.Pointer<CBLBlob> Function(
    FLString contentType, FLSlice contents);
typedef DartCBLBlob_CreateWithData = ffi.Pointer<CBLBlob> Function(
    FLString contentType, FLSlice contents);

final class CBLBlobWriteStream extends ffi.Opaque {}

typedef NativeCBLBlobWriter_Create = ffi.Pointer<CBLBlobWriteStream> Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> arg1);
typedef DartCBLBlobWriter_Create = ffi.Pointer<CBLBlobWriteStream> Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> arg1);
typedef NativeCBLBlobWriter_Close = ffi.Void Function(
    ffi.Pointer<CBLBlobWriteStream> arg0);
typedef DartCBLBlobWriter_Close = void Function(
    ffi.Pointer<CBLBlobWriteStream> arg0);
typedef NativeCBLBlobWriter_Write = ffi.Bool Function(
    ffi.Pointer<CBLBlobWriteStream> writer,
    ffi.Pointer<ffi.Void> data,
    ffi.Size length,
    ffi.Pointer<CBLError> outError);
typedef DartCBLBlobWriter_Write = bool Function(
    ffi.Pointer<CBLBlobWriteStream> writer,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLBlob_CreateWithStream = ffi.Pointer<CBLBlob> Function(
    FLString contentType, ffi.Pointer<CBLBlobWriteStream> writer);
typedef DartCBLBlob_CreateWithStream = ffi.Pointer<CBLBlob> Function(
    FLString contentType, ffi.Pointer<CBLBlobWriteStream> writer);

final class _FLSlot extends ffi.Opaque {}

typedef FLSlot = ffi.Pointer<_FLSlot>;
typedef NativeFLSlot_SetBlob = ffi.Void Function(
    FLSlot slot, ffi.Pointer<CBLBlob> blob);
typedef DartFLSlot_SetBlob = void Function(
    FLSlot slot, ffi.Pointer<CBLBlob> blob);
typedef NativeCBLDatabase_GetBlob = ffi.Pointer<CBLBlob> Function(
    ffi.Pointer<CBLDatabase> db,
    FLDict properties,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_GetBlob = ffi.Pointer<CBLBlob> Function(
    ffi.Pointer<CBLDatabase> db,
    FLDict properties,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_SaveBlob = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLBlob> blob,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_SaveBlob = bool Function(ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLBlob> blob, ffi.Pointer<CBLError> outError);

/// Conflict-handling options when saving or deleting a document.
typedef CBLConcurrencyControl = ffi.Uint8;
typedef DartCBLConcurrencyControl = int;
typedef CBLConflictHandlerFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDocument> documentBeingSaved,
    ffi.Pointer<CBLDocument> conflictingDocument);
typedef DartCBLConflictHandlerFunction = bool Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDocument> documentBeingSaved,
    ffi.Pointer<CBLDocument> conflictingDocument);

/// Custom conflict handler for use when saving or deleting a document. This
/// handler is called if the save would cause a conflict, i.e. if the document
/// in the database has been updated (probably by a pull replicator, or by
/// application code on another thread) since it was loaded into the CBLDocument
/// being saved. @param context The value of the \p context parameter you passed
/// to \ref CBLDatabase_SaveDocumentWithConflictHandler. @param
/// documentBeingSaved The document being saved (same as the parameter you
/// passed to \ref CBLDatabase_SaveDocumentWithConflictHandler.) The callback
/// may modify this document's properties as necessary to resolve the conflict.
/// @param conflictingDocument The revision of the document currently in the
/// database, which has been changed since \p documentBeingSaved was loaded. May
/// be NULL, meaning that the document has been deleted. @return True to save
/// the document, false to abort the save.
typedef CBLConflictHandler
    = ffi.Pointer<ffi.NativeFunction<CBLConflictHandlerFunction>>;
typedef NativeCBLDatabase_GetDocument = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_GetDocument = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_SaveDocument = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_SaveDocument = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_SaveDocumentWithConcurrencyControl
    = ffi.Bool Function(
        ffi.Pointer<CBLDatabase> db,
        ffi.Pointer<CBLDocument> doc,
        CBLConcurrencyControl concurrency,
        ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_SaveDocumentWithConcurrencyControl = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    int concurrency,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_SaveDocumentWithConflictHandler = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    CBLConflictHandler conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_SaveDocumentWithConflictHandler = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    CBLConflictHandler conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DeleteDocument = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DeleteDocument = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DeleteDocumentWithConcurrencyControl
    = ffi.Bool Function(
        ffi.Pointer<CBLDatabase> db,
        ffi.Pointer<CBLDocument> document,
        CBLConcurrencyControl concurrency,
        ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DeleteDocumentWithConcurrencyControl = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    int concurrency,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_PurgeDocument = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_PurgeDocument = bool Function(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_PurgeDocumentByID = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_PurgeDocumentByID = bool Function(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_GetMutableDocument
    = ffi.Pointer<CBLDocument> Function(ffi.Pointer<CBLDatabase> database,
        FLString docID, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_GetMutableDocument = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLDatabase> database,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDocument_Create = ffi.Pointer<CBLDocument> Function();
typedef DartCBLDocument_Create = ffi.Pointer<CBLDocument> Function();
typedef NativeCBLDocument_CreateWithID = ffi.Pointer<CBLDocument> Function(
    FLString docID);
typedef DartCBLDocument_CreateWithID = ffi.Pointer<CBLDocument> Function(
    FLString docID);
typedef NativeCBLDocument_MutableCopy = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLDocument> original);
typedef DartCBLDocument_MutableCopy = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLDocument> original);
typedef NativeCBLDocument_ID = FLString Function(ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_ID = FLString Function(ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_RevisionID = FLString Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_RevisionID = FLString Function(
    ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_Sequence = ffi.Uint64 Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_Sequence = int Function(ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_Properties = FLDict Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_Properties = FLDict Function(
    ffi.Pointer<CBLDocument> arg0);
typedef FLMutableDict = ffi.Pointer<_FLDict>;
typedef NativeCBLDocument_MutableProperties = FLMutableDict Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_MutableProperties = FLMutableDict Function(
    ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_SetProperties = ffi.Void Function(
    ffi.Pointer<CBLDocument> arg0, FLMutableDict properties);
typedef DartCBLDocument_SetProperties = void Function(
    ffi.Pointer<CBLDocument> arg0, FLMutableDict properties);
typedef NativeCBLDocument_CreateJSON = FLSliceResult Function(
    ffi.Pointer<CBLDocument> arg0);
typedef DartCBLDocument_CreateJSON = FLSliceResult Function(
    ffi.Pointer<CBLDocument> arg0);
typedef NativeCBLDocument_SetJSON = ffi.Bool Function(
    ffi.Pointer<CBLDocument> arg0,
    FLSlice json,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDocument_SetJSON = bool Function(ffi.Pointer<CBLDocument> arg0,
    FLSlice json, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_GetDocumentExpiration = CBLTimestamp Function(
    ffi.Pointer<CBLDatabase> db, FLSlice docID, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_GetDocumentExpiration = int Function(
    ffi.Pointer<CBLDatabase> db, FLSlice docID, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_SetDocumentExpiration = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    CBLTimestamp expiration,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_SetDocumentExpiration = bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    int expiration,
    ffi.Pointer<CBLError> outError);
typedef CBLDocumentChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDatabase> db, FLString docID);
typedef DartCBLDocumentChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDatabase> db, FLString docID);

/// A document change listener callback, invoked after a specific document is
/// changed on disk. @warning By default, this listener may be called on
/// arbitrary threads. If your code isn't prepared for that, you may want to use
/// \ref CBLDatabase_BufferNotifications so that listeners will be called in a
/// safe context. @warning <b>Deprecated :</b> Use CBLCollectionChangeListener
/// instead. @param context An arbitrary value given when the callback was
/// registered. @param db The database containing the document. @param docID The
/// document's ID.
typedef CBLDocumentChangeListener
    = ffi.Pointer<ffi.NativeFunction<CBLDocumentChangeListenerFunction>>;
typedef NativeCBLDatabase_AddDocumentChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLDatabase> db,
        FLString docID,
        CBLDocumentChangeListener listener,
        ffi.Pointer<ffi.Void> context);
typedef DartCBLDatabase_AddDocumentChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLDatabase> db,
        FLString docID,
        CBLDocumentChangeListener listener,
        ffi.Pointer<ffi.Void> context);

/// Query languages
typedef CBLQueryLanguage = ffi.Uint32;
typedef DartCBLQueryLanguage = int;
typedef NativeCBLDatabase_CreateQuery = ffi.Pointer<CBLQuery> Function(
    ffi.Pointer<CBLDatabase> db,
    CBLQueryLanguage language,
    FLString queryString,
    ffi.Pointer<ffi.Int> outErrorPos,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_CreateQuery = ffi.Pointer<CBLQuery> Function(
    ffi.Pointer<CBLDatabase> db,
    int language,
    FLString queryString,
    ffi.Pointer<ffi.Int> outErrorPos,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLQuery_SetParameters = ffi.Void Function(
    ffi.Pointer<CBLQuery> query, FLDict parameters);
typedef DartCBLQuery_SetParameters = void Function(
    ffi.Pointer<CBLQuery> query, FLDict parameters);
typedef NativeCBLQuery_Parameters = FLDict Function(
    ffi.Pointer<CBLQuery> query);
typedef DartCBLQuery_Parameters = FLDict Function(ffi.Pointer<CBLQuery> query);
typedef NativeCBLQuery_Execute = ffi.Pointer<CBLResultSet> Function(
    ffi.Pointer<CBLQuery> arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLQuery_Execute = ffi.Pointer<CBLResultSet> Function(
    ffi.Pointer<CBLQuery> arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLQuery_Explain = FLSliceResult Function(
    ffi.Pointer<CBLQuery> arg0);
typedef DartCBLQuery_Explain = FLSliceResult Function(
    ffi.Pointer<CBLQuery> arg0);
typedef NativeCBLQuery_ColumnCount = ffi.UnsignedInt Function(
    ffi.Pointer<CBLQuery> arg0);
typedef DartCBLQuery_ColumnCount = int Function(ffi.Pointer<CBLQuery> arg0);
typedef NativeCBLQuery_ColumnName = FLSlice Function(
    ffi.Pointer<CBLQuery> arg0, ffi.UnsignedInt columnIndex);
typedef DartCBLQuery_ColumnName = FLSlice Function(
    ffi.Pointer<CBLQuery> arg0, int columnIndex);
typedef NativeCBLResultSet_Next = ffi.Bool Function(
    ffi.Pointer<CBLResultSet> arg0);
typedef DartCBLResultSet_Next = bool Function(ffi.Pointer<CBLResultSet> arg0);

final class _FLValue extends ffi.Opaque {}

typedef FLValue = ffi.Pointer<_FLValue>;
typedef NativeCBLResultSet_ValueAtIndex = FLValue Function(
    ffi.Pointer<CBLResultSet> arg0, ffi.UnsignedInt index);
typedef DartCBLResultSet_ValueAtIndex = FLValue Function(
    ffi.Pointer<CBLResultSet> arg0, int index);
typedef NativeCBLResultSet_ValueForKey = FLValue Function(
    ffi.Pointer<CBLResultSet> arg0, FLString key);
typedef DartCBLResultSet_ValueForKey = FLValue Function(
    ffi.Pointer<CBLResultSet> arg0, FLString key);

final class _FLArray extends ffi.Opaque {}

typedef FLArray = ffi.Pointer<_FLArray>;
typedef NativeCBLResultSet_ResultArray = FLArray Function(
    ffi.Pointer<CBLResultSet> arg0);
typedef DartCBLResultSet_ResultArray = FLArray Function(
    ffi.Pointer<CBLResultSet> arg0);
typedef NativeCBLResultSet_ResultDict = FLDict Function(
    ffi.Pointer<CBLResultSet> arg0);
typedef DartCBLResultSet_ResultDict = FLDict Function(
    ffi.Pointer<CBLResultSet> arg0);
typedef NativeCBLResultSet_GetQuery = ffi.Pointer<CBLQuery> Function(
    ffi.Pointer<CBLResultSet> rs);
typedef DartCBLResultSet_GetQuery = ffi.Pointer<CBLQuery> Function(
    ffi.Pointer<CBLResultSet> rs);
typedef CBLQueryChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> token);
typedef DartCBLQueryChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> token);

/// A callback to be invoked after the query's results have changed. The actual
/// result set can be obtained by calling \ref CBLQuery_CopyCurrentResults,
/// either during the callback or at any time thereafter. @warning By default,
/// this listener may be called on arbitrary threads. If your code isn't
/// prepared for that, you may want to use \ref CBLDatabase_BufferNotifications
/// so that listeners will be called in a safe context. @param context The same
/// `context` value that you passed when adding the listener. @param query The
/// query that triggered the listener. @param token The token for obtaining the
/// query results by calling \ref CBLQuery_CopyCurrentResults.
typedef CBLQueryChangeListener
    = ffi.Pointer<ffi.NativeFunction<CBLQueryChangeListenerFunction>>;
typedef NativeCBLQuery_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLQuery> query,
        CBLQueryChangeListener listener, ffi.Pointer<ffi.Void> context);
typedef DartCBLQuery_AddChangeListener = ffi.Pointer<CBLListenerToken> Function(
    ffi.Pointer<CBLQuery> query,
    CBLQueryChangeListener listener,
    ffi.Pointer<ffi.Void> context);
typedef NativeCBLQuery_CopyCurrentResults = ffi.Pointer<CBLResultSet> Function(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> listener,
    ffi.Pointer<CBLError> outError);
typedef DartCBLQuery_CopyCurrentResults = ffi.Pointer<CBLResultSet> Function(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> listener,
    ffi.Pointer<CBLError> outError);

/// Value Index Configuration.
final class CBLValueIndexConfiguration extends ffi.Struct {
  /// The language used in the expressions.
  @CBLQueryLanguage()
  external int expressionLanguage;

  /// The expressions describing each coloumn of the index. The expressions
  /// could be specified in a JSON Array or in N1QL syntax using comma
  /// delimiter.
  external FLString expressions;
}

typedef NativeCBLDatabase_CreateValueIndex = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_CreateValueIndex = bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError);

/// Full-Text Index Configuration.
final class CBLFullTextIndexConfiguration extends ffi.Struct {
  /// The language used in the expressions (Required).
  @CBLQueryLanguage()
  external int expressionLanguage;

  /// The expressions describing each coloumn of the index. The expressions
  /// could be specified in a JSON Array or in N1QL syntax using comma
  /// delimiter. (Required)
  external FLString expressions;

  /// Should diacritical marks (accents) be ignored? Defaults to \ref
  /// kCBLDefaultFullTextIndexIgnoreAccents. Generally this should be left
  /// `false` for non-English text.
  @ffi.Bool()
  external bool ignoreAccents;

  /// The dominant language. Setting this enables word stemming, i.e. matching
  /// different cases of the same word ("big" and "bigger", for instance) and
  /// ignoring common "stop-words" ("the", "a", "of", etc.)
  ///
  /// Can be an ISO-639 language code or a lowercase (English) language name;
  /// supported languages are: da/danish, nl/dutch, en/english, fi/finnish,
  /// fr/french, de/german, hu/hungarian, it/italian, no/norwegian,
  /// pt/portuguese, ro/romanian, ru/russian, es/spanish, sv/swedish,
  /// tr/turkish.
  ///
  /// If left null, or set to an unrecognized language, no language-specific
  /// behaviors such as stemming and stop-word removal occur.
  external FLString language;
}

typedef NativeCBLDatabase_CreateFullTextIndex = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_CreateFullTextIndex = bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DeleteIndex = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db, FLString name, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DeleteIndex = bool Function(
    ffi.Pointer<CBLDatabase> db, FLString name, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_GetIndexNames = FLArray Function(
    ffi.Pointer<CBLDatabase> db);
typedef DartCBLDatabase_GetIndexNames = FLArray Function(
    ffi.Pointer<CBLDatabase> db);
typedef FLMutableArray = ffi.Pointer<_FLArray>;
typedef NativeCBLDatabase_ScopeNames = FLMutableArray Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_ScopeNames = FLMutableArray Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_CollectionNames = FLMutableArray Function(
    ffi.Pointer<CBLDatabase> db,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_CollectionNames = FLMutableArray Function(
    ffi.Pointer<CBLDatabase> db,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Scope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLDatabase> db,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_Scope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLDatabase> db,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_CreateCollection
    = ffi.Pointer<CBLCollection> Function(
        ffi.Pointer<CBLDatabase> db,
        FLString collectionName,
        FLString scopeName,
        ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_CreateCollection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DeleteCollection = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DeleteCollection = bool Function(
    ffi.Pointer<CBLDatabase> db,
    FLString collectionName,
    FLString scopeName,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DefaultScope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DefaultScope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_DefaultCollection = ffi.Pointer<CBLCollection>
    Function(ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_DefaultCollection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLDatabase> db, ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_Scope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLCollection> collection);
typedef DartCBLCollection_Scope = ffi.Pointer<CBLScope> Function(
    ffi.Pointer<CBLCollection> collection);
typedef NativeCBLCollection_Name = FLString Function(
    ffi.Pointer<CBLCollection> collection);
typedef DartCBLCollection_Name = FLString Function(
    ffi.Pointer<CBLCollection> collection);
typedef NativeCBLCollection_Count = ffi.Uint64 Function(
    ffi.Pointer<CBLCollection> collection);
typedef DartCBLCollection_Count = int Function(
    ffi.Pointer<CBLCollection> collection);
typedef NativeCBLCollection_GetDocument = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_GetDocument = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_SaveDocument = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_SaveDocument = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_SaveDocumentWithConcurrencyControl
    = ffi.Bool Function(
        ffi.Pointer<CBLCollection> collection,
        ffi.Pointer<CBLDocument> doc,
        CBLConcurrencyControl concurrency,
        ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_SaveDocumentWithConcurrencyControl = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    int concurrency,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_SaveDocumentWithConflictHandler = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    CBLConflictHandler conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_SaveDocumentWithConflictHandler = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> doc,
    CBLConflictHandler conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_DeleteDocument = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_DeleteDocument = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_DeleteDocumentWithConcurrencyControl
    = ffi.Bool Function(
        ffi.Pointer<CBLCollection> collection,
        ffi.Pointer<CBLDocument> document,
        CBLConcurrencyControl concurrency,
        ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_DeleteDocumentWithConcurrencyControl = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    int concurrency,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_PurgeDocument = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_PurgeDocument = bool Function(
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_PurgeDocumentByID = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_PurgeDocumentByID = bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_GetDocumentExpiration = CBLTimestamp Function(
    ffi.Pointer<CBLCollection> collection,
    FLSlice docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_GetDocumentExpiration = int Function(
    ffi.Pointer<CBLCollection> collection,
    FLSlice docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_SetDocumentExpiration = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLSlice docID,
    CBLTimestamp expiration,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_SetDocumentExpiration = bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLSlice docID,
    int expiration,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_GetMutableDocument
    = ffi.Pointer<CBLDocument> Function(ffi.Pointer<CBLCollection> collection,
        FLString docID, ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_GetMutableDocument
    = ffi.Pointer<CBLDocument> Function(ffi.Pointer<CBLCollection> collection,
        FLString docID, ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_CreateValueIndex = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_CreateValueIndex = bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_CreateFullTextIndex = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_CreateFullTextIndex = bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_DeleteIndex = ffi.Bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_DeleteIndex = bool Function(
    ffi.Pointer<CBLCollection> collection,
    FLString name,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLCollection_GetIndexNames = FLMutableArray Function(
    ffi.Pointer<CBLCollection> collection, ffi.Pointer<CBLError> outError);
typedef DartCBLCollection_GetIndexNames = FLMutableArray Function(
    ffi.Pointer<CBLCollection> collection, ffi.Pointer<CBLError> outError);

/// \name Change Listeners @{ A collection change listener lets you detect
/// changes made to all documents in a collection. (If you want to observe
/// specific documents, use a \ref CBLCollectionDocumentChangeListener instead.)
/// @note If there are multiple \ref CBLCollection instances on the same
/// database file, each one's listeners will be notified of changes made by
/// other collection instances. @warning Changes made to the database file by
/// other processes will _not_ be notified.
final class CBLCollectionChange extends ffi.Struct {
  /// <The collection that changed.
  external ffi.Pointer<CBLCollection> collection;

  /// < The number of documents that changed (size of the `docIDs` array).
  @ffi.UnsignedInt()
  external int numDocs;

  /// <The IDs of the documents that changed.
  external ffi.Pointer<FLString> docIDs;
}

typedef CBLCollectionChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLCollectionChange> change);
typedef DartCBLCollectionChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLCollectionChange> change);

/// A collection change listener callback, invoked after one or more documents
/// are changed on disk. @warning By default, this listener may be called on
/// arbitrary threads. If your code isn't prepared for that, you may want to use
/// \ref CBLDatabase_BufferNotifications so that listeners will be called in a
/// safe context. @param context An arbitrary value given when the callback was
/// registered. @param change The collection change information.
typedef CBLCollectionChangeListener
    = ffi.Pointer<ffi.NativeFunction<CBLCollectionChangeListenerFunction>>;
typedef NativeCBLCollection_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLCollection> collection,
        CBLCollectionChangeListener listener,
        ffi.Pointer<ffi.Void> context);
typedef DartCBLCollection_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLCollection> collection,
        CBLCollectionChangeListener listener,
        ffi.Pointer<ffi.Void> context);

/// \name Document listeners @{ A document change listener lets you detect
/// changes made to a specific document after they are persisted to the
/// collection. @note If there are multiple CBLCollection instances on the same
/// database file, each one's document listeners will be notified of changes
/// made by other collection instances.
final class CBLDocumentChange extends ffi.Struct {
  /// < The collection that changed.
  external ffi.Pointer<CBLCollection> collection;

  /// <The document's ID.
  external FLString docID;
}

typedef CBLCollectionDocumentChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDocumentChange> change);
typedef DartCBLCollectionDocumentChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDocumentChange> change);

/// A document change listener callback, invoked after a specific document is
/// changed on disk. @warning By default, this listener may be called on
/// arbitrary threads. If your code isn't prepared for that, you may want to use
/// \ref CBLDatabase_BufferNotifications so that listeners will be called in a
/// safe context. @param context An arbitrary value given when the callback was
/// registered. @param change The document change info.
typedef CBLCollectionDocumentChangeListener = ffi
    .Pointer<ffi.NativeFunction<CBLCollectionDocumentChangeListenerFunction>>;
typedef NativeCBLCollection_AddDocumentChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLCollection> collection,
        FLString docID,
        CBLCollectionDocumentChangeListener listener,
        ffi.Pointer<ffi.Void> context);
typedef DartCBLCollection_AddDocumentChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
        ffi.Pointer<CBLCollection> collection,
        FLString docID,
        CBLCollectionDocumentChangeListener listener,
        ffi.Pointer<ffi.Void> context);

/// Database encryption algorithms (available only in the Enterprise Edition).
typedef CBLEncryptionAlgorithm = ffi.Uint32;
typedef DartCBLEncryptionAlgorithm = int;

/// Encryption key sizes (in bytes).
typedef CBLEncryptionKeySize = ffi.Uint64;
typedef DartCBLEncryptionKeySize = int;

/// Encryption key specified in a \ref CBLDatabaseConfiguration.
final class CBLEncryptionKey extends ffi.Struct {
  /// < Encryption algorithm
  @CBLEncryptionAlgorithm()
  external int algorithm;

  /// < Raw key data
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Uint8> bytes;
}

/// Database configuration options.
final class CBLDatabaseConfiguration extends ffi.Struct {
  /// < The parent directory of the database
  external FLString directory;

  /// < The database's encryption key (if any)
  external CBLEncryptionKey encryptionKey;
}

typedef NativeCBLDatabaseConfiguration_Default = CBLDatabaseConfiguration
    Function();
typedef DartCBLDatabaseConfiguration_Default = CBLDatabaseConfiguration
    Function();
typedef NativeCBLEncryptionKey_FromPassword = ffi.Bool Function(
    ffi.Pointer<CBLEncryptionKey> key, FLString password);
typedef DartCBLEncryptionKey_FromPassword = bool Function(
    ffi.Pointer<CBLEncryptionKey> key, FLString password);
typedef NativeCBLEncryptionKey_FromPasswordOld = ffi.Bool Function(
    ffi.Pointer<CBLEncryptionKey> key, FLString password);
typedef DartCBLEncryptionKey_FromPasswordOld = bool Function(
    ffi.Pointer<CBLEncryptionKey> key, FLString password);
typedef NativeCBL_DatabaseExists = ffi.Bool Function(
    FLString name, FLString inDirectory);
typedef DartCBL_DatabaseExists = bool Function(
    FLString name, FLString inDirectory);
typedef NativeCBL_CopyDatabase = ffi.Bool Function(
    FLString fromPath,
    FLString toName,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError);
typedef DartCBL_CopyDatabase = bool Function(
    FLString fromPath,
    FLString toName,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBL_DeleteDatabase = ffi.Bool Function(
    FLString name, FLString inDirectory, ffi.Pointer<CBLError> outError);
typedef DartCBL_DeleteDatabase = bool Function(
    FLString name, FLString inDirectory, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Open = ffi.Pointer<CBLDatabase> Function(
    FLSlice name,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_Open = ffi.Pointer<CBLDatabase> Function(
    FLSlice name,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Close = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_Close = bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Delete = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_Delete = bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_BeginTransaction = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_BeginTransaction = bool Function(
    ffi.Pointer<CBLDatabase> arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_EndTransaction = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Bool commit,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_EndTransaction = bool Function(
    ffi.Pointer<CBLDatabase> arg0, bool commit, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_ChangeEncryptionKey = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLEncryptionKey> newKey,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_ChangeEncryptionKey = bool Function(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLEncryptionKey> newKey,
    ffi.Pointer<CBLError> outError);

/// Maintenance Type used when performing database maintenance.
typedef CBLMaintenanceType = ffi.Uint32;
typedef DartCBLMaintenanceType = int;
typedef NativeCBLDatabase_PerformMaintenance = ffi.Bool Function(
    ffi.Pointer<CBLDatabase> db,
    CBLMaintenanceType type,
    ffi.Pointer<CBLError> outError);
typedef DartCBLDatabase_PerformMaintenance = bool Function(
    ffi.Pointer<CBLDatabase> db, int type, ffi.Pointer<CBLError> outError);
typedef NativeCBLDatabase_Name = FLString Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef DartCBLDatabase_Name = FLString Function(ffi.Pointer<CBLDatabase> arg0);
typedef NativeCBLDatabase_Path = FLStringResult Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef DartCBLDatabase_Path = FLStringResult Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef NativeCBLDatabase_Count = ffi.Uint64 Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef DartCBLDatabase_Count = int Function(ffi.Pointer<CBLDatabase> arg0);
typedef NativeCBLDatabase_Config = CBLDatabaseConfiguration Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef DartCBLDatabase_Config = CBLDatabaseConfiguration Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef CBLDatabaseChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDatabase> db,
    ffi.UnsignedInt numDocs,
    ffi.Pointer<FLString> docIDs);
typedef DartCBLDatabaseChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDatabase> db,
    int numDocs,
    ffi.Pointer<FLString> docIDs);

/// A default collection change listener callback, invoked after one or more
/// documents in the default collection are changed on disk. @warning By
/// default, this listener may be called on arbitrary threads. If your code
/// isn't prepared for that, you may want to use \ref
/// CBLDatabase_BufferNotifications so that listeners will be called in a safe
/// context. @warning <b>Deprecated :</b> CBLCollectionChangeListener instead.
/// @param context An arbitrary value given when the callback was registered.
/// @param db The database that changed. @param numDocs The number of documents
/// that changed (size of the `docIDs` array) @param docIDs The IDs of the
/// documents that changed, as a C array of `numDocs` C strings.
typedef CBLDatabaseChangeListener
    = ffi.Pointer<ffi.NativeFunction<CBLDatabaseChangeListenerFunction>>;
typedef NativeCBLDatabase_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLDatabase> db,
        CBLDatabaseChangeListener listener, ffi.Pointer<ffi.Void> context);
typedef DartCBLDatabase_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLDatabase> db,
        CBLDatabaseChangeListener listener, ffi.Pointer<ffi.Void> context);
typedef CBLNotificationsReadyCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDatabase> db);
typedef DartCBLNotificationsReadyCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<CBLDatabase> db);

/// Callback indicating that the database (or an object belonging to it) is
/// ready to call one or more listeners. You should call \ref
/// CBLDatabase*SendNotifications at your earliest convenience, in the context
/// (thread, dispatch queue, etc.) you want them to run. @note This callback is
/// called \_only once* until the next time \ref CBLDatabase_SendNotifications
/// is called. If you don't respond by (sooner or later) calling that function,
/// you will not be informed that any listeners are ready. @warning This can be
/// called from arbitrary threads. It should do as little work as possible, just
/// scheduling a future call to \ref CBLDatabase_SendNotifications.
typedef CBLNotificationsReadyCallback
    = ffi.Pointer<ffi.NativeFunction<CBLNotificationsReadyCallbackFunction>>;
typedef NativeCBLDatabase_BufferNotifications = ffi.Void Function(
    ffi.Pointer<CBLDatabase> db,
    CBLNotificationsReadyCallback callback,
    ffi.Pointer<ffi.Void> context);
typedef DartCBLDatabase_BufferNotifications = void Function(
    ffi.Pointer<CBLDatabase> db,
    CBLNotificationsReadyCallback callback,
    ffi.Pointer<ffi.Void> context);
typedef NativeCBLDatabase_SendNotifications = ffi.Void Function(
    ffi.Pointer<CBLDatabase> db);
typedef DartCBLDatabase_SendNotifications = void Function(
    ffi.Pointer<CBLDatabase> db);

final class CBLEndpoint extends ffi.Opaque {}

typedef NativeCBLEndpoint_CreateWithURL = ffi.Pointer<CBLEndpoint> Function(
    FLString url, ffi.Pointer<CBLError> outError);
typedef DartCBLEndpoint_CreateWithURL = ffi.Pointer<CBLEndpoint> Function(
    FLString url, ffi.Pointer<CBLError> outError);
typedef NativeCBLEndpoint_CreateWithLocalDB = ffi.Pointer<CBLEndpoint> Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef DartCBLEndpoint_CreateWithLocalDB = ffi.Pointer<CBLEndpoint> Function(
    ffi.Pointer<CBLDatabase> arg0);
typedef NativeCBLEndpoint_Free = ffi.Void Function(
    ffi.Pointer<CBLEndpoint> arg0);
typedef DartCBLEndpoint_Free = void Function(ffi.Pointer<CBLEndpoint> arg0);

final class CBLAuthenticator extends ffi.Opaque {}

typedef NativeCBLAuth_CreatePassword = ffi.Pointer<CBLAuthenticator> Function(
    FLString username, FLString password);
typedef DartCBLAuth_CreatePassword = ffi.Pointer<CBLAuthenticator> Function(
    FLString username, FLString password);
typedef NativeCBLAuth_CreateSession = ffi.Pointer<CBLAuthenticator> Function(
    FLString sessionID, FLString cookieName);
typedef DartCBLAuth_CreateSession = ffi.Pointer<CBLAuthenticator> Function(
    FLString sessionID, FLString cookieName);
typedef NativeCBLAuth_Free = ffi.Void Function(
    ffi.Pointer<CBLAuthenticator> arg0);
typedef DartCBLAuth_Free = void Function(ffi.Pointer<CBLAuthenticator> arg0);

/// Direction of replication: push, pull, or both.
typedef CBLReplicatorType = ffi.Uint8;
typedef DartCBLReplicatorType = int;

/// Flags describing a replicated document.
typedef CBLDocumentFlags = ffi.UnsignedInt;
typedef DartCBLDocumentFlags = int;
typedef CBLReplicationFilterFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDocument> document,
    CBLDocumentFlags flags);
typedef DartCBLReplicationFilterFunction = bool Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDocument> document,
    DartCBLDocumentFlags flags);

/// A callback that can decide whether a particular document should be pushed or
/// pulled. @warning This callback will be called on a background thread managed
/// by the replicator. It must pay attention to thread-safety. It should not
/// take a long time to return, or it will slow down the replicator. @param
/// context The `context` field of the \ref CBLReplicatorConfiguration. @param
/// document The document in question. @param flags Indicates whether the
/// document was deleted or removed. @return True if the document should be
/// replicated, false to skip it.
typedef CBLReplicationFilter
    = ffi.Pointer<ffi.NativeFunction<CBLReplicationFilterFunction>>;
typedef CBLConflictResolverFunction = ffi.Pointer<CBLDocument> Function(
    ffi.Pointer<ffi.Void> context,
    FLString documentID,
    ffi.Pointer<CBLDocument> localDocument,
    ffi.Pointer<CBLDocument> remoteDocument);

/// Conflict-resolution callback for use in replications. This callback will be
/// invoked when the replicator finds a newer server-side revision of a document
/// that also has local changes. The local and remote changes must be resolved
/// before the document can be pushed to the server. @note Any new CBLBlob
/// objects set to the resolved document returned by the callback must not be
/// released. They need to be retained for installation while the resolved
/// document is being saved into the database, and the replicator will be
/// responsible for releasing them after they are installed. @warning This
/// callback will be called on a background thread managed by the replicator. It
/// must pay attention to thread-safety. However, unlike a filter callback, it
/// does not need to return quickly. If it needs to prompt for user input,
/// that's OK. @param context The `context` field of the \ref
/// CBLReplicatorConfiguration. @param documentID The ID of the conflicted
/// document. @param localDocument The current revision of the document in the
/// local database, or NULL if the local document has been deleted. @param
/// remoteDocument The revision of the document found on the server, or NULL if
/// the document has been deleted on the server. @return The resolved document
/// to save locally (and push, if the replicator is pushing.) This can be the
/// same as \p localDocument or \p remoteDocument, or you can create a mutable
/// copy of either one and modify it appropriately. Or return NULL if the
/// resolution is to delete the document.
typedef CBLConflictResolver
    = ffi.Pointer<ffi.NativeFunction<CBLConflictResolverFunction>>;

/// Types of proxy servers, for CBLProxySettings.
typedef CBLProxyType = ffi.Uint8;
typedef DartCBLProxyType = int;

/// Proxy settings for the replicator.
final class CBLProxySettings extends ffi.Struct {
  /// < Type of proxy
  @CBLProxyType()
  external int type;

  /// < Proxy server hostname or IP address
  external FLString hostname;

  /// < Proxy server port
  @ffi.Uint16()
  external int port;

  /// < Username for proxy auth (optional)
  external FLString username;

  /// < Password for proxy auth
  external FLString password;
}

typedef CBLPropertyEncryptorFunction = FLSliceResult Function(
    ffi.Pointer<ffi.Void> context,
    FLString documentID,
    FLDict properties,
    FLString keyPath,
    FLSlice input,
    ffi.Pointer<FLStringResult> algorithm,
    ffi.Pointer<FLStringResult> kid,
    ffi.Pointer<CBLError> error);

/// Callback that encrypts \ref CBLEncryptable properties in the documents of
/// the default collection pushed by the replicator. The callback returns
/// encrypted data as a FLSliceResult object, and the replicator will
/// responsible for releasing the returned FLSliceResult object.
///
/// If an error occurred during encryption, return a null \ref FLSliceResult
/// with an error set to the out error parameter of the callback. There are two
/// errors that are supported by the callback :
///
/// 1. kCBLDomain / kCBLErrorCrypto : Permanent Crypto Error. When this error is
///    set, the document will fail to replicate, and the document will not be
///    synced again unless the document is updated, or the replicator is reset.
///
/// 2. kCBLWebSocketDomain / 503 : Service Unavailable Error. This error is for
///    mostly for a case such as when a crypto service is temporarily
///    unavailable during encryption. When this error is set, the replicator
///    will go into the offline state and will retry again according to the
///    replicator retry logic. As a result, the document will be retried to
///    replicate again, and the encryption callback will be called again to
///    encrypt the properties of the document.
///
/// @note If an error besides the two errors above is set to the out error
/// parameter of the callback, or only a null \ref FLSliceResult object is
/// returned without setting an error, the document will be failed to replicate
/// as the kCBLDomain / kCBLErrorCrypto error is sepecified. @note A null \ref
/// FLSliceResult can be created by calling FLSliceResult_CreateWith(nullptr,
/// 0). @warning <b>Deprecated :</b> Use CBLDocumentPropertyEncryptor instead.
typedef CBLPropertyEncryptor
    = ffi.Pointer<ffi.NativeFunction<CBLPropertyEncryptorFunction>>;
typedef CBLPropertyDecryptorFunction = FLSliceResult Function(
    ffi.Pointer<ffi.Void> context,
    FLString documentID,
    FLDict properties,
    FLString keyPath,
    FLSlice input,
    FLString algorithm,
    FLString kid,
    ffi.Pointer<CBLError> error);

/// Callback that decrypts encrypted \ref CBLEncryptable properties in documents
/// of the default collection pulled by the replicator. The callback returns
/// decrypted data as a FLSliceResult object, and the replicator will
/// responsible for releasing the returned FLSliceResult object.
///
/// If an error occurred during decryption, return a null \ref FLSliceResult
/// with an error set to the out error parameter of the callback. There are two
/// errors that are supported by the callback :
///
/// 1. kCBLDomain / kCBLErrorCrypto : Permanent Crypto Error. When this error is
///    set, the document will fail to replicate, and the document will not be
///    synced again unless the document is updated, or the replicator is reset.
///
/// 2. kCBLWebSocketDomain / 503 : Service Unavailable Error. This error is for
///    mostly for a case such as when a crypto service is temporarily
///    unavailable during decryption. When this error is set, the replicator
///    will go into the offline state and will retry again according to the
///    replicator retry logic. As a result, the document will be retried to
///    replicate again, and the decryption callback will be called again to
///    decrypt the properties of the document.
///
/// If the decryption should be skipped to retain the encrypted data as-is,
/// return a null \ref FLSliceResult object without setting an error set to the
/// out error parameter.
///
/// @note If an error besides the two errors above is set to the out error
/// parameter of the callback, the document will be failed to replicate as
/// getting the kCBLDomain / kCBLErrorCrypto error. @note A null \ref
/// FLSliceResult can be created by calling FLSliceResult_CreateWith(nullptr,
/// 0). @warning <b>Deprecated :</b> Use CBLDocumentPropertyDecryptor instead.
typedef CBLPropertyDecryptor
    = ffi.Pointer<ffi.NativeFunction<CBLPropertyDecryptorFunction>>;
typedef CBLDocumentPropertyEncryptorFunction = FLSliceResult Function(
    ffi.Pointer<ffi.Void> context,
    FLString scope,
    FLString collection,
    FLString documentID,
    FLDict properties,
    FLString keyPath,
    FLSlice input,
    ffi.Pointer<FLStringResult> algorithm,
    ffi.Pointer<FLStringResult> kid,
    ffi.Pointer<CBLError> error);

/// Callback that encrypts \ref CBLEncryptable properties in the documents
/// pushed by the replicator. The callback returns encrypted data as a
/// FLSliceResult object, and the replicator will responsible for releasing the
/// returned FLSliceResult object.
///
/// If an error occurred during encryption, return a null \ref FLSliceResult
/// with an error set to the out error parameter of the callback. There are two
/// errors that are supported by the callback :
///
/// 1. kCBLDomain / kCBLErrorCrypto : Permanent Crypto Error. When this error is
///    set, the document will fail to replicate, and the document will not be
///    synced again unless the document is updated, or the replicator is reset.
///
/// 2. kCBLWebSocketDomain / 503 : Service Unavailable Error. This error is for
///    mostly for a case such as when a crypto service is temporarily
///    unavailable during encryption. When this error is set, the replicator
///    will go into the offline state and will retry again according to the
///    replicator retry logic. As a result, the document will be retried to
///    replicate again, and the encryption callback will be called again to
///    encrypt the properties of the document.
///
/// @note If an error besides the two errors above is set to the out error
/// parameter of the callback, or only a null \ref FLSliceResult object is
/// returned without setting an error, the document will be failed to replicate
/// as the kCBLDomain / kCBLErrorCrypto error is sepecified. @note A null \ref
/// FLSliceResult can be created by calling FLSliceResult_CreateWith(nullptr,
/// 0).
typedef CBLDocumentPropertyEncryptor
    = ffi.Pointer<ffi.NativeFunction<CBLDocumentPropertyEncryptorFunction>>;
typedef CBLDocumentPropertyDecryptorFunction = FLSliceResult Function(
    ffi.Pointer<ffi.Void> context,
    FLString scope,
    FLString collection,
    FLString documentID,
    FLDict properties,
    FLString keyPath,
    FLSlice input,
    FLString algorithm,
    FLString kid,
    ffi.Pointer<CBLError> error);

/// Callback that decrypts encrypted \ref CBLEncryptable properties in documents
/// pulled by the replicator. The callback returns decrypted data as a
/// FLSliceResult object, and the replicator will responsible for releasing the
/// returned FLSliceResult object.
///
/// If an error occurred during decryption, return a null \ref FLSliceResult
/// with an error set to the out error parameter of the callback. There are two
/// errors that are supported by the callback :
///
/// 1. kCBLDomain / kCBLErrorCrypto : Permanent Crypto Error. When this error is
///    set, the document will fail to replicate, and the document will not be
///    synced again unless the document is updated, or the replicator is reset.
///
/// 2. kCBLWebSocketDomain / 503 : Service Unavailable Error. This error is for
///    mostly for a case such as when a crypto service is temporarily
///    unavailable during decryption. When this error is set, the replicator
///    will go into the offline state and will retry again according to the
///    replicator retry logic. As a result, the document will be retried to
///    replicate again, and the decryption callback will be called again to
///    decrypt the properties of the document.
///
/// If the decryption should be skipped to retain the encrypted data as-is,
/// return a null \ref FLSliceResult object without setting an error set to the
/// out error parameter.
///
/// @note If an error besides the two errors above is set to the out error
/// parameter of the callback, the document will be failed to replicate as
/// getting the kCBLDomain / kCBLErrorCrypto error. @note A null \ref
/// FLSliceResult can be created by calling FLSliceResult_CreateWith(nullptr,
/// 0).
typedef CBLDocumentPropertyDecryptor
    = ffi.Pointer<ffi.NativeFunction<CBLDocumentPropertyDecryptorFunction>>;

/// The collection and the configuration that can be configured specifically for
/// the replication.
final class CBLReplicationCollection extends ffi.Struct {
  /// < The collection.
  external ffi.Pointer<CBLCollection> collection;

  /// < Optional conflict-resolver callback
  external CBLConflictResolver conflictResolver;

  /// < Optional callback to filter which docs are pushed
  external CBLReplicationFilter pushFilter;

  /// < Optional callback to validate incoming docs.
  external CBLReplicationFilter pullFilter;

  /// Optional set of channels to pull from. @note Channels are not supported in
  /// Peer-to-Peer and Database-to-Database replication.
  external FLArray channels;

  /// < Optional set of document IDs to replicate
  external FLArray documentIDs;
}

/// The configuration of a replicator.
final class CBLReplicatorConfiguration extends ffi.Struct {
  /// The database to replicate. When setting the database, ONLY the default
  /// collection will be used for replication. (Required if collections is not
  /// set) @warning <b>Deprecated :</b> Use collections instead.
  external ffi.Pointer<CBLDatabase> database;

  /// <
  external ffi.Pointer<CBLEndpoint> endpoint;

  /// Push, pull or both. The default value is \ref kCBLDefaultReplicatorType.
  @CBLReplicatorType()
  external int replicatorType;

  /// Continuous replication?. The default value is \ref
  /// kCBLDefaultReplicatorContinuous.
  @ffi.Bool()
  external bool continuous;

  /// If auto purge is active, then the library will automatically purge any
  /// documents that the replicating user loses access to via the Sync Function
  /// on Sync Gateway. If disableAutoPurge is true, this behavior is disabled
  /// and an access removed event will be sent to any document listeners that
  /// are active on the replicator. The default value is \ref
  /// kCBLDefaultReplicatorDisableAutoPurge.
  ///
  /// \note Auto Purge will not be performed when documentIDs filter is
  /// specified.
  @ffi.Bool()
  external bool disableAutoPurge;

  /// Max retry attempts where the initial connect to replicate counts toward
  /// the given value. The default value is \ref
  /// kCBLDefaultReplicatorMaxAttemptsSingleShot for a one-shot replicator and
  /// \ref kCBLDefaultReplicatorMaxAttemptsContinuous for a continuous
  /// replicator. Specify 1 means there will be no retry after the first
  /// attempt.
  @ffi.UnsignedInt()
  external int maxAttempts;

  /// Max wait time between retry attempts in seconds. The default value \ref
  /// kCBLDefaultReplicatorMaxAttemptWaitTime.
  @ffi.UnsignedInt()
  external int maxAttemptWaitTime;

  /// The heartbeat interval in seconds. The default value is \ref
  /// kCBLDefaultReplicatorHeartbeat.
  @ffi.UnsignedInt()
  external int heartbeat;

  /// < Authentication credentials, if needed
  external ffi.Pointer<CBLAuthenticator> authenticator;

  /// < HTTP client proxy settings
  external ffi.Pointer<CBLProxySettings> proxy;

  /// < Extra HTTP headers to add to the WebSocket request
  external FLDict headers;

  /// An X.509 cert (PEM or DER) to "pin" for TLS connections. The pinned cert
  /// will be evaluated against any certs in a cert chain, and the cert chain
  /// will be valid only if the cert chain contains the pinned cert.
  external FLSlice pinnedServerCertificate;

  /// < Set of anchor certs (PEM format)
  external FLSlice trustedRootCertificates;

  /// Optional set of channels to pull from when replicating with the default
  /// collection. @note This property can only be used when setting the config
  /// object with the database instead of collections. @note Channels are not
  /// supported in Peer-to-Peer and Database-to-Database replication. @warning
  /// <b>Deprecated :</b> Use CBLReplicationCollection.channels instead.
  external FLArray channels;

  /// Optional set of document IDs to replicate when replicating with the
  /// default collection. @note This property can only be used when setting the
  /// config object with the database instead of collections. @warning
  /// <b>Deprecated :</b> Use CBLReplicationCollection.documentIDs instead.
  external FLArray documentIDs;

  /// Optional callback to filter which docs are pushed when replicating with
  /// the default collection. @note This property can only be used when setting
  /// the config object with the database instead of collections. @warning
  /// <b>Deprecated :</b> Use CBLReplicationCollection.pushFilter instead.
  external CBLReplicationFilter pushFilter;

  /// Optional callback to validate incoming docs when replicating with the
  /// default collection. @note This property can only be used when setting the
  /// config object with the database instead of collections. @warning
  /// <b>Deprecated :</b> Use CBLReplicationCollection.pullFilter instead.
  external CBLReplicationFilter pullFilter;

  /// Optional conflict-resolver callback. @note This property can only be used
  /// when setting the config object with the database instead of collections.
  /// @warning <b>Deprecated :</b> Use CBLReplicationCollection.conflictResolver
  /// instead.
  external CBLConflictResolver conflictResolver;

  /// < Arbitrary value that will be passed to callbacks
  external ffi.Pointer<ffi.Void> context;

  /// Optional callback to encrypt \ref CBLEncryptable values of the documents
  /// in the default collection. @note This property can only be used when
  /// setting the config object with the database instead of collections.
  /// @warning <b>Deprecated :</b> Use documentPropertyEncryptor instead.
  external CBLPropertyEncryptor propertyEncryptor;

  /// Optional callback to decrypt encrypted \ref CBLEncryptable values of the
  /// documents in the default collection. @note This property can only be used
  /// when setting the config object with the database instead of collections.
  /// @warning <b>Deprecated :</b> Use documentPropertyDecryptor instead.
  external CBLPropertyDecryptor propertyDecryptor;

  /// < Optional callback to encrypt \ref CBLEncryptable values.
  external CBLDocumentPropertyEncryptor documentPropertyEncryptor;

  /// < Optional callback to decrypt encrypted \ref CBLEncryptable values.
  external CBLDocumentPropertyDecryptor documentPropertyDecryptor;

  /// The collections to replicate with the target's endpoint (Required if the
  /// database is not set).
  external ffi.Pointer<CBLReplicationCollection> collections;

  /// The number of collections (Required if the database is not set
  @ffi.Size()
  external int collectionCount;

  /// The option to remove the restriction that does not allow the replicator to
  /// save the parent-domain cookies, the cookies whose domains are the parent
  /// domain of the remote host, from the HTTP response. For example, when the
  /// option is set to true, the cookies whose domain are .foo.com returned by
  /// bar.foo.com host will be permitted to save. This is only recommended if
  /// the host issuing the cookie is well trusted.
  ///
  /// This option is disabled by default (see \ref
  /// kCBLDefaultReplicatorAcceptParentCookies) which means that the
  /// parent-domain cookies are not permitted to save by default.
  @ffi.Bool()
  external bool acceptParentDomainCookies;
}

typedef NativeCBLReplicator_Create = ffi.Pointer<CBLReplicator> Function(
    ffi.Pointer<CBLReplicatorConfiguration> arg0,
    ffi.Pointer<CBLError> outError);
typedef DartCBLReplicator_Create = ffi.Pointer<CBLReplicator> Function(
    ffi.Pointer<CBLReplicatorConfiguration> arg0,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLReplicator_Config = ffi.Pointer<CBLReplicatorConfiguration>
    Function(ffi.Pointer<CBLReplicator> arg0);
typedef DartCBLReplicator_Config = ffi.Pointer<CBLReplicatorConfiguration>
    Function(ffi.Pointer<CBLReplicator> arg0);
typedef NativeCBLReplicator_Start = ffi.Void Function(
    ffi.Pointer<CBLReplicator> replicator, ffi.Bool resetCheckpoint);
typedef DartCBLReplicator_Start = void Function(
    ffi.Pointer<CBLReplicator> replicator, bool resetCheckpoint);
typedef NativeCBLReplicator_Stop = ffi.Void Function(
    ffi.Pointer<CBLReplicator> arg0);
typedef DartCBLReplicator_Stop = void Function(ffi.Pointer<CBLReplicator> arg0);
typedef NativeCBLReplicator_SetHostReachable = ffi.Void Function(
    ffi.Pointer<CBLReplicator> arg0, ffi.Bool reachable);
typedef DartCBLReplicator_SetHostReachable = void Function(
    ffi.Pointer<CBLReplicator> arg0, bool reachable);
typedef NativeCBLReplicator_SetSuspended = ffi.Void Function(
    ffi.Pointer<CBLReplicator> repl, ffi.Bool suspended);
typedef DartCBLReplicator_SetSuspended = void Function(
    ffi.Pointer<CBLReplicator> repl, bool suspended);

/// The possible states a replicator can be in during its lifecycle.
typedef CBLReplicatorActivityLevel = ffi.Uint8;
typedef DartCBLReplicatorActivityLevel = int;

/// A fractional progress value, ranging from 0.0 to 1.0 as replication
/// progresses. The value is very approximate and may bounce around during
/// replication; making it more accurate would require slowing down the
/// replicator and incurring more load on the server. It's fine to use in a
/// progress bar, though.
final class CBLReplicatorProgress extends ffi.Struct {
  /// <Very-approximate fractional completion, from 0.0 to 1.0
  @ffi.Float()
  external double complete;

  /// < Number of documents transferred so far
  @ffi.Uint64()
  external int documentCount;
}

/// A replicator's current status.
final class CBLReplicatorStatus extends ffi.Struct {
  /// < Current state
  @CBLReplicatorActivityLevel()
  external int activity;

  /// < Approximate fraction complete
  external CBLReplicatorProgress progress;

  /// < Error, if any
  external CBLError error;
}

typedef NativeCBLReplicator_Status = CBLReplicatorStatus Function(
    ffi.Pointer<CBLReplicator> arg0);
typedef DartCBLReplicator_Status = CBLReplicatorStatus Function(
    ffi.Pointer<CBLReplicator> arg0);
typedef NativeCBLReplicator_PendingDocumentIDs = FLDict Function(
    ffi.Pointer<CBLReplicator> arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLReplicator_PendingDocumentIDs = FLDict Function(
    ffi.Pointer<CBLReplicator> arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLReplicator_IsDocumentPending = ffi.Bool Function(
    ffi.Pointer<CBLReplicator> repl,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef DartCBLReplicator_IsDocumentPending = bool Function(
    ffi.Pointer<CBLReplicator> repl,
    FLString docID,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLReplicator_PendingDocumentIDs2 = FLDict Function(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError);
typedef DartCBLReplicator_PendingDocumentIDs2 = FLDict Function(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError);
typedef NativeCBLReplicator_IsDocumentPending2 = ffi.Bool Function(
    ffi.Pointer<CBLReplicator> repl,
    FLString docID,
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError);
typedef DartCBLReplicator_IsDocumentPending2 = bool Function(
    ffi.Pointer<CBLReplicator> repl,
    FLString docID,
    ffi.Pointer<CBLCollection> collection,
    ffi.Pointer<CBLError> outError);
typedef CBLReplicatorChangeListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLReplicator> replicator,
    ffi.Pointer<CBLReplicatorStatus> status);
typedef DartCBLReplicatorChangeListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLReplicator> replicator,
    ffi.Pointer<CBLReplicatorStatus> status);

/// A callback that notifies you when the replicator's status changes. @note
/// This callback will be called on a background thread managed by the
/// replicator. It must pay attention to thread-safety. It should not take a
/// long time to return, or it will slow down the replicator. @param context The
/// value given when the listener was added. @param replicator The replicator.
/// @param status The replicator's status.
typedef CBLReplicatorChangeListener
    = ffi.Pointer<ffi.NativeFunction<CBLReplicatorChangeListenerFunction>>;
typedef NativeCBLReplicator_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLReplicator> arg0,
        CBLReplicatorChangeListener arg1, ffi.Pointer<ffi.Void> context);
typedef DartCBLReplicator_AddChangeListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLReplicator> arg0,
        CBLReplicatorChangeListener arg1, ffi.Pointer<ffi.Void> context);

/// Information about a document that's been pushed or pulled.
final class CBLReplicatedDocument extends ffi.Struct {
  /// < The document ID.
  external FLString ID;

  /// < Indicates whether the document was deleted or removed.
  @CBLDocumentFlags()
  external int flags;

  /// < If the code is nonzero, the document failed to replicate.
  external CBLError error;

  /// <The scope name of the collection
  external FLString scope;

  /// <The collection name.
  external FLString collection;
}

typedef CBLDocumentReplicationListenerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLReplicator> replicator,
    ffi.Bool isPush,
    ffi.UnsignedInt numDocuments,
    ffi.Pointer<CBLReplicatedDocument> documents);
typedef DartCBLDocumentReplicationListenerFunction = void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLReplicator> replicator,
    bool isPush,
    int numDocuments,
    ffi.Pointer<CBLReplicatedDocument> documents);

/// A callback that notifies you when documents are replicated. @note This
/// callback will be called on a background thread managed by the replicator. It
/// must pay attention to thread-safety. It should not take a long time to
/// return, or it will slow down the replicator. @param context The value given
/// when the listener was added. @param replicator The replicator. @param isPush
/// True if the document(s) were pushed, false if pulled. @param numDocuments
/// The number of documents reported by this callback. @param documents An array
/// with information about each document.
typedef CBLDocumentReplicationListener
    = ffi.Pointer<ffi.NativeFunction<CBLDocumentReplicationListenerFunction>>;
typedef NativeCBLReplicator_AddDocumentReplicationListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLReplicator> arg0,
        CBLDocumentReplicationListener arg1, ffi.Pointer<ffi.Void> context);
typedef DartCBLReplicator_AddDocumentReplicationListener
    = ffi.Pointer<CBLListenerToken> Function(ffi.Pointer<CBLReplicator> arg0,
        CBLDocumentReplicationListener arg1, ffi.Pointer<ffi.Void> context);
typedef NativeCBLEncryptable_CreateWithNull = ffi.Pointer<CBLEncryptable>
    Function();
typedef DartCBLEncryptable_CreateWithNull = ffi.Pointer<CBLEncryptable>
    Function();
typedef NativeCBLEncryptable_CreateWithBool = ffi.Pointer<CBLEncryptable>
    Function(ffi.Bool value);
typedef DartCBLEncryptable_CreateWithBool = ffi.Pointer<CBLEncryptable>
    Function(bool value);
typedef NativeCBLEncryptable_CreateWithInt = ffi.Pointer<CBLEncryptable>
    Function(ffi.Int64 value);
typedef DartCBLEncryptable_CreateWithInt = ffi.Pointer<CBLEncryptable> Function(
    int value);
typedef NativeCBLEncryptable_CreateWithUInt = ffi.Pointer<CBLEncryptable>
    Function(ffi.Uint64 value);
typedef DartCBLEncryptable_CreateWithUInt = ffi.Pointer<CBLEncryptable>
    Function(int value);
typedef NativeCBLEncryptable_CreateWithFloat = ffi.Pointer<CBLEncryptable>
    Function(ffi.Float value);
typedef DartCBLEncryptable_CreateWithFloat = ffi.Pointer<CBLEncryptable>
    Function(double value);
typedef NativeCBLEncryptable_CreateWithDouble = ffi.Pointer<CBLEncryptable>
    Function(ffi.Double value);
typedef DartCBLEncryptable_CreateWithDouble = ffi.Pointer<CBLEncryptable>
    Function(double value);
typedef NativeCBLEncryptable_CreateWithString = ffi.Pointer<CBLEncryptable>
    Function(FLString value);
typedef DartCBLEncryptable_CreateWithString = ffi.Pointer<CBLEncryptable>
    Function(FLString value);
typedef NativeCBLEncryptable_CreateWithValue = ffi.Pointer<CBLEncryptable>
    Function(FLValue value);
typedef DartCBLEncryptable_CreateWithValue = ffi.Pointer<CBLEncryptable>
    Function(FLValue value);
typedef NativeCBLEncryptable_CreateWithArray = ffi.Pointer<CBLEncryptable>
    Function(FLArray value);
typedef DartCBLEncryptable_CreateWithArray = ffi.Pointer<CBLEncryptable>
    Function(FLArray value);
typedef NativeCBLEncryptable_CreateWithDict = ffi.Pointer<CBLEncryptable>
    Function(FLDict value);
typedef DartCBLEncryptable_CreateWithDict = ffi.Pointer<CBLEncryptable>
    Function(FLDict value);
typedef NativeCBLEncryptable_Value = FLValue Function(
    ffi.Pointer<CBLEncryptable> encryptable);
typedef DartCBLEncryptable_Value = FLValue Function(
    ffi.Pointer<CBLEncryptable> encryptable);
typedef NativeCBLEncryptable_Properties = FLDict Function(
    ffi.Pointer<CBLEncryptable> encryptable);
typedef DartCBLEncryptable_Properties = FLDict Function(
    ffi.Pointer<CBLEncryptable> encryptable);
typedef NativeFLDict_IsEncryptableValue = ffi.Bool Function(FLDict arg0);
typedef DartFLDict_IsEncryptableValue = bool Function(FLDict arg0);
typedef NativeFLDict_GetEncryptableValue = ffi.Pointer<CBLEncryptable> Function(
    FLDict encryptableDict);
typedef DartFLDict_GetEncryptableValue = ffi.Pointer<CBLEncryptable> Function(
    FLDict encryptableDict);
typedef NativeFLSlot_SetEncryptableValue = ffi.Void Function(
    FLSlot slot, ffi.Pointer<CBLEncryptable> encryptable);
typedef DartFLSlot_SetEncryptableValue = void Function(
    FLSlot slot, ffi.Pointer<CBLEncryptable> encryptable);

/// Subsystems that log information.
typedef CBLLogDomain = ffi.Uint8;
typedef DartCBLLogDomain = int;

/// Levels of log messages. Higher values are more important/severe. Each level
/// includes the lower ones.
typedef CBLLogLevel = ffi.Uint8;
typedef DartCBLLogLevel = int;
typedef NativeCBL_Log = ffi.Void Function(
    CBLLogDomain domain, CBLLogLevel level, ffi.Pointer<ffi.Char> format);
typedef DartCBL_Log = void Function(
    int domain, int level, ffi.Pointer<ffi.Char> format);
typedef NativeCBL_LogMessage = ffi.Void Function(
    CBLLogDomain domain, CBLLogLevel level, FLSlice message);
typedef DartCBL_LogMessage = void Function(
    int domain, int level, FLSlice message);
typedef CBLLogCallbackFunction = ffi.Void Function(
    CBLLogDomain domain, CBLLogLevel level, FLString message);
typedef DartCBLLogCallbackFunction = void Function(
    DartCBLLogDomain domain, DartCBLLogLevel level, FLString message);

/// A logging callback that the application can register. @param domain The
/// domain of the message @param level The severity level of the message. @param
/// message The actual formatted message.
typedef CBLLogCallback
    = ffi.Pointer<ffi.NativeFunction<CBLLogCallbackFunction>>;
typedef NativeCBLLog_ConsoleLevel = CBLLogLevel Function();
typedef DartCBLLog_ConsoleLevel = int Function();
typedef NativeCBLLog_SetConsoleLevel = ffi.Void Function(CBLLogLevel arg0);
typedef DartCBLLog_SetConsoleLevel = void Function(int arg0);
typedef NativeCBLLog_CallbackLevel = CBLLogLevel Function();
typedef DartCBLLog_CallbackLevel = int Function();
typedef NativeCBLLog_SetCallbackLevel = ffi.Void Function(CBLLogLevel arg0);
typedef DartCBLLog_SetCallbackLevel = void Function(int arg0);
typedef NativeCBLLog_Callback = CBLLogCallback Function();
typedef DartCBLLog_Callback = CBLLogCallback Function();
typedef NativeCBLLog_SetCallback = ffi.Void Function(CBLLogCallback callback);
typedef DartCBLLog_SetCallback = void Function(CBLLogCallback callback);

/// The properties for configuring logging to files. @warning `usePlaintext`
/// results in significantly larger log files and higher CPU usage that may slow
/// down your app; we recommend turning it off in production.
final class CBLLogFileConfiguration extends ffi.Struct {
  /// < The minimum level of message to write (Required).
  @CBLLogLevel()
  external int level;

  /// < The directory where log files will be created (Required).
  external FLString directory;

  /// Max number of older log files to keep (in addition to current one.) The
  /// default is \ref kCBLDefaultLogFileMaxRotateCount.
  @ffi.Uint32()
  external int maxRotateCount;

  /// The size in bytes at which a file will be rotated out (best effort). The
  /// default is \ref kCBLDefaultLogFileMaxSize.
  @ffi.Size()
  external int maxSize;

  /// Whether or not to log in plaintext (as opposed to binary.) Plaintext
  /// logging is slower and bigger. The default is \ref
  /// kCBLDefaultLogFileUsePlainText.
  @ffi.Bool()
  external bool usePlaintext;
}

typedef NativeCBLLog_FileConfig = ffi.Pointer<CBLLogFileConfiguration>
    Function();
typedef DartCBLLog_FileConfig = ffi.Pointer<CBLLogFileConfiguration> Function();
typedef NativeCBLLog_SetFileConfig = ffi.Bool Function(
    CBLLogFileConfiguration arg0, ffi.Pointer<CBLError> outError);
typedef DartCBLLog_SetFileConfig = bool Function(
    CBLLogFileConfiguration arg0, ffi.Pointer<CBLError> outError);
typedef NativeCBLScope_Name = FLString Function(ffi.Pointer<CBLScope> scope);
typedef DartCBLScope_Name = FLString Function(ffi.Pointer<CBLScope> scope);
typedef NativeCBLScope_CollectionNames = FLMutableArray Function(
    ffi.Pointer<CBLScope> scope, ffi.Pointer<CBLError> outError);
typedef DartCBLScope_CollectionNames = FLMutableArray Function(
    ffi.Pointer<CBLScope> scope, ffi.Pointer<CBLError> outError);
typedef NativeCBLScope_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLScope> scope,
    FLString collectionName,
    ffi.Pointer<CBLError> outError);
typedef DartCBLScope_Collection = ffi.Pointer<CBLCollection> Function(
    ffi.Pointer<CBLScope> scope,
    FLString collectionName,
    ffi.Pointer<CBLError> outError);
typedef FLHeapSlice = FLSlice;
typedef NativeFLSlice_Equal = ffi.Bool Function(FLSlice a, FLSlice b);
typedef DartFLSlice_Equal = bool Function(FLSlice a, FLSlice b);
typedef NativeFLSlice_Compare = ffi.Int Function(FLSlice arg0, FLSlice arg1);
typedef DartFLSlice_Compare = int Function(FLSlice arg0, FLSlice arg1);
typedef NativeFLSlice_Hash = ffi.Uint32 Function(FLSlice s);
typedef DartFLSlice_Hash = int Function(FLSlice s);
typedef NativeFLSlice_ToCString = ffi.Bool Function(
    FLSlice s, ffi.Pointer<ffi.Char> buffer, ffi.Size capacity);
typedef DartFLSlice_ToCString = bool Function(
    FLSlice s, ffi.Pointer<ffi.Char> buffer, int capacity);
typedef NativeFLSliceResult_New = FLSliceResult Function(ffi.Size arg0);
typedef DartFLSliceResult_New = FLSliceResult Function(int arg0);
typedef NativeFLSlice_Copy = FLSliceResult Function(FLSlice arg0);
typedef DartFLSlice_Copy = FLSliceResult Function(FLSlice arg0);
typedef NativeFLBuf_Retain = ffi.Void Function(ffi.Pointer<ffi.Void> arg0);
typedef DartFLBuf_Retain = void Function(ffi.Pointer<ffi.Void> arg0);
typedef NativeFLBuf_Release = ffi.Void Function(ffi.Pointer<ffi.Void> arg0);
typedef DartFLBuf_Release = void Function(ffi.Pointer<ffi.Void> arg0);
typedef NativeFL_WipeMemory = ffi.Void Function(
    ffi.Pointer<ffi.Void> dst, ffi.Size size);
typedef DartFL_WipeMemory = void Function(ffi.Pointer<ffi.Void> dst, int size);

final class _FLEncoder extends ffi.Opaque {}

typedef FLEncoder = ffi.Pointer<_FLEncoder>;

final class _FLDoc extends ffi.Opaque {}

typedef FLDoc = ffi.Pointer<_FLDoc>;

final class _FLSharedKeys extends ffi.Opaque {}

typedef FLSharedKeys = ffi.Pointer<_FLSharedKeys>;

/// Error codes returned from some API calls.
enum FLError {
  kFLNoError(0),
  kFLMemoryError(1),
  kFLOutOfRange(2),
  kFLInvalidData(3),
  kFLEncodeError(4),
  kFLJSONError(5),
  kFLUnknownValue(6),
  kFLInternalError(7),
  kFLNotFound(8),
  kFLSharedKeysStateError(9),
  kFLPOSIXError(10),
  kFLUnsupported(11);

  final int value;
  const FLError(this.value);

  static FLError fromValue(int value) => switch (value) {
        0 => kFLNoError,
        1 => kFLMemoryError,
        2 => kFLOutOfRange,
        3 => kFLInvalidData,
        4 => kFLEncodeError,
        5 => kFLJSONError,
        6 => kFLUnknownValue,
        7 => kFLInternalError,
        8 => kFLNotFound,
        9 => kFLSharedKeysStateError,
        10 => kFLPOSIXError,
        11 => kFLUnsupported,
        _ => throw ArgumentError("Unknown value for FLError: $value"),
      };
}

/// Specifies whether not input data is trusted to be 100% valid Fleece.
enum FLTrust {
  /// Input data is not trusted to be valid, and will be fully validated by the
  /// API call.
  kFLUntrusted(0),

  /// Input data is trusted to be valid. The API will perform only minimal
  /// validation when reading it. This is faster than kFLUntrusted, but should
  /// only be used if the data was generated by a trusted encoder and has not
  /// been altered or corrupted. For example, this can be used to parse Fleece
  /// data previously stored by your code in local storage. If invalid data is
  /// read by this call, subsequent calls to Value accessor functions can crash
  /// or return bogus results (including data from arbitrary memory locations.)
  kFLTrusted(1);

  final int value;
  const FLTrust(this.value);

  static FLTrust fromValue(int value) => switch (value) {
        0 => kFLUntrusted,
        1 => kFLTrusted,
        _ => throw ArgumentError("Unknown value for FLTrust: $value"),
      };
}

/// A point in time, expressed as milliseconds since the Unix epoch (1-1-1970
/// midnight UTC.)
typedef FLTimestamp = ffi.Int64;
typedef DartFLTimestamp = int;
typedef NativeFLTimestamp_Now = FLTimestamp Function();
typedef DartFLTimestamp_Now = int Function();
typedef NativeFLTimestamp_ToString = FLStringResult Function(
    FLTimestamp timestamp, ffi.Bool asUTC);
typedef DartFLTimestamp_ToString = FLStringResult Function(
    int timestamp, bool asUTC);
typedef NativeFLTimestamp_FromString = FLTimestamp Function(FLString str);
typedef DartFLTimestamp_FromString = int Function(FLString str);
typedef NativeFLArray_Count = ffi.Uint32 Function(FLArray arg0);
typedef DartFLArray_Count = int Function(FLArray arg0);
typedef NativeFLArray_IsEmpty = ffi.Bool Function(FLArray arg0);
typedef DartFLArray_IsEmpty = bool Function(FLArray arg0);
typedef NativeFLArray_AsMutable = FLMutableArray Function(FLArray arg0);
typedef DartFLArray_AsMutable = FLMutableArray Function(FLArray arg0);
typedef NativeFLArray_Get = FLValue Function(FLArray arg0, ffi.Uint32 index);
typedef DartFLArray_Get = FLValue Function(FLArray arg0, int index);

/// Opaque array iterator. Declare one on the stack and pass its address to
/// `FLArrayIteratorBegin`.
final class FLArrayIterator extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _private1;

  @ffi.Uint32()
  external int _private2;

  @ffi.Bool()
  external bool _private3;

  external ffi.Pointer<ffi.Void> _private4;
}

typedef NativeFLArrayIterator_Begin = ffi.Void Function(
    FLArray arg0, ffi.Pointer<FLArrayIterator> arg1);
typedef DartFLArrayIterator_Begin = void Function(
    FLArray arg0, ffi.Pointer<FLArrayIterator> arg1);
typedef NativeFLArrayIterator_GetValue = FLValue Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef DartFLArrayIterator_GetValue = FLValue Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef NativeFLArrayIterator_GetValueAt = FLValue Function(
    ffi.Pointer<FLArrayIterator> arg0, ffi.Uint32 offset);
typedef DartFLArrayIterator_GetValueAt = FLValue Function(
    ffi.Pointer<FLArrayIterator> arg0, int offset);
typedef NativeFLArrayIterator_GetCount = ffi.Uint32 Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef DartFLArrayIterator_GetCount = int Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef NativeFLArrayIterator_Next = ffi.Bool Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef DartFLArrayIterator_Next = bool Function(
    ffi.Pointer<FLArrayIterator> arg0);
typedef NativeFLDict_Count = ffi.Uint32 Function(FLDict arg0);
typedef DartFLDict_Count = int Function(FLDict arg0);
typedef NativeFLDict_IsEmpty = ffi.Bool Function(FLDict arg0);
typedef DartFLDict_IsEmpty = bool Function(FLDict arg0);
typedef NativeFLDict_AsMutable = FLMutableDict Function(FLDict arg0);
typedef DartFLDict_AsMutable = FLMutableDict Function(FLDict arg0);
typedef NativeFLDict_Get = FLValue Function(FLDict arg0, FLSlice keyString);
typedef DartFLDict_Get = FLValue Function(FLDict arg0, FLSlice keyString);

/// Opaque dictionary iterator. Declare one on the stack, and pass its address
/// to FLDictIterator_Begin.
final class FLDictIterator extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _private1;

  @ffi.Uint32()
  external int _private2;

  @ffi.Bool()
  external bool _private3;

  external ffi.Pointer<ffi.Void> _private4;

  external ffi.Pointer<ffi.Void> _private5;

  external ffi.Pointer<ffi.Void> _private6;

  external ffi.Pointer<ffi.Void> _private7;

  @ffi.Int()
  external int _private8;
}

typedef NativeFLDictIterator_Begin = ffi.Void Function(
    FLDict arg0, ffi.Pointer<FLDictIterator> arg1);
typedef DartFLDictIterator_Begin = void Function(
    FLDict arg0, ffi.Pointer<FLDictIterator> arg1);
typedef NativeFLDictIterator_GetKey = FLValue Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_GetKey = FLValue Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef NativeFLDictIterator_GetKeyString = FLString Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_GetKeyString = FLString Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef NativeFLDictIterator_GetValue = FLValue Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_GetValue = FLValue Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef NativeFLDictIterator_GetCount = ffi.Uint32 Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_GetCount = int Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef NativeFLDictIterator_Next = ffi.Bool Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_Next = bool Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef NativeFLDictIterator_End = ffi.Void Function(
    ffi.Pointer<FLDictIterator> arg0);
typedef DartFLDictIterator_End = void Function(
    ffi.Pointer<FLDictIterator> arg0);

/// Opaque key for a dictionary. You are responsible for creating space for
/// these; they can go on the stack, on the heap, inside other objects,
/// anywhere. Be aware that the lookup operations that use these will write into
/// the struct to store "hints" that speed up future searches.
final class FLDictKey extends ffi.Struct {
  external FLSlice private1;

  external ffi.Pointer<ffi.Void> private2;

  @ffi.Uint32()
  external int private3;

  @ffi.Uint32()
  external int private4;

  @ffi.Bool()
  external bool private5;
}

typedef NativeFLDictKey_Init = FLDictKey Function(FLSlice string);
typedef DartFLDictKey_Init = FLDictKey Function(FLSlice string);
typedef NativeFLDictKey_GetString = FLString Function(
    ffi.Pointer<FLDictKey> arg0);
typedef DartFLDictKey_GetString = FLString Function(
    ffi.Pointer<FLDictKey> arg0);
typedef NativeFLDict_GetWithKey = FLValue Function(
    FLDict arg0, ffi.Pointer<FLDictKey> arg1);
typedef DartFLDict_GetWithKey = FLValue Function(
    FLDict arg0, ffi.Pointer<FLDictKey> arg1);

final class _FLDeepIterator extends ffi.Opaque {}

typedef FLDeepIterator = ffi.Pointer<_FLDeepIterator>;
typedef NativeFLDeepIterator_New = FLDeepIterator Function(FLValue arg0);
typedef DartFLDeepIterator_New = FLDeepIterator Function(FLValue arg0);
typedef NativeFLDeepIterator_Free = ffi.Void Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_Free = void Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetValue = FLValue Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_GetValue = FLValue Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetParent = FLValue Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_GetParent = FLValue Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetKey = FLSlice Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_GetKey = FLSlice Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetIndex = ffi.Uint32 Function(
    FLDeepIterator arg0);
typedef DartFLDeepIterator_GetIndex = int Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetDepth = ffi.Size Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_GetDepth = int Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_SkipChildren = ffi.Void Function(
    FLDeepIterator arg0);
typedef DartFLDeepIterator_SkipChildren = void Function(FLDeepIterator arg0);
typedef NativeFLDeepIterator_Next = ffi.Bool Function(FLDeepIterator arg0);
typedef DartFLDeepIterator_Next = bool Function(FLDeepIterator arg0);

final class FLPathComponent extends ffi.Struct {
  /// < Dict key, or kFLSliceNull if none
  external FLSlice key;

  /// < Array index, only if there's no key
  @ffi.Uint32()
  external int index;
}

typedef NativeFLDeepIterator_GetPath = ffi.Void Function(
    FLDeepIterator arg0,
    ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
    ffi.Pointer<ffi.Size> outDepth);
typedef DartFLDeepIterator_GetPath = void Function(
    FLDeepIterator arg0,
    ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
    ffi.Pointer<ffi.Size> outDepth);
typedef NativeFLDeepIterator_GetPathString = FLSliceResult Function(
    FLDeepIterator arg0);
typedef DartFLDeepIterator_GetPathString = FLSliceResult Function(
    FLDeepIterator arg0);
typedef NativeFLDeepIterator_GetJSONPointer = FLSliceResult Function(
    FLDeepIterator arg0);
typedef DartFLDeepIterator_GetJSONPointer = FLSliceResult Function(
    FLDeepIterator arg0);
typedef NativeFLDoc_FromResultData = FLDoc Function(FLSliceResult data,
    ffi.UnsignedInt arg1, FLSharedKeys arg2, FLSlice externData);
typedef DartFLDoc_FromResultData = FLDoc Function(
    FLSliceResult data, int arg1, FLSharedKeys arg2, FLSlice externData);
typedef NativeFLDoc_Release = ffi.Void Function(FLDoc arg0);
typedef DartFLDoc_Release = void Function(FLDoc arg0);
typedef NativeFLDoc_Retain = FLDoc Function(FLDoc arg0);
typedef DartFLDoc_Retain = FLDoc Function(FLDoc arg0);
typedef NativeFLDoc_GetData = FLSlice Function(FLDoc arg0);
typedef DartFLDoc_GetData = FLSlice Function(FLDoc arg0);
typedef NativeFLDoc_GetAllocedData = FLSliceResult Function(FLDoc arg0);
typedef DartFLDoc_GetAllocedData = FLSliceResult Function(FLDoc arg0);
typedef NativeFLDoc_GetRoot = FLValue Function(FLDoc arg0);
typedef DartFLDoc_GetRoot = FLValue Function(FLDoc arg0);
typedef NativeFLDoc_GetSharedKeys = FLSharedKeys Function(FLDoc arg0);
typedef DartFLDoc_GetSharedKeys = FLSharedKeys Function(FLDoc arg0);
typedef NativeFLValue_FindDoc = FLDoc Function(FLValue arg0);
typedef DartFLValue_FindDoc = FLDoc Function(FLValue arg0);
typedef NativeFLDoc_SetAssociated = ffi.Bool Function(
    FLDoc doc, ffi.Pointer<ffi.Void> pointer, ffi.Pointer<ffi.Char> type);
typedef DartFLDoc_SetAssociated = bool Function(
    FLDoc doc, ffi.Pointer<ffi.Void> pointer, ffi.Pointer<ffi.Char> type);
typedef NativeFLDoc_GetAssociated = ffi.Pointer<ffi.Void> Function(
    FLDoc doc, ffi.Pointer<ffi.Char> type);
typedef DartFLDoc_GetAssociated = ffi.Pointer<ffi.Void> Function(
    FLDoc doc, ffi.Pointer<ffi.Char> type);

/// Output formats a FLEncoder can generate.
enum FLEncoderFormat {
  /// < Fleece encoding
  kFLEncodeFleece(0),

  /// < JSON encoding
  kFLEncodeJSON(1),

  /// < [JSON5](http://json5.org), an extension of JSON with a more readable
  /// syntax
  kFLEncodeJSON5(2);

  final int value;
  const FLEncoderFormat(this.value);

  static FLEncoderFormat fromValue(int value) => switch (value) {
        0 => kFLEncodeFleece,
        1 => kFLEncodeJSON,
        2 => kFLEncodeJSON5,
        _ => throw ArgumentError("Unknown value for FLEncoderFormat: $value"),
      };
}

typedef NativeFLEncoder_New = FLEncoder Function();
typedef DartFLEncoder_New = FLEncoder Function();
typedef NativeFLEncoder_NewWithOptions = FLEncoder Function(
    ffi.UnsignedInt format, ffi.Size reserveSize, ffi.Bool uniqueStrings);
typedef DartFLEncoder_NewWithOptions = FLEncoder Function(
    int format, int reserveSize, bool uniqueStrings);

final class __sbuf extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _base;

  @ffi.Int()
  external int _size;
}

typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;
typedef __darwin_off_t = __int64_t;
typedef fpos_t = __darwin_off_t;

final class __sFILEX extends ffi.Opaque {}

final class __sFILE extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _p;

  @ffi.Int()
  external int _r;

  @ffi.Int()
  external int _w;

  @ffi.Short()
  external int _flags;

  @ffi.Short()
  external int _file;

  external __sbuf _bf;

  @ffi.Int()
  external int _lbfsize;

  external ffi.Pointer<ffi.Void> _cookie;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
      _close;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _read;

  external ffi.Pointer<
      ffi.NativeFunction<
          fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>> _seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _write;

  external __sbuf _ub;

  external ffi.Pointer<__sFILEX> _extra;

  @ffi.Int()
  external int _ur;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedChar> _ubuf;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.UnsignedChar> _nbuf;

  external __sbuf _lb;

  @ffi.Int()
  external int _blksize;

  @fpos_t()
  external int _offset;
}

typedef FILE = __sFILE;
typedef NativeFLEncoder_NewWritingToFile = FLEncoder Function(
    ffi.Pointer<FILE> arg0, ffi.Bool uniqueStrings);
typedef DartFLEncoder_NewWritingToFile = FLEncoder Function(
    ffi.Pointer<FILE> arg0, bool uniqueStrings);
typedef NativeFLEncoder_Free = ffi.Void Function(FLEncoder arg0);
typedef DartFLEncoder_Free = void Function(FLEncoder arg0);
typedef NativeFLEncoder_SetSharedKeys = ffi.Void Function(
    FLEncoder arg0, FLSharedKeys arg1);
typedef DartFLEncoder_SetSharedKeys = void Function(
    FLEncoder arg0, FLSharedKeys arg1);
typedef NativeFLEncoder_SetExtraInfo = ffi.Void Function(
    FLEncoder arg0, ffi.Pointer<ffi.Void> info);
typedef DartFLEncoder_SetExtraInfo = void Function(
    FLEncoder arg0, ffi.Pointer<ffi.Void> info);
typedef NativeFLEncoder_GetExtraInfo = ffi.Pointer<ffi.Void> Function(
    FLEncoder arg0);
typedef DartFLEncoder_GetExtraInfo = ffi.Pointer<ffi.Void> Function(
    FLEncoder arg0);
typedef NativeFLEncoder_Reset = ffi.Void Function(FLEncoder arg0);
typedef DartFLEncoder_Reset = void Function(FLEncoder arg0);
typedef NativeFLEncoder_BytesWritten = ffi.Size Function(FLEncoder arg0);
typedef DartFLEncoder_BytesWritten = int Function(FLEncoder arg0);
typedef NativeFLEncoder_WriteNull = ffi.Bool Function(FLEncoder arg0);
typedef DartFLEncoder_WriteNull = bool Function(FLEncoder arg0);
typedef NativeFLEncoder_WriteUndefined = ffi.Bool Function(FLEncoder arg0);
typedef DartFLEncoder_WriteUndefined = bool Function(FLEncoder arg0);
typedef NativeFLEncoder_WriteBool = ffi.Bool Function(
    FLEncoder arg0, ffi.Bool arg1);
typedef DartFLEncoder_WriteBool = bool Function(FLEncoder arg0, bool arg1);
typedef NativeFLEncoder_WriteInt = ffi.Bool Function(
    FLEncoder arg0, ffi.Int64 arg1);
typedef DartFLEncoder_WriteInt = bool Function(FLEncoder arg0, int arg1);
typedef NativeFLEncoder_WriteUInt = ffi.Bool Function(
    FLEncoder arg0, ffi.Uint64 arg1);
typedef DartFLEncoder_WriteUInt = bool Function(FLEncoder arg0, int arg1);
typedef NativeFLEncoder_WriteFloat = ffi.Bool Function(
    FLEncoder arg0, ffi.Float arg1);
typedef DartFLEncoder_WriteFloat = bool Function(FLEncoder arg0, double arg1);
typedef NativeFLEncoder_WriteDouble = ffi.Bool Function(
    FLEncoder arg0, ffi.Double arg1);
typedef DartFLEncoder_WriteDouble = bool Function(FLEncoder arg0, double arg1);
typedef NativeFLEncoder_WriteString = ffi.Bool Function(
    FLEncoder arg0, FLString arg1);
typedef DartFLEncoder_WriteString = bool Function(
    FLEncoder arg0, FLString arg1);
typedef NativeFLEncoder_WriteDateString = ffi.Bool Function(
    FLEncoder encoder, FLTimestamp ts, ffi.Bool asUTC);
typedef DartFLEncoder_WriteDateString = bool Function(
    FLEncoder encoder, int ts, bool asUTC);
typedef NativeFLEncoder_WriteData = ffi.Bool Function(
    FLEncoder arg0, FLSlice arg1);
typedef DartFLEncoder_WriteData = bool Function(FLEncoder arg0, FLSlice arg1);
typedef NativeFLEncoder_WriteValue = ffi.Bool Function(
    FLEncoder arg0, FLValue arg1);
typedef DartFLEncoder_WriteValue = bool Function(FLEncoder arg0, FLValue arg1);
typedef NativeFLEncoder_BeginArray = ffi.Bool Function(
    FLEncoder arg0, ffi.Size reserveCount);
typedef DartFLEncoder_BeginArray = bool Function(
    FLEncoder arg0, int reserveCount);
typedef NativeFLEncoder_EndArray = ffi.Bool Function(FLEncoder arg0);
typedef DartFLEncoder_EndArray = bool Function(FLEncoder arg0);
typedef NativeFLEncoder_BeginDict = ffi.Bool Function(
    FLEncoder arg0, ffi.Size reserveCount);
typedef DartFLEncoder_BeginDict = bool Function(
    FLEncoder arg0, int reserveCount);
typedef NativeFLEncoder_WriteKey = ffi.Bool Function(
    FLEncoder arg0, FLString arg1);
typedef DartFLEncoder_WriteKey = bool Function(FLEncoder arg0, FLString arg1);
typedef NativeFLEncoder_WriteKeyValue = ffi.Bool Function(
    FLEncoder arg0, FLValue arg1);
typedef DartFLEncoder_WriteKeyValue = bool Function(
    FLEncoder arg0, FLValue arg1);
typedef NativeFLEncoder_EndDict = ffi.Bool Function(FLEncoder arg0);
typedef DartFLEncoder_EndDict = bool Function(FLEncoder arg0);
typedef NativeFLEncoder_WriteRaw = ffi.Bool Function(
    FLEncoder arg0, FLSlice arg1);
typedef DartFLEncoder_WriteRaw = bool Function(FLEncoder arg0, FLSlice arg1);
typedef NativeFLEncoder_FinishDoc = FLDoc Function(
    FLEncoder arg0, ffi.Pointer<ffi.UnsignedInt> outError);
typedef DartFLEncoder_FinishDoc = FLDoc Function(
    FLEncoder arg0, ffi.Pointer<ffi.UnsignedInt> outError);
typedef NativeFLEncoder_Finish = FLSliceResult Function(
    FLEncoder arg0, ffi.Pointer<ffi.UnsignedInt> outError);
typedef DartFLEncoder_Finish = FLSliceResult Function(
    FLEncoder arg0, ffi.Pointer<ffi.UnsignedInt> outError);
typedef NativeFLEncoder_GetError = ffi.UnsignedInt Function(FLEncoder arg0);
typedef DartFLEncoder_GetError = int Function(FLEncoder arg0);
typedef NativeFLEncoder_GetErrorMessage = ffi.Pointer<ffi.Char> Function(
    FLEncoder arg0);
typedef DartFLEncoder_GetErrorMessage = ffi.Pointer<ffi.Char> Function(
    FLEncoder arg0);
typedef NativeFLValue_ToJSON = FLStringResult Function(FLValue arg0);
typedef DartFLValue_ToJSON = FLStringResult Function(FLValue arg0);
typedef NativeFLValue_ToJSON5 = FLStringResult Function(FLValue arg0);
typedef DartFLValue_ToJSON5 = FLStringResult Function(FLValue arg0);
typedef NativeFLValue_ToJSONX = FLStringResult Function(
    FLValue v, ffi.Bool json5, ffi.Bool canonicalForm);
typedef DartFLValue_ToJSONX = FLStringResult Function(
    FLValue v, bool json5, bool canonicalForm);
typedef NativeFLDoc_FromJSON = FLDoc Function(
    FLSlice json, ffi.Pointer<ffi.UnsignedInt> outError);
typedef DartFLDoc_FromJSON = FLDoc Function(
    FLSlice json, ffi.Pointer<ffi.UnsignedInt> outError);
typedef NativeFLMutableArray_NewFromJSON = FLMutableArray Function(
    FLString json, ffi.Pointer<ffi.UnsignedInt> outError);
typedef DartFLMutableArray_NewFromJSON = FLMutableArray Function(
    FLString json, ffi.Pointer<ffi.UnsignedInt> outError);
typedef NativeFLMutableDict_NewFromJSON = FLMutableDict Function(
    FLString json, ffi.Pointer<ffi.UnsignedInt> outError);
typedef DartFLMutableDict_NewFromJSON = FLMutableDict Function(
    FLString json, ffi.Pointer<ffi.UnsignedInt> outError);
typedef NativeFLEncoder_ConvertJSON = ffi.Bool Function(
    FLEncoder arg0, FLSlice json);
typedef DartFLEncoder_ConvertJSON = bool Function(FLEncoder arg0, FLSlice json);

final class _FLKeyPath extends ffi.Opaque {}

typedef FLKeyPath = ffi.Pointer<_FLKeyPath>;
typedef NativeFLKeyPath_New = FLKeyPath Function(
    FLSlice specifier, ffi.Pointer<ffi.UnsignedInt> outError);
typedef DartFLKeyPath_New = FLKeyPath Function(
    FLSlice specifier, ffi.Pointer<ffi.UnsignedInt> outError);
typedef NativeFLKeyPath_Free = ffi.Void Function(FLKeyPath arg0);
typedef DartFLKeyPath_Free = void Function(FLKeyPath arg0);
typedef NativeFLKeyPath_Eval = FLValue Function(FLKeyPath arg0, FLValue root);
typedef DartFLKeyPath_Eval = FLValue Function(FLKeyPath arg0, FLValue root);
typedef NativeFLKeyPath_EvalOnce = FLValue Function(
    FLSlice specifier, FLValue root, ffi.Pointer<ffi.UnsignedInt> outError);
typedef DartFLKeyPath_EvalOnce = FLValue Function(
    FLSlice specifier, FLValue root, ffi.Pointer<ffi.UnsignedInt> outError);
typedef NativeFLKeyPath_ToString = FLStringResult Function(FLKeyPath path);
typedef DartFLKeyPath_ToString = FLStringResult Function(FLKeyPath path);
typedef NativeFLKeyPath_Equals = ffi.Bool Function(
    FLKeyPath path1, FLKeyPath path2);
typedef DartFLKeyPath_Equals = bool Function(FLKeyPath path1, FLKeyPath path2);
typedef NativeFLKeyPath_GetElement = ffi.Bool Function(
    FLKeyPath arg0,
    ffi.Size i,
    ffi.Pointer<FLSlice> outDictKey,
    ffi.Pointer<ffi.Int32> outArrayIndex);
typedef DartFLKeyPath_GetElement = bool Function(FLKeyPath arg0, int i,
    ffi.Pointer<FLSlice> outDictKey, ffi.Pointer<ffi.Int32> outArrayIndex);

/// Types of Fleece values. Basically JSON, with the addition of Data (raw
/// blob).
enum FLValueType {
  /// < Type of a NULL pointer, i.e. no such value, like JSON `undefined`. Also
  /// the type of \ref kFLUndefinedValue, and of a value created by \ref
  /// FLEncoder_WriteUndefined().
  kFLUndefined(-1),

  /// < Equivalent to a JSON 'null'
  kFLNull(0),

  /// < A `true` or `false` value
  kFLBoolean(1),

  /// < A numeric value, either integer or floating-point
  kFLNumber(2),

  /// < A string
  kFLString(3),

  /// < Binary data (no JSON equivalent)
  kFLData(4),

  /// < An array of values
  kFLArray(5),

  /// < A mapping of strings to values (AKA "object" in JSON.)
  kFLDict(6);

  final int value;
  const FLValueType(this.value);

  static FLValueType fromValue(int value) => switch (value) {
        -1 => kFLUndefined,
        0 => kFLNull,
        1 => kFLBoolean,
        2 => kFLNumber,
        3 => kFLString,
        4 => kFLData,
        5 => kFLArray,
        6 => kFLDict,
        _ => throw ArgumentError("Unknown value for FLValueType: $value"),
      };
}

typedef NativeFLValue_GetType = ffi.Int Function(FLValue arg0);
typedef DartFLValue_GetType = int Function(FLValue arg0);
typedef NativeFLValue_IsInteger = ffi.Bool Function(FLValue arg0);
typedef DartFLValue_IsInteger = bool Function(FLValue arg0);
typedef NativeFLValue_IsUnsigned = ffi.Bool Function(FLValue arg0);
typedef DartFLValue_IsUnsigned = bool Function(FLValue arg0);
typedef NativeFLValue_IsDouble = ffi.Bool Function(FLValue arg0);
typedef DartFLValue_IsDouble = bool Function(FLValue arg0);
typedef NativeFLValue_AsBool = ffi.Bool Function(FLValue arg0);
typedef DartFLValue_AsBool = bool Function(FLValue arg0);
typedef NativeFLValue_AsInt = ffi.Int64 Function(FLValue arg0);
typedef DartFLValue_AsInt = int Function(FLValue arg0);
typedef NativeFLValue_AsUnsigned = ffi.Uint64 Function(FLValue arg0);
typedef DartFLValue_AsUnsigned = int Function(FLValue arg0);
typedef NativeFLValue_AsFloat = ffi.Float Function(FLValue arg0);
typedef DartFLValue_AsFloat = double Function(FLValue arg0);
typedef NativeFLValue_AsDouble = ffi.Double Function(FLValue arg0);
typedef DartFLValue_AsDouble = double Function(FLValue arg0);
typedef NativeFLValue_AsString = FLString Function(FLValue arg0);
typedef DartFLValue_AsString = FLString Function(FLValue arg0);
typedef NativeFLValue_AsTimestamp = FLTimestamp Function(FLValue arg0);
typedef DartFLValue_AsTimestamp = int Function(FLValue arg0);
typedef NativeFLValue_AsData = FLSlice Function(FLValue arg0);
typedef DartFLValue_AsData = FLSlice Function(FLValue arg0);
typedef NativeFLValue_AsArray = FLArray Function(FLValue arg0);
typedef DartFLValue_AsArray = FLArray Function(FLValue arg0);
typedef NativeFLValue_AsDict = FLDict Function(FLValue arg0);
typedef DartFLValue_AsDict = FLDict Function(FLValue arg0);
typedef NativeFLValue_ToString = FLStringResult Function(FLValue arg0);
typedef DartFLValue_ToString = FLStringResult Function(FLValue arg0);
typedef NativeFLValue_IsEqual = ffi.Bool Function(FLValue v1, FLValue v2);
typedef DartFLValue_IsEqual = bool Function(FLValue v1, FLValue v2);
typedef NativeFLValue_IsMutable = ffi.Bool Function(FLValue arg0);
typedef DartFLValue_IsMutable = bool Function(FLValue arg0);
typedef NativeFLValue_Retain = FLValue Function(FLValue arg0);
typedef DartFLValue_Retain = FLValue Function(FLValue arg0);
typedef NativeFLValue_Release = ffi.Void Function(FLValue arg0);
typedef DartFLValue_Release = void Function(FLValue arg0);

/// Option flags for making mutable copies of values.
enum FLCopyFlags {
  /// < Shallow copy. References immutables instead of copying.
  kFLDefaultCopy(0),

  /// < Deep copy of mutable values
  kFLDeepCopy(1),

  /// < Makes mutable copies of immutables instead of just refs.
  kFLCopyImmutables(2),

  /// < Both deep-copy and copy-immutables.
  kFLDeepCopyImmutables(3);

  final int value;
  const FLCopyFlags(this.value);

  static FLCopyFlags fromValue(int value) => switch (value) {
        0 => kFLDefaultCopy,
        1 => kFLDeepCopy,
        2 => kFLCopyImmutables,
        3 => kFLDeepCopyImmutables,
        _ => throw ArgumentError("Unknown value for FLCopyFlags: $value"),
      };
}

typedef NativeFLArray_MutableCopy = FLMutableArray Function(
    FLArray arg0, ffi.UnsignedInt arg1);
typedef DartFLArray_MutableCopy = FLMutableArray Function(
    FLArray arg0, int arg1);
typedef NativeFLMutableArray_New = FLMutableArray Function();
typedef DartFLMutableArray_New = FLMutableArray Function();
typedef NativeFLMutableArray_GetSource = FLArray Function(FLMutableArray arg0);
typedef DartFLMutableArray_GetSource = FLArray Function(FLMutableArray arg0);
typedef NativeFLMutableArray_IsChanged = ffi.Bool Function(FLMutableArray arg0);
typedef DartFLMutableArray_IsChanged = bool Function(FLMutableArray arg0);
typedef NativeFLMutableArray_SetChanged = ffi.Void Function(
    FLMutableArray arg0, ffi.Bool changed);
typedef DartFLMutableArray_SetChanged = void Function(
    FLMutableArray arg0, bool changed);
typedef NativeFLMutableArray_Insert = ffi.Void Function(
    FLMutableArray array, ffi.Uint32 firstIndex, ffi.Uint32 count);
typedef DartFLMutableArray_Insert = void Function(
    FLMutableArray array, int firstIndex, int count);
typedef NativeFLMutableArray_Remove = ffi.Void Function(
    FLMutableArray array, ffi.Uint32 firstIndex, ffi.Uint32 count);
typedef DartFLMutableArray_Remove = void Function(
    FLMutableArray array, int firstIndex, int count);
typedef NativeFLMutableArray_Resize = ffi.Void Function(
    FLMutableArray array, ffi.Uint32 size);
typedef DartFLMutableArray_Resize = void Function(
    FLMutableArray array, int size);
typedef NativeFLMutableArray_GetMutableArray = FLMutableArray Function(
    FLMutableArray arg0, ffi.Uint32 index);
typedef DartFLMutableArray_GetMutableArray = FLMutableArray Function(
    FLMutableArray arg0, int index);
typedef NativeFLMutableArray_GetMutableDict = FLMutableDict Function(
    FLMutableArray arg0, ffi.Uint32 index);
typedef DartFLMutableArray_GetMutableDict = FLMutableDict Function(
    FLMutableArray arg0, int index);
typedef NativeFLDict_MutableCopy = FLMutableDict Function(
    FLDict source, ffi.UnsignedInt arg1);
typedef DartFLDict_MutableCopy = FLMutableDict Function(
    FLDict source, int arg1);
typedef NativeFLMutableDict_New = FLMutableDict Function();
typedef DartFLMutableDict_New = FLMutableDict Function();
typedef NativeFLMutableDict_GetSource = FLDict Function(FLMutableDict arg0);
typedef DartFLMutableDict_GetSource = FLDict Function(FLMutableDict arg0);
typedef NativeFLMutableDict_IsChanged = ffi.Bool Function(FLMutableDict arg0);
typedef DartFLMutableDict_IsChanged = bool Function(FLMutableDict arg0);
typedef NativeFLMutableDict_SetChanged = ffi.Void Function(
    FLMutableDict arg0, ffi.Bool arg1);
typedef DartFLMutableDict_SetChanged = void Function(
    FLMutableDict arg0, bool arg1);
typedef NativeFLMutableDict_Remove = ffi.Void Function(
    FLMutableDict arg0, FLString key);
typedef DartFLMutableDict_Remove = void Function(
    FLMutableDict arg0, FLString key);
typedef NativeFLMutableDict_RemoveAll = ffi.Void Function(FLMutableDict arg0);
typedef DartFLMutableDict_RemoveAll = void Function(FLMutableDict arg0);
typedef NativeFLMutableDict_GetMutableArray = FLMutableArray Function(
    FLMutableDict arg0, FLString key);
typedef DartFLMutableDict_GetMutableArray = FLMutableArray Function(
    FLMutableDict arg0, FLString key);
typedef NativeFLMutableDict_GetMutableDict = FLMutableDict Function(
    FLMutableDict arg0, FLString key);
typedef DartFLMutableDict_GetMutableDict = FLMutableDict Function(
    FLMutableDict arg0, FLString key);
typedef NativeFLValue_NewString = FLValue Function(FLString arg0);
typedef DartFLValue_NewString = FLValue Function(FLString arg0);
typedef NativeFLValue_NewData = FLValue Function(FLSlice arg0);
typedef DartFLValue_NewData = FLValue Function(FLSlice arg0);
typedef NativeFLMutableArray_Set = FLSlot Function(
    FLMutableArray arg0, ffi.Uint32 index);
typedef DartFLMutableArray_Set = FLSlot Function(
    FLMutableArray arg0, int index);
typedef NativeFLMutableArray_Append = FLSlot Function(FLMutableArray arg0);
typedef DartFLMutableArray_Append = FLSlot Function(FLMutableArray arg0);
typedef NativeFLMutableDict_Set = FLSlot Function(
    FLMutableDict arg0, FLString key);
typedef DartFLMutableDict_Set = FLSlot Function(
    FLMutableDict arg0, FLString key);
typedef NativeFLSlot_SetNull = ffi.Void Function(FLSlot arg0);
typedef DartFLSlot_SetNull = void Function(FLSlot arg0);
typedef NativeFLSlot_SetBool = ffi.Void Function(FLSlot arg0, ffi.Bool arg1);
typedef DartFLSlot_SetBool = void Function(FLSlot arg0, bool arg1);
typedef NativeFLSlot_SetInt = ffi.Void Function(FLSlot arg0, ffi.Int64 arg1);
typedef DartFLSlot_SetInt = void Function(FLSlot arg0, int arg1);
typedef NativeFLSlot_SetUInt = ffi.Void Function(FLSlot arg0, ffi.Uint64 arg1);
typedef DartFLSlot_SetUInt = void Function(FLSlot arg0, int arg1);
typedef NativeFLSlot_SetFloat = ffi.Void Function(FLSlot arg0, ffi.Float arg1);
typedef DartFLSlot_SetFloat = void Function(FLSlot arg0, double arg1);
typedef NativeFLSlot_SetDouble = ffi.Void Function(
    FLSlot arg0, ffi.Double arg1);
typedef DartFLSlot_SetDouble = void Function(FLSlot arg0, double arg1);
typedef NativeFLSlot_SetString = ffi.Void Function(FLSlot arg0, FLString arg1);
typedef DartFLSlot_SetString = void Function(FLSlot arg0, FLString arg1);
typedef NativeFLSlot_SetData = ffi.Void Function(FLSlot arg0, FLSlice arg1);
typedef DartFLSlot_SetData = void Function(FLSlot arg0, FLSlice arg1);
typedef NativeFLSlot_SetValue = ffi.Void Function(FLSlot arg0, FLValue arg1);
typedef DartFLSlot_SetValue = void Function(FLSlot arg0, FLValue arg1);
typedef NativeFLCreateJSONDelta = FLSliceResult Function(
    FLValue old, FLValue nuu);
typedef DartFLCreateJSONDelta = FLSliceResult Function(
    FLValue old, FLValue nuu);
typedef NativeFLEncodeJSONDelta = ffi.Bool Function(
    FLValue old, FLValue nuu, FLEncoder jsonEncoder);
typedef DartFLEncodeJSONDelta = bool Function(
    FLValue old, FLValue nuu, FLEncoder jsonEncoder);
typedef NativeFLApplyJSONDelta = FLSliceResult Function(
    FLValue old, FLSlice jsonDelta, ffi.Pointer<ffi.UnsignedInt> outError);
typedef DartFLApplyJSONDelta = FLSliceResult Function(
    FLValue old, FLSlice jsonDelta, ffi.Pointer<ffi.UnsignedInt> outError);
typedef NativeFLEncodeApplyingJSONDelta = ffi.Bool Function(
    FLValue old, FLSlice jsonDelta, FLEncoder encoder);
typedef DartFLEncodeApplyingJSONDelta = bool Function(
    FLValue old, FLSlice jsonDelta, FLEncoder encoder);
typedef NativeFLSharedKeys_New = FLSharedKeys Function();
typedef DartFLSharedKeys_New = FLSharedKeys Function();
typedef FLSharedKeysReadCallbackFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void>, FLSharedKeys);
typedef DartFLSharedKeysReadCallbackFunction = bool Function(
    ffi.Pointer<ffi.Void>, FLSharedKeys);
typedef FLSharedKeysReadCallback
    = ffi.Pointer<ffi.NativeFunction<FLSharedKeysReadCallbackFunction>>;
typedef NativeFLSharedKeys_NewWithRead = FLSharedKeys Function(
    FLSharedKeysReadCallback arg0, ffi.Pointer<ffi.Void> context);
typedef DartFLSharedKeys_NewWithRead = FLSharedKeys Function(
    FLSharedKeysReadCallback arg0, ffi.Pointer<ffi.Void> context);
typedef NativeFLSharedKeys_GetStateData = FLSliceResult Function(
    FLSharedKeys arg0);
typedef DartFLSharedKeys_GetStateData = FLSliceResult Function(
    FLSharedKeys arg0);
typedef NativeFLSharedKeys_LoadStateData = ffi.Bool Function(
    FLSharedKeys arg0, FLSlice arg1);
typedef DartFLSharedKeys_LoadStateData = bool Function(
    FLSharedKeys arg0, FLSlice arg1);
typedef NativeFLSharedKeys_WriteState = ffi.Void Function(
    FLSharedKeys arg0, FLEncoder arg1);
typedef DartFLSharedKeys_WriteState = void Function(
    FLSharedKeys arg0, FLEncoder arg1);
typedef NativeFLSharedKeys_LoadState = ffi.Bool Function(
    FLSharedKeys arg0, FLValue arg1);
typedef DartFLSharedKeys_LoadState = bool Function(
    FLSharedKeys arg0, FLValue arg1);
typedef NativeFLSharedKeys_Encode = ffi.Int Function(
    FLSharedKeys arg0, FLString arg1, ffi.Bool add);
typedef DartFLSharedKeys_Encode = int Function(
    FLSharedKeys arg0, FLString arg1, bool add);
typedef NativeFLSharedKeys_Decode = FLString Function(
    FLSharedKeys arg0, ffi.Int key);
typedef DartFLSharedKeys_Decode = FLString Function(FLSharedKeys arg0, int key);
typedef NativeFLSharedKeys_Count = ffi.UnsignedInt Function(FLSharedKeys arg0);
typedef DartFLSharedKeys_Count = int Function(FLSharedKeys arg0);
typedef NativeFLSharedKeys_RevertToCount = ffi.Void Function(
    FLSharedKeys arg0, ffi.UnsignedInt oldCount);
typedef DartFLSharedKeys_RevertToCount = void Function(
    FLSharedKeys arg0, int oldCount);
typedef NativeFLSharedKeys_Retain = FLSharedKeys Function(FLSharedKeys arg0);
typedef DartFLSharedKeys_Retain = FLSharedKeys Function(FLSharedKeys arg0);
typedef NativeFLSharedKeys_Release = ffi.Void Function(FLSharedKeys arg0);
typedef DartFLSharedKeys_Release = void Function(FLSharedKeys arg0);

final class _FLSharedKeyScope extends ffi.Opaque {}

typedef FLSharedKeyScope = ffi.Pointer<_FLSharedKeyScope>;
typedef NativeFLSharedKeyScope_WithRange = FLSharedKeyScope Function(
    FLSlice range, FLSharedKeys arg1);
typedef DartFLSharedKeyScope_WithRange = FLSharedKeyScope Function(
    FLSlice range, FLSharedKeys arg1);
typedef NativeFLSharedKeyScope_Free = ffi.Void Function(FLSharedKeyScope arg0);
typedef DartFLSharedKeyScope_Free = void Function(FLSharedKeyScope arg0);
typedef NativeFLValue_FromData = FLValue Function(
    FLSlice data, ffi.UnsignedInt trust);
typedef DartFLValue_FromData = FLValue Function(FLSlice data, int trust);
typedef NativeFLJSON5_ToJSON = FLStringResult Function(
    FLString json5,
    ffi.Pointer<FLStringResult> outErrorMessage,
    ffi.Pointer<ffi.Size> outErrorPos,
    ffi.Pointer<ffi.UnsignedInt> outError);
typedef DartFLJSON5_ToJSON = FLStringResult Function(
    FLString json5,
    ffi.Pointer<FLStringResult> outErrorMessage,
    ffi.Pointer<ffi.Size> outErrorPos,
    ffi.Pointer<ffi.UnsignedInt> outError);
typedef NativeFLData_ConvertJSON = FLSliceResult Function(
    FLSlice json, ffi.Pointer<ffi.UnsignedInt> outError);
typedef DartFLData_ConvertJSON = FLSliceResult Function(
    FLSlice json, ffi.Pointer<ffi.UnsignedInt> outError);
typedef NativeFLEncoder_Amend = ffi.Void Function(
    FLEncoder e, FLSlice base, ffi.Bool reuseStrings, ffi.Bool externPointers);
typedef DartFLEncoder_Amend = void Function(
    FLEncoder e, FLSlice base, bool reuseStrings, bool externPointers);
typedef NativeFLEncoder_GetBase = FLSlice Function(FLEncoder arg0);
typedef DartFLEncoder_GetBase = FLSlice Function(FLEncoder arg0);
typedef NativeFLEncoder_SuppressTrailer = ffi.Void Function(FLEncoder arg0);
typedef DartFLEncoder_SuppressTrailer = void Function(FLEncoder arg0);
typedef NativeFLEncoder_GetNextWritePos = ffi.Size Function(FLEncoder arg0);
typedef DartFLEncoder_GetNextWritePos = int Function(FLEncoder arg0);
typedef NativeFLEncoder_LastValueWritten = ffi.IntPtr Function(FLEncoder arg0);
typedef DartFLEncoder_LastValueWritten = int Function(FLEncoder arg0);
typedef NativeFLEncoder_WriteValueAgain = ffi.Void Function(
    FLEncoder arg0, ffi.IntPtr preWrittenValue);
typedef DartFLEncoder_WriteValueAgain = void Function(
    FLEncoder arg0, int preWrittenValue);
typedef NativeFLEncoder_Snip = FLSliceResult Function(FLEncoder arg0);
typedef DartFLEncoder_Snip = FLSliceResult Function(FLEncoder arg0);
typedef NativeFLEncoder_FinishItem = ffi.Size Function(FLEncoder arg0);
typedef DartFLEncoder_FinishItem = int Function(FLEncoder arg0);
typedef NativeFLJSONEncoder_NextDocument = ffi.Void Function(FLEncoder arg0);
typedef DartFLJSONEncoder_NextDocument = void Function(FLEncoder arg0);
typedef NativeFLDump = ffi.Pointer<ffi.Char> Function(FLValue arg0);
typedef DartFLDump = ffi.Pointer<ffi.Char> Function(FLValue arg0);
typedef NativeFLDumpData = ffi.Pointer<ffi.Char> Function(FLSlice data);
typedef DartFLDumpData = ffi.Pointer<ffi.Char> Function(FLSlice data);
typedef NativeFLData_Dump = FLStringResult Function(FLSlice data);
typedef DartFLData_Dump = FLStringResult Function(FLSlice data);

const int kCBLDomain = 1;

const int kCBLPOSIXDomain = 2;

const int kCBLSQLiteDomain = 3;

const int kCBLFleeceDomain = 4;

const int kCBLNetworkDomain = 5;

const int kCBLWebSocketDomain = 6;

const int kCBLErrorAssertionFailed = 1;

const int kCBLErrorUnimplemented = 2;

const int kCBLErrorUnsupportedEncryption = 3;

const int kCBLErrorBadRevisionID = 4;

const int kCBLErrorCorruptRevisionData = 5;

const int kCBLErrorNotOpen = 6;

const int kCBLErrorNotFound = 7;

const int kCBLErrorConflict = 8;

const int kCBLErrorInvalidParameter = 9;

const int kCBLErrorUnexpectedError = 10;

const int kCBLErrorCantOpenFile = 11;

const int kCBLErrorIOError = 12;

const int kCBLErrorMemoryError = 13;

const int kCBLErrorNotWriteable = 14;

const int kCBLErrorCorruptData = 15;

const int kCBLErrorBusy = 16;

const int kCBLErrorNotInTransaction = 17;

const int kCBLErrorTransactionNotClosed = 18;

const int kCBLErrorUnsupported = 19;

const int kCBLErrorNotADatabaseFile = 20;

const int kCBLErrorWrongFormat = 21;

const int kCBLErrorCrypto = 22;

const int kCBLErrorInvalidQuery = 23;

const int kCBLErrorMissingIndex = 24;

const int kCBLErrorInvalidQueryParam = 25;

const int kCBLErrorRemoteError = 26;

const int kCBLErrorDatabaseTooOld = 27;

const int kCBLErrorDatabaseTooNew = 28;

const int kCBLErrorBadDocID = 29;

const int kCBLErrorCantUpgradeDatabase = 30;

const int kCBLNetErrDNSFailure = 1;

const int kCBLNetErrUnknownHost = 2;

const int kCBLNetErrTimeout = 3;

const int kCBLNetErrInvalidURL = 4;

const int kCBLNetErrTooManyRedirects = 5;

const int kCBLNetErrTLSHandshakeFailed = 6;

const int kCBLNetErrTLSCertExpired = 7;

const int kCBLNetErrTLSCertUntrusted = 8;

const int kCBLNetErrTLSClientCertRequired = 9;

const int kCBLNetErrTLSClientCertRejected = 10;

const int kCBLNetErrTLSCertUnknownRoot = 11;

const int kCBLNetErrInvalidRedirect = 12;

const int kCBLNetErrUnknown = 13;

const int kCBLNetErrTLSCertRevoked = 14;

const int kCBLNetErrTLSCertNameMismatch = 15;

const int kCBLSeekModeFromStart = 0;

const int kCBLSeekModeRelative = 1;

const int kCBLSeekModeFromEnd = 2;

const int kCBLConcurrencyControlLastWriteWins = 0;

const int kCBLConcurrencyControlFailOnConflict = 1;

const int kCBLJSONLanguage = 0;

const int kCBLN1QLLanguage = 1;

const int kCBLEncryptionNone = 0;

const int kCBLEncryptionAES256 = 1;

const int kCBLEncryptionKeySizeAES256 = 32;

const int kCBLMaintenanceTypeCompact = 0;

const int kCBLMaintenanceTypeReindex = 1;

const int kCBLMaintenanceTypeIntegrityCheck = 2;

const int kCBLMaintenanceTypeOptimize = 3;

const int kCBLMaintenanceTypeFullOptimize = 4;

const int kCBLReplicatorTypePushAndPull = 0;

const int kCBLReplicatorTypePush = 1;

const int kCBLReplicatorTypePull = 2;

const int kCBLDocumentFlagsDeleted = 1;

const int kCBLDocumentFlagsAccessRemoved = 2;

const int kCBLProxyHTTP = 0;

const int kCBLProxyHTTPS = 1;

const int kCBLReplicatorStopped = 0;

const int kCBLReplicatorOffline = 1;

const int kCBLReplicatorConnecting = 2;

const int kCBLReplicatorIdle = 3;

const int kCBLReplicatorBusy = 4;

const int kCBLLogDomainDatabase = 0;

const int kCBLLogDomainQuery = 1;

const int kCBLLogDomainReplicator = 2;

const int kCBLLogDomainNetwork = 3;

const int kCBLLogDebug = 0;

const int kCBLLogVerbose = 1;

const int kCBLLogInfo = 2;

const int kCBLLogWarning = 3;

const int kCBLLogError = 4;

const int kCBLLogNone = 5;

const String CBLITE_VERSION = '3.1.6';

const int CBLITE_VERSION_NUMBER = 3001006;

const int CBLITE_BUILD_NUMBER = 6;

const String CBLITE_SOURCE_ID = '093eaca';

const String CBLITE_BUILD_TIMESTAMP = '2024-02-28T23:03:08Z';

const String HOTLEVEL = 'Ofast';

const String COLDLEVEL = 'Oz';

const int FLTimestampNone = -9223372036854775808;
